{"words":[{"name":"__preambles__","effect":"","markdown":"a block\n","primer":"a block","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"@:","effect":"( F @: N -- ):","markdown":"creates an opener entry with the given Name in caller. Submits Form to the entry. Opener entries, when resolved to and opened, in turn **open** their corresponding Form.\n\n```\n\"Blocks are evaluated (opened) when the opener entry\nthey're stored under is opened.\"\n[ 1 2 + ] @: getThree\ngetThree leaves: [ 3 ]\n\n\"Builtins also get opened when under an opener entry.\"\n#+ here @: myAddAlias\n1 2 myAddAlias leaves: [ 3 ]\n\n\"Any other form is left as-is, even if it is a word.\"\n3 @: litThree\n#+ @: litPlus\nlitThree leaves: [ 3 ]\nlitPlus leaves: [ + ]\n```\n","primer":"creates an opener entry with the given Name in caller.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[0,1],[1,1]],"outbound":[]},{"name":"$:","effect":"( F $: N -- ):","markdown":"creates a pusher entry with the given Name in caller. Submits Form to the entry. Pusher entries, when resolved to and opened, **push** their corresponding Form onto the active stack.\n\n```\n100 $: x\n200 $: y\n\nx leaves: 100\ny leaves: 200\n\n[ 1 2 + ] $: getThree\n\n\"Nope! In this case, use `@:` if you want the block to be\n opened (evaluated).\"\ngetThree leaves: [ 1 2 + ]\n```\n","primer":"creates a pusher entry with the given Name in caller.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[0,2],[1,2]],"outbound":[]},{"name":"=:","effect":"( F =: N -- ):","markdown":"submits Form to an entry with the given Name.\n\nThe entry must exist already, being defined by `$:`, `@:`, or otherwise. Entry type is disregarded (i.e. it doesn't matter whether it's an opener or a pusher entry). More importantly, *entry type is preserved.*\n\n```\n\"Note, by the way, that order doesn't matter. What\n matters is for `x` to be there at the time of calling\n `addOneToX`. In other words, `addOneToX` must be able to\n find `x` when it's opened.\"\n\n100 $: x\n\n[ x 1 + =: x ] @: addOneToX\n\nx leaves: 100\naddOneToX\nx leaves: 101\n\"...\"\n```\n","primer":"submits Form to an entry with the given Name.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[1,3],[0,3]],"outbound":[1,2]},{"name":"2die","effect":"( Qm F -- ):","markdown":"enquotes Form, stitches it to the end of Quote message, and dies with the resulting quote set as the death message.\n\n```\n'expected foobar, got: ' 100 2die \"Sorry: expected foobar, got: 100.\"\n```\n","primer":"enquotes Form, stitches it to the end of Quote message, and dies with the resulting quote set as the death message.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[1,4],[2,4]],"outbound":[]},{"name":"needsCapability:","effect":"( needsCapability: I -- ):","markdown":"ensures that the frontend has enabled the capability with the specified Id. Dies if such a capability isn't enabled, or if Id isn't a capability id at all.\n","primer":"ensures that the frontend has enabled the capability with the specified Id.","takes":[[0,0]],"leaves":[],"erefs":[[3,5]],"outbound":[]},{"name":"top?","effect":"( B -- Tf true / false ):","markdown":"leaves Top form in Block followed by `true` if there is one, otherwise leaves `false` only.\n\nTop form is the form before the cursor in Block.\n\n```\n[ ] top? leaves: false\n[ 1 2 3 | ] top? leaves: [ 3 true ]\n[ 1 2 | 3 ] top? leaves: [ 2 true ]\n[ 1 | 2 3 ] top? leaves: [ 1 true ]\n[ | 1 2 3 ] top? leaves: false\n```\n","primer":"leaves Top form in Block followed by `true` if there is one, otherwise leaves `false` only.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[4,6],[5,6]],"outbound":[]},{"name":"peek?","effect":"( [ ... | F ... ]B -- F true / false ):","markdown":"leaves Form and/ or a boolean for whether Form exists in Block.\n\n```\n[ 1 | 2 3 ] peek? leaves: [ 2 true ]\n[ 1 2 3 | ] peek? leaves: false\n```\n","primer":"leaves Form and/ or a boolean for whether Form exists in Block.","takes":[[1,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,7],[1,7]],"outbound":[]},{"name":"|atLeftBound?","effect":"( B -- true/false ):","markdown":"leaves whether cursor is at the left end in Block.\n\n```\n[ | ] |atLeftBound? leaves: true\n[ 1 | ] |atLeftBound? leaves: false\n[ | 1 2 3 ] |atLeftBound? leaves: true\n[ 1 | 2 3 ] |atLeftBound? leaves: false\n[ 1 2 3 | ] |atLeftBound? leaves: false\n```\n","primer":"leaves whether cursor is at the left end in Block.","takes":[[0,0]],"leaves":[],"erefs":[[5,8]],"outbound":[]},{"name":"|atRightBound?","effect":"( B -- true/false ):","markdown":"leaves whether cursor is at the right end in Block.\n\n```\n[ | ] |atRightBound? leaves: true\n[ 1 | ] |atRightBound? leaves: true\n[ | 1 2 3 ] |atRightBound? leaves: false\n[ 1 | 2 3 ] |atRightBound? leaves: false\n[ 1 2 3 | ] |atRightBound? leaves: true\n```\n","primer":"leaves whether cursor is at the right end in Block.","takes":[[0,0]],"leaves":[],"erefs":[[5,9]],"outbound":[]},{"name":"|afterFirst?","effect":"( B -- true/false ):","markdown":"leaves whether cursor is after the first form in Block.\n\n```\n[ | ] |afterFirst? leaves: false\n[ 1 | ] |afterFirst? leaves: true\n[ 1 | 2 3 ] |afterFirst? leaves: true\n[ 1 2 3 | ] |afterFirst? leaves: false\n```\n","primer":"leaves whether cursor is after the first form in Block.","takes":[[0,0]],"leaves":[],"erefs":[[5,10]],"outbound":[]},{"name":"|-","effect":"( B N -- ):","markdown":"decrements block cursor position: moves cursor back N times in Block.\n\n```\n[ 1 2 3 | ] dup 2 |- leaves: [ [ 1 | 2 3 ] ]\n```\n","primer":"decrements block cursor position: moves cursor back N times in Block.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[6,11],[5,11]],"outbound":[]},{"name":"|+","effect":"( B N -- ):","markdown":"increments block cursor position: moves cursor forward N times in Block.\n\n```\n[ 1 2 3 ] $: block\nblock 1 |to\nblock leaves: [ [ 1 | 2 3 ] ]\nblock 1 |+\nblock leaves: [ [ 1 2 | 3 ] ]\nblock 1 |+\nblock leaves: [ [ 1 2 3 | ] ]\n```\n","primer":"increments block cursor position: moves cursor forward N times in Block.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[6,12],[5,12]],"outbound":[]},{"name":"|:","effect":"( S |: F -- S ):","markdown":"infix version of `there`.\n\nLike `there`, preserves `ahead`. Leaves the opener block dirty due to this.\n\n```\n([ 1 2 3 ] |: 100) leaves: [ 1 2 3 100 ]\n([ 1 2 3 ] |: +) leaves: [ [ 1 5 ] ]\n([ 1 2 3 ] |: swap) leaves: [ [ 1 3 2 ] ]\n\n[ 100 ] |: [ ahead thru + ] 200 123 leaves: [ 300 123 ]\n```\n","primer":"infix version of `there`.","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[7,378]],"outbound":[378,370]},{"name":"|clamp","effect":"( B N -- ):","markdown":"moves the cursor in Block to N. If N is negative, the cursor is moved to 0. If N is greater than the amount of forms in Block, the cursor is moved to the end of Block.\n\n```\n[ 1 2 3 ] $: x\nx 1 |clamp\nx leaves: [ [ 1 | 2 3 ] ]\nx 1000 |clamp\nx leaves: [ [ 1 2 3 | ] ]\nx -1000 |clamp\nx leaves: [ [ | 1 2 3 ] ]\n```\n","primer":"moves the cursor in Block to N. If N is negative, the cursor is moved to 0.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[5,14],[6,14]],"outbound":[]},{"name":"|hydrate","effect":"( Lb N B -- ):","markdown":"moves the cursor in List block to N, then hydrates List block with Block. After Block had executed *successfully*, moves the cursor in List block back to where it was before `|hydrate` (clamped to either end, if necessary).\n\n```\n[ 1 | 2 3 ] $: x\n\nx 2 [ + ] |hydrate\nx leaves: [ [ 3 | 3 ] ]\n\nx 2 [ 2drop ] |hydrate\nx leaves: [ [ ] ]\n```\n","primer":"moves the cursor in List block to N, then hydrates List block with Block.","takes":[[2,0],[0,0],[1,0]],"leaves":[],"erefs":[[6,15],[5,15],[8,15]],"outbound":[]},{"name":"|swap","effect":"( -- ):","markdown":"swaps the item before and after cursor in the active stack.\n\n```\n[ 1 2 | 3 ] $: block\nblock [ |swap ] there\nblock leaves: [ [ 1 3 | 2  ] ]\n```\n","primer":"swaps the item before and after cursor in the active stack.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"gulp","effect":"( F B -- ):","markdown":"`shove`s Form into Block, drops both.\n\n```\n3 [ 1 2 ] keep: gulp leaves: [ [ 1 2 3 ] ]\n```\n","primer":"`shove`s Form into Block, drops both.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[1,17],[5,17]],"outbound":[462]},{"name":"spit","effect":"( [ ... F | ... ]B -- F [ ... | ... ]B ] ):","markdown":"`cherry`s Form from Block onto the active stack, placing it before the Block. Inverse of `gulp`.\n\n```\n[ 1 2 3 ] spit leaves: [ 3 [ 1 2 ] ]\n```\n","primer":"`cherry`s Form from Block onto the active stack, placing it before the Block.","takes":[[0,0],[1,0]],"leaves":[[0,0],[1,0]],"erefs":[[1,18],[5,18]],"outbound":[17,461]},{"name":"<<","effect":"( [ ... | ... ]B F -- [ ... F | ... ]B ):","markdown":"`shove`s Form into Block, leaves only Block.\n\n```\n[ 1 2 ] 3 << leaves: [ [ 1 2 3 ] ]\n```\n","primer":"`shove`s Form into Block, leaves only Block.","takes":[[1,0],[0,0]],"leaves":[[0,0],[1,0]],"erefs":[[1,19],[5,19]],"outbound":[462]},{"name":">>","effect":"( [ ... F | ... ]B -- [ ... | ... ]B F ):","markdown":"`cherry`s Form from Block, leaves both. Inverse of `&lt;&lt;`.\n\n```\n[ 1 2 3 ] >> leaves: [ [ 1 2 ] 3 ]\n```\n","primer":"`cherry`s Form from Block, leaves both.","takes":[[0,0],[1,0]],"leaves":[[1,0],[0,0]],"erefs":[[1,20],[5,20]],"outbound":[461]},{"name":"enclose","effect":"( F -- [ F ]B ):","markdown":"encloses Form in a new, orphan Block.\n\n```\n'Hi!' enclose leaves: [ [ 'Hi!' ] ]\n```\n","primer":"encloses Form in a new, orphan Block.","takes":[[0,0]],"leaves":[[0,0],[1,0]],"erefs":[[1,21],[5,21]],"outbound":[]},{"name":"2enclose","effect":"( X Y -- [ X Y ]B ):","markdown":"encloses X and Y, a pair of forms, in a new, orphan Block.\n\n```\n'Hello' 'World' 2enclose leaves: [ [ 'Hello' 'World' ] ]\n```\n","primer":"encloses X and Y, a pair of forms, in a new, orphan Block.","takes":[[0,0],[1,0]],"leaves":[[0,0],[1,0],[2,0]],"erefs":[[9,22],[10,22],[5,22]],"outbound":[]},{"name":"first","effect":"( B -- F ):","markdown":"leaves first Form in Block. Dies if Block is empty.\n\n```\n[ 0 ] first leaves: 0\n[ 1 2 3 ] first leaves: 1\n```\n","primer":"leaves first Form in Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[1,23],[5,23]],"outbound":[]},{"name":"first?","effect":"( B -- F true / false ):","markdown":"leaves first Form in Block followed by true if Block is non-empty. Leaves false if Block is empty.\n\n```\n[ ] first? leaves: [ false ]\n[ 1 2 3 ] first? leaves: [ 1 true ]\n```\n","primer":"leaves first Form in Block followed by true if Block is non-empty.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[1,24],[5,24]],"outbound":[]},{"name":"last","effect":"( B -- F ):","markdown":"leaves last Form in Block. Dies if Block is empty.\n\n```\n[ 0 ] last leaves: 0\n[ 1 2 3 ] last leaves: 3\n```\n","primer":"leaves last Form in Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[1,25],[5,25]],"outbound":[]},{"name":"last?","effect":"( B -- F true / false ):","markdown":"leaves last Form in Block followed by true if Block is non-empty. Leaves false if Block is empty.\n\n```\n[ ] last? leaves: [ false ]\n[ 1 2 3 ] last? leaves: [ 3 true ]\n```\n","primer":"leaves last Form in Block followed by true if Block is non-empty.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[1,26],[5,26]],"outbound":[]},{"name":"startsWith?","effect":"( B/Q F/Fq -- Sb ):","markdown":"leaves Status boolean for whether Block ends with Form (as per `=`), or Quote ends with Fragment quote.\n\nAlways leaves true if Form or Fragment quote is empty.\n\n```\n'hello world' 'h' startsWith? leaves: true\n'hello world' 'hello' startsWith? leaves: true\n'hello world' 'world' startsWith? leaves: false\n\n[ 1 2 3 ] 1 startsWith? leaves: true\n[ 1 2 3 ] 3 startsWith? leaves: false\n```\n","primer":"leaves Status boolean for whether Block ends with Form (as per `=`), or Quote ends with Fragment quote.","takes":[[1,0],[2,0],[3,0],[4,0]],"leaves":[[0,0]],"erefs":[[11,27],[5,27],[12,27],[1,27],[13,27]],"outbound":[386]},{"name":"endsWith?","effect":"( B/Q F/Fq -- Sb ):","markdown":"leaves Status boolean for whether Block ends with Form (as per `=`), or if Quote ends with Fragment quote.\n\nAlways leaves true if Form or Fragment quote is empty.\n\n```\n'hello world' 'd' endsWith? leaves: true\n'hello world' 'world' endsWith? leaves: true\n'hello world' 'hello' endsWith? leaves: false\n\n[ 1 2 3 ] 3 endsWith? leaves: true\n[ 1 2 3 ] 1 endsWith? leaves: false\n```\n","primer":"leaves Status boolean for whether Block ends with Form (as per `=`), or if Quote ends with Fragment quote.","takes":[[1,0],[2,0],[3,0],[4,0]],"leaves":[[0,0]],"erefs":[[11,28],[5,28],[12,28],[1,28],[13,28]],"outbound":[386]},{"name":"surroundedBy?","effect":"( B/Q Bf/Bq Ef/Eq -- true/false ):","markdown":"leaves whether Block/Quote starts with Begin form/Begin quote, and ends with End form/ End quote.\n\n```\n[ 1 2 3 ] 1 3 surroundedBy? leaves: true\n'[[hello world]]' '[[' ']]' surroundedBy? leaves: true\n```\n","primer":"leaves whether Block/Quote starts with Begin form/Begin quote, and ends with End form/ End quote.","takes":[[0,0],[1,0],[2,0],[3,0],[4,0],[5,0]],"leaves":[],"erefs":[[5,29],[12,29],[14,29],[15,29],[16,29],[17,29]],"outbound":[]},{"name":"adopt","effect":"( P C -- C ):","markdown":"same as `reparent`, but in different order.\n","primer":"same as `reparent`, but in different order.","takes":[[1,0],[0,0]],"leaves":[[0,0]],"erefs":[[18,478],[19,478]],"outbound":[478]},{"name":"--","effect":"( P `--` C -- C ):","markdown":"infix version of `adopt`.\n\n```\n[ 100 $: x ] obj $: a\n[ 200 $: y ] obj $: b\n\n(a -- b -- a) drop\na -> [x y] leaves: [ [ 100 200 ] ]\nb -> [x y] leaves: [ [ 100 200 ] ]\n```\n","primer":"infix version of `adopt`.","takes":[[1,0],[0,0]],"leaves":[[0,0]],"erefs":[[18,478],[19,478]],"outbound":[30]},{"name":"\u00b7>","effect":"( B \u00b7> F -- F ):","markdown":"infix version of `befriend` that leaves the *friend* for further chaining.\n\n```\n[ 100 $: x ] obj $: a\n[ 200 $: y ] obj $: b\na \u00b7> b \u00b7> a drop\n\na.x leaves: 100\na.y leaves: 200\n\nb.x leaves: 100\nb.y leaves: 200\n\na [ 'Hello World' =: x ] extend\n\na.x leaves: 'Hello World'\na.y leaves: 200\n\nb.x leaves: 'Hello World'\nb.y leaves: 200\n```\n","primer":"infix version of `befriend` that leaves the *friend* for further chaining.","takes":[[1,0],[0,0]],"leaves":[[0,0]],"erefs":[[20,479],[5,479]],"outbound":[479]},{"name":"child","effect":"( B -- Cb ):","markdown":"leaves an empty Child block for Block. Very much like `new`, but doesn't copy the tape and therefore may be faster in certain circumstances.\n","primer":"leaves an empty Child block for Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[21,33],[5,33]],"outbound":[380]},{"name":"->","effect":"( Db -> N -- F ):","markdown":"Resolves Name, a word, using the given Dictionary block (block with a dictionary and/or relatives, therefore, simply any block). Does not distinguish between entry types (i.e., it doesn't matter whether Name resolves to an opener or a pusher entry): its value Form is always *pushed* onto the active stack.\n\n```\n[ 100 $: x 200 $: y [ x y + ] @: sum ] obj $: point\n\npoint -> x leaves: 100\npoint -> y leaves: 200\npoint -> sum leaves: [ [ x y + ] ] \"Beware!\"\n\n\"Note that we still can open it and get the result:\"\nopen leaves: 300\n```\n\nIt is possible to access multiple entries when Name is a block, *preserving block structure*:\n\n```\n[ 100 $: x 200 $: y ] obj -> [ x y ] leaves: [ [ 100 200 ] ]\n[ 100 $: x 200 $: y ] obj -> [ [ [ x ] ] y ] leaves: [ [ [ [ 100 ] ] 200 ] ]\n```\n","primer":"Resolves Name, a word, using the given Dictionary block (block with a dictionary and/or relatives, therefore, simply any block).","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[22,34],[1,34],[0,34]],"outbound":[]},{"name":".","effect":"( Db . N -- ... ):","markdown":"resolves Name in Dictionary block and *opens* it. Infix version of `entry:open`.\n\n`.` is the only word that gets special treatment in Novika, in that it does not need to be surrounded with whitespace when other words must be.\n\n```\n[ 100 $: x 200 $: y [ x y + ] @: sum ] obj $: point\n\npoint.x leaves: 100\npoint.y leaves: 200\npoint.sum leaves: 300\n```\n\nPreserves (carries through) `ahead`, but makes the caller block's instance dirty (which should not cause any trouble from the user's perspective).\n\n```\n[ $: double?\n\n  [ ahead thru double? => [ 2 * ] ] @: bar:\n\n  this\n] @: foo\n\ntrue foo.bar: 100 leaves: [ 200 ]\nfalse foo.bar: 100 leaves: [ 100 ]\n```\n","primer":"resolves Name in Dictionary block and *opens* it.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[0,35],[22,35]],"outbound":[418,370]},{"name":"fetch:","effect":"( Db N fetch: B -- ):","markdown":"resolves Name using Dictionary block, and opens Block with the resolved entry's value form *on top of the caller stack.* If Name could not be resolved using the dictionary block, or if the dictionary block  is something other than block, does nothing. Itself, leaves nothing (unless Block is empty: in that case, leaves the value form if resolved successfully).\n\n```\n'This is not a block!' #x fetch: [ 1 + ] leaves: [ ]\n[ 100 $: x ] obj #x fetch: [ 1 + ] leaves: [ 101 ]\n[ 100 $: x ] obj #undefinedThing fetch: [ 1 + ] leaves: [ ]\n```\n","primer":"resolves Name using Dictionary block, and opens Block with the resolved entry's value form *on top of the caller stack.","takes":[[0,0],[1,0],[2,0]],"leaves":[],"erefs":[[22,36],[0,36],[5,36]],"outbound":[]},{"name":"extendWith","effect":"( S B -- S ):","markdown":"extends Source block with entries from the dictionary of Body block, then instantiates Body block, befriends the instance with Source block, and opens Body block with an empty stack. When the Body block instance finishes running, extends Source block with entries from the instance. Leaves Source block.\n\nAll complexities and edge cases aside, this word is basically one of the ways to redefine/create/modify an entry through computation and from another, possibly unrelated block (unrelated as in via the block graph, that is).\n\n**Important**: Source block is not extended with *private entries* of Body block or Body block instance (that is, entries whose name starts with _underscore). However, Body block does get access and is able to reassign private entries of Source block.\n\nSee `extendWith:` for an example.\n","primer":"extends Source block with entries from the dictionary of Body block, then instantiates Body block, befriends the instance with Source block, and opens Body block with an empty stack.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[23,37],[24,37]],"outbound":[38]},{"name":"extendWith:","effect":"( S extendWith: B -- S ):","markdown":"infix version of `extendWith`.\n\n```\n[ 100 $: x ] obj $: a\n[ 200 $: y ] obj $: b\n\na \u00b7> b \u00b7> a drop\n\na.x a.y leaves: [ 100 200 ]\nb.x b.y leaves: [ 100 200 ]\n\na extendWith: [ [ y y * ] @: x ] drop\nb extendWith: [ 4 =: y ] drop\n\na.x a.y leaves: [ 16 4 ]\nb.x b.y leaves: [ 16 4 ]\n\nb extendWith: [ 100 $: y ] drop\n\na.x a.y leaves: [ 10000 100 ]\nb.x b.y leaves: [ 10000 100 ]\n```\n","primer":"infix version of `extendWith`.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[23,37],[24,37]],"outbound":[37]},{"name":"extend:","effect":"( S extend: B -- ):","markdown":"an alternative infix version of `extendWith` which doesn't leave anything.\n\n```\n[ 100 $: x ] obj $: a\n[ 200 $: y ] obj $: b\n\na \u00b7> b \u00b7> a drop\n\na.x a.y leaves: [ 100 200 ]\nb.x b.y leaves: [ 100 200 ]\n\na extend: [ [ y y * ] @: x ]\nb extend: [ 4 =: y ]\n\na.x a.y leaves: [ 16 4 ]\nb.x b.y leaves: [ 16 4 ]\n\nb extend: [ 100 $: y ]\n\na.x a.y leaves: [ 10000 100 ]\nb.x b.y leaves: [ 10000 100 ]\n```\n","primer":"an alternative infix version of `extendWith` which doesn't leave anything.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[23,37],[24,37]],"outbound":[37]},{"name":"|slideRight","effect":"( Lb B -- Lb ):","markdown":"slides cursor in List block from left to right, in steps of one. Opens Block with List block as the stack *after* each step. Leaves List block. `break` and `next` are available.\n\n```\n[ 1 | 2 3 ] [ + ] |slideRight leaves: [ [ 6 ] ]\n```\n\nIn the table below, sliding step is marked with '*', and block iteration is postfixed by a '+'.\n\n```text\n +------+-------+-------------+\n | #    | form  |    list     |\n +======+=======+=============+\n | 0    |       | [ 1 2 3 ]   |\n | 1    | 1 |to | [ 1 | 2 3 ] |\n | *    |       | [ 1 2 | 3 ] |\n | 3+   |    +  | [ 3 | 3 ]   |\n | *    |       | [ 3 3 ]     |\n | 5+   |    +  | [ 6 ]       |\n +------+-------+-------------+\n```\n","primer":"slides cursor in List block from left to right, in steps of one.","takes":[[1,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,40],[8,40]],"outbound":[]},{"name":"|->","effect":"( Lb |-> B -- Lb ):","markdown":"infix version of `|slideRight`.\n","primer":"infix version of `|slideRight`.","takes":[[1,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,40],[8,40]],"outbound":[40]},{"name":"|~>","effect":"( Lb |~> B -- Lb ):","markdown":"similar to `|-&gt;`, but remembers the cursor position in List block and restores it after all items were visited by Block (clamping to either end, if necessary).\n\n```\n[ 1 | 2 3 ] $: x\nx |~> [ 1 + ]\nx leaves: [ [ 1 | 3 4 ] ]\n```\n","primer":"similar to `|-&gt;`, but remembers the cursor position in List block and restores it after all items were visited by Block (clamping to either end, if necessary).","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[8,42],[5,42]],"outbound":[]},{"name":"||->","effect":"( Lb ||-> B -- Lb ):","markdown":"same as `|-&gt;`, but moves the cursor to the start of List block first, then executes Block and so on. See `|-&gt;` and especially `|slideRight` for more information on what all of this means.\n\n```\n[ 1 2 3 ] ||-> [ 2 * ] leaves: [ [ 2 4 6 ] ]\n```\n","primer":"same as `|-&gt;`, but moves the cursor to the start of List block first, then executes Block and so on.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[8,43],[5,43]],"outbound":[40]},{"name":"||~>","effect":"( Lb |~> B -- Lb ):","markdown":"similar to `||-&gt;`, but remembers the cursor position in List block and restores it after all items were visited by Block (clamping to either end, if necessary).\n\n```\n[ 1 | 2 3 ] $: x\nx leaves: [ [ 1 | 2 3 ] ]\nx ||~> [ 1 + ]\nx leaves: [ [ 2 | 3 4 ] ]\n```\n","primer":"similar to `||-&gt;`, but remembers the cursor position in List block and restores it after all items were visited by Block (clamping to either end, if necessary).","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[8,44],[5,44]],"outbound":[]},{"name":"|slideLeft","effect":"( Lb B -- Lb ):","markdown":"similar to `|-&gt;`, but slides the cursor from right to left. Consult `|slideRight`. `break` and `next` are available.\n","primer":"similar to `|-&gt;`, but slides the cursor from right to left.","takes":[[1,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,40],[8,40]],"outbound":[40]},{"name":"<-|","effect":"( Lb <-| B -- Lb ):","markdown":"infix version of `|slideLeft`.\n","primer":"infix version of `|slideLeft`.","takes":[[1,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,40],[8,40]],"outbound":[45]},{"name":"eachWithIndex","effect":"( Lb B -- ):","markdown":"opens Block with each item of List block on top of a new stack, and its index below (that is, `Index  Item`). List block is unchanged. `break` and `next` are available.\n\n```\n[ 1 2 3 ] [ 2echo ] eachWithIndex\n\"STDOUT: 0 1\u23ce\"\n\"STDOUT: 1 2\u23ce\"\n\"STDOUT: 2 3\u23ce\"\n```\n","primer":"opens Block with each item of List block on top of a new stack, and its index below (that is, `Index Item`).","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,47],[8,47]],"outbound":[]},{"name":"each","effect":"( Lb B -- ):","markdown":"opens Block with each item of List block on top of a new stack. List block is unchanged. `break` and `next` are available.\n\n```\n[ 1 2 3 ] [ echo ] each\n\"STDOUT: 1\u23ce\"\n\"STDOUT: 2\u23ce\"\n\"STDOUT: 3\u23ce\"\n```\n","primer":"opens Block with each item of List block on top of a new stack.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,48],[8,48]],"outbound":[]},{"name":"each:","effect":"( Lb each: B -- ):","markdown":"infix version of `each`.\n\n```\n[ 1 2 3 ] each: [ echo ]\n\"STDOUT: 1\u23ce\"\n\"STDOUT: 2\u23ce\"\n\"STDOUT: 3\u23ce\"\n```\n","primer":"infix version of `each`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,48],[8,48]],"outbound":[48]},{"name":"eachWithIndex:","effect":"( Lb eachWithIndex: B -- ):","markdown":"infix version of `eachWithIndex`.\n\n```\n[ 1 2 3 ] eachWithIndex: [ 2echo ]\n\"STDOUT: 0 1\u23ce\"\n\"STDOUT: 1 2\u23ce\"\n\"STDOUT: 2 3\u23ce\"\n```\n","primer":"infix version of `eachWithIndex`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,47],[8,47]],"outbound":[47]},{"name":"pairs","effect":"( Lb B -- ):","markdown":"opens Block with pairs of items from List block on top of an empty stack. `break` and `next` are available. Does nothing if List block is empty. Dies if List block has an odd number of forms.\n\n```\n[ 1 2 3 4 ] [ + echo ] pairs\n\"STDOUT: 3\u23ce (i.e., 1 + 2)\"\n\"STDOUT: 7\u23ce (i.e., 3 + 4)\"\n```\n","primer":"opens Block with pairs of items from List block on top of an empty stack.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,51],[8,51]],"outbound":[]},{"name":"pairs:","effect":"( Lb pairs: B -- ):","markdown":"infix version of `pairs`.\n\n```\n[ 1 2 3 4 ] pairs: [ + echo ]\n\"STDOUT: 3\u23ce\"\n\"STDOUT: 7\u23ce\"\n```\n","primer":"infix version of `pairs`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,51],[8,51]],"outbound":[51]},{"name":"mapPairs","effect":"( Lb B -- Rb ):","markdown":"leaves Result block obtained by collecting results of Block opened with previous Result block as the stack, plus a pair of items from List block, for each pair of items in List block. Dies if List block has an odd number of forms. `break` and `next` are available.\n\n```\n\"Sum pairs of numbers 1, 2; 3, 4; 5, 6 etc.:\"\n1 to: 10 mapPairs: + leaves: [ [ 3 7 11 15 19 ] ]\n```\n","primer":"leaves Result block obtained by collecting results of Block opened with previous Result block as the stack, plus a pair of items from List block, for each pair of items in List block.","takes":[[2,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,53],[25,53],[8,53]],"outbound":[]},{"name":"mapPairs:","effect":"( Lb mapPairs: B -- Rb ):","markdown":"infix version of `mapPairs`.\n\n```\n\"Sum pairs of numbers 1, 2; 3, 4; 5, 6 etc.:\"\n1 to: 10 mapPairs: + leaves: [ [ 3 7 11 15 19 ] ]\n```\n","primer":"infix version of `mapPairs`.","takes":[[2,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,53],[25,53],[8,53]],"outbound":[53]},{"name":"consPairs","effect":"( Lb B -- ):","markdown":"opens Block with consequtive pairs of items from List block on top of an empty stack. `break` and `next` are available.\n\n```\n[ ] [ + echo ] consPairs\n[ 1 ] [ + echo ] consPairs\n\"Both do nothing!\"\n\n[ 1 2 ] [ + echo ] consPairs\n\"STDOUT: 3\u23ce (i.e, 1 + 2)\"\n\n[ 1 2 3 ] [ + echo ] consPairs\n\"STDOUT: 3\u23ce (i.e., 1 + 2)\"\n\"STDOUT: 5\u23ce (i.e., 2 + 3)\"\n```\n","primer":"opens Block with consequtive pairs of items from List block on top of an empty stack.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,55],[8,55]],"outbound":[]},{"name":"consPairs:","effect":"( Lb B -- ):","markdown":"infix version of `consPairs`.\n\n```\n[ 1 2 3 ] consPairs: [ + echo ]\n\"STDOUT: 3\u23ce\"\n\"STDOUT: 5\u23ce\"\n```\n","primer":"infix version of `consPairs`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,55],[8,55]],"outbound":[55]},{"name":"mapConsPairs","effect":"( Lb B -- Rb ):","markdown":"leaves Result block obtained by collecting results of Block opened with previous Result block as the stack, plus a **consecutive** pair of items from List block, for each consecutive pair of items in List block. `break` and `next` are available.\n\n```\n\"Sum pairs of numbers 1, 2; 2, 3; 3, 4 etc.:\"\n1 to: 10 mapConsPairs: + leaves: [ [ 3 5 7 9 11 13 15 17 19 ] ]\n```\n","primer":"leaves Result block obtained by collecting results of Block opened with previous Result block as the stack, plus a **consecutive** pair of items from List block, for each consecutive pair of items in List block.","takes":[[2,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,57],[25,57],[8,57]],"outbound":[]},{"name":"mapConsPairs:","effect":"( Lb mapConsPairs: B -- Rb ):","markdown":"infix version of `mapConsPairs`.\n\n```\n\"Sum pairs of numbers 1, 2; 2, 3; 3, 4 etc.:\"\n1 to: 10 mapConsPairs: + leaves: [ [ 3 5 7 9 11 13 15 17 19 ] ]\n```\n","primer":"infix version of `mapConsPairs`.","takes":[[2,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,57],[25,57],[8,57]],"outbound":[57]},{"name":"map","effect":"( Lb B -- Mlb ):","markdown":"opens Block with each item of List block on top of an empty stack. Replaces item in List block with Block's stack top after opening it. Leaves the resulting Modified list block. `break` and `next` are available.\n\n```\n[ 1 2 3 ] [ 1 + ] map leaves: [ [ 2 3 4 ] ] \"(a different block!)\"\n\n[ 1 2 3 ] $: a\na [ 1 + ] map leaves: [ [ 2 3 4 ] ] \"(a different block!)\"\na leaves: [ [ 1 2 3 ] ]\n```\n","primer":"opens Block with each item of List block on top of an empty stack.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[26,59],[5,59],[8,59]],"outbound":[]},{"name":"map:","effect":"( Lb map: B -- MLb ):","markdown":"infix version of `map`.\n\n```\n[ 1 2 3 ] map: [ 1 + ] leaves: [ 2 3 4 ]\n```\n","primer":"infix version of `map`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,59],[8,59]],"outbound":[59]},{"name":"only","effect":"( Lb B -- Rb ):","markdown":"opens Block with each item of List block on top of an empty stack. Removes that item in Result block if Block's stack top is false after it was opened. `break` and `next` are available.\n\n```\n[ ] [ 100 > ] only\n  leaves: [ [ ] ] \"(a different block!)\"\n\n[ 1 2 3 ] [ ] only\n  leaves: [ [ 1 2 3 ] ] \"(a different block!)\"\n\n[ 1 100 2 300 4 600 10 ] [ 100 > ] only\n  leaves: [ [ 300 600 ] ]\n```\n","primer":"opens Block with each item of List block on top of an empty stack.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[8,61],[25,61],[5,61]],"outbound":[]},{"name":"without","effect":"( Lb B -- Rb ):","markdown":"inverse of `only`.\n","primer":"inverse of `only`.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[8,61],[25,61],[5,61]],"outbound":[61]},{"name":"only:","effect":"( Lb only: B -- Rb ):","markdown":"infix version of `only`.\n\n```\n[ 1 100 2 300 4 600 10 ] only: [ 100 > ]\n  leaves: [ [ 300 600 ] ]\n```\n","primer":"infix version of `only`.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[8,61],[25,61],[5,61]],"outbound":[61]},{"name":"without:","effect":"( Lb without: B -- MLb ):","markdown":"infix version of `without`.\n\n```\n[ 1 100 2 300 4 600 10 ] without: [ 100 > ]\n  leaves: [ [ 1 100 2 4 10 ] ]\n```\n","primer":"infix version of `without`.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[8,61],[5,61]],"outbound":[62]},{"name":"reduce","effect":"( Lb B M -- M ):","markdown":"reduces List block using Block. Block is opened with Memo, current item on top of an empty stack. Memo is updated to Block's value after Block is opened. `break` and `next` are available.\n\n```\n[ ] [ + ] 0 reduce\n  leaves:  0\n\n[ 1 ] [ + ] 0 reduce\n  leaves: 1 \"(i.e., 0 + 1)\"\n\n[ 1 2 3 ] [ + ] 0 reduce\n  leaves: 6\n\n[ 'Hellope, ' 'Europe!' ' ' 'Huh?' ] [ stitch ] '' reduce\n  leaves: 'Hellope, Europe! Huh?'\n```\n\nSupports stack reduction:\n\n```\n'1' '2' '3' stack [ stitch ] '' reduce\n  leaves: '123'\n```\n","primer":"reduces List block using Block.","takes":[[0,0],[2,0],[1,0]],"leaves":[[1,0]],"erefs":[[8,65],[27,65],[5,65]],"outbound":[]},{"name":"amount","effect":"( Lb B -- A ):","markdown":"leaves the Amount of items for which Block, when opened with an item from List block on top of an empty stack, leaves a truthy form. `break` and `next` are available.\n\n```\n[ 1 2 3 ] [ 2 > ] amount leaves: 1\n[ 1 2 3 ] [ 100 > ] amount leaves: 0\n[ 1 5000 2 4400 1 100 102 ] [ 100 <= ] amount\n  leaves: 4 \"(i.e., 1, 2, 1, 100)\"\n\n```\n","primer":"leaves the Amount of items for which Block, when opened with an item from List block on top of an empty stack, leaves a truthy form.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[28,66],[5,66],[8,66]],"outbound":[]},{"name":"#","effect":"( Lb B -- A ):","markdown":"infix version of `amount`.\n\n```\n[ 1 2 3 ] # [ 2 > ] leaves: 1\n```\n","primer":"infix version of `amount`.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[28,66],[5,66],[8,66]],"outbound":[66]},{"name":"all?","effect":"( Lb B -- true/false ):","markdown":"whether Block leaves true for all items in List block, when opened with each item on top of an empty stack.\n\n```\n[ ] [ 100 < ] all? leaves: true \"BEWARE!\"\n[ 1 2 3 ] [ 100 < ] all? leaves: true\n[ 101 2 3 4 ] [ 100 < ] all?\n  leaves: false \"(i.e., because of 101)\"\n```\n","primer":"whether Block leaves true for all items in List block, when opened with each item on top of an empty stack.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,68],[8,68]],"outbound":[]},{"name":"all:","effect":"( Lb all: B -- true/false ): ","markdown":"infix version of `all?`\n\n```\n[ ] all: even? leaves: true \"BEWARE!\"\n[ 1 2 3 ] all: even? leaves: false\n```\n","primer":"infix version of `all?` ``` [ ] all: even?","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,68],[8,68]],"outbound":[68]},{"name":"any?","effect":"( Lb B -- true/false ):","markdown":"whether Block leaves true for any item in List block, when opened with each item on top of an empty stack.\n\n```\n[ ] [ 100 < ] any? leaves: false \"BEWARE!\"\n[ 1 2 3 ] [ 3 = ] any? leaves: true\n[ 101 3 2000 ] [ 100 < ] any? leaves: true\n[ 1002 350 2000 ] [ 100 < ] any? leaves: false\n```\n","primer":"whether Block leaves true for any item in List block, when opened with each item on top of an empty stack.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,70],[8,70]],"outbound":[]},{"name":"anyof:","effect":"( F anyof: B -- true/false ):","markdown":"infix version of `anyof?`.\n\n```\n100 anyof: [ 1 2 3 ] leaves: false\n#foo anyof: [ foo bar ] leaves: true\n\n[ 1 2 3 ] $: x\n1 anyof: x leaves: true\n#foo anyof: x leaves: false\n```\n","primer":"infix version of `anyof?`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,387],[1,387]],"outbound":[387]},{"name":"zip","effect":"( A B -- Z ):","markdown":"leaves Zipped A, B. Dies if there is a different amount of items in A and B.\n\n```\n[ ] [ ] zip leaves: [ [ ] ]\n[ 1 2 ] [ 3 4 ] zip leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]\n```\n","primer":"leaves Zipped A, B.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[29,72],[30,72],[31,72]],"outbound":[]},{"name":"zipWithDefault","effect":"( A B D -- Zb ):","markdown":"leaves Zipped A, B with holes filled by the given Default form.\n\n```\n[ ] [ ] #hole zipWithDefault leaves: [ [ ] ]\n\n[ 1 2 ] [ 3 4 ] #hole zipWithDefault\n  leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]\n\n[ 1 2 ] [ 3 ] #hole zipWithDefault\n  leaves: [ [ [ 1 3 ] [ 2 hole ] ] ]\n\n[ 1 ] [ 3 4 ] #hole zipWithDefault\n  leaves: [ [ [ 1 3 ] [ hole 4 ] ] ]\n\n```\n","primer":"leaves Zipped A, B with holes filled by the given Default form.","takes":[[0,0],[1,0],[2,0]],"leaves":[],"erefs":[[30,73],[31,73],[32,73]],"outbound":[]},{"name":"zip:","effect":"( A zip: B -- Z | A zip: B withDefault: D -- Z ):","markdown":"combined infix for `zip` and `zipWithDefault`.\n\n```\n[ 1 2 ] zip: [ 3 4 ] leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]\n[ 1 2 ] zip: [ x y ] leaves: [ [ [ 1 x ] [ 2 y ] ] ]\n[ a b ] zip: [ 'Hi!' ] withDefault: 0 leaves: [ [ [ a 'Hi!' ] [ b 0 ] ] ]\n```\n","primer":"combined infix for `zip` and `zipWithDefault`.","takes":[[1,0],[2,0]],"leaves":[[0,0],[1,0],[2,0],[3,0],[0,1]],"erefs":[[29,72],[30,73],[31,73],[32,73]],"outbound":[73,72]},{"name":"conjure","effect":"( S D -- I ):","markdown":"given a Source block and a Destination block, leaves an Instance of the Destination block with all words (see `word?`) replaced with entry values from the dictionary of Source (they are **not** opened), and all quoted words unquoted (see `quotedWord?`). Recurses on sub-blocks.\n\n```\n1 $: x\n2 $: y\n#+ $: plus\n\nthis [ x y plus #dup plus [ ##foo #echo ] #open ] conjure\n  leaves: [ [ 1 2 + dup + [ #foo echo ] #open ] ]\n\nopen leaves: 6\n\"STDOUT: foo\u23ce\"\n```\n","primer":"given a Source block and a Destination block, leaves an Instance of the Destination block with all words (see `word?`) replaced with entry values from the dictionary of Source (they are **not** opened), and all quoted words unquoted (see `quotedWord?`).","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[33,75],[23,75],[34,75]],"outbound":[397,393]},{"name":"here","effect":"( B -- I ):","markdown":"`conjure` with Source block set to caller.\n\n```\n1 $: x\n2 $: y\n#+ $: plus\n\n[ x y plus #dup plus [ ##foo #echo ] #open ] here\n  leaves: [ [ 1 2 + dup + [ #foo echo ] #open ] ]\n\nopen leaves: 6 \"STDOUT: foo\u23ce\"\n```\n","primer":"`conjure` with Source block set to caller.","takes":[],"leaves":[[0,0]],"erefs":[[33,75]],"outbound":[75]},{"name":"minmax","effect":"( Lb -- Min Max ):","markdown":"leaves decimal minimum, maximum in List block. Use `minmaxBy` if List block doesn't (or doesn't always) contain solely decimals. If an empty block is given, dies, so make sure to handle that yourself.\n\n```\n[ 1 2 3 ] minmax leaves: [ 1 3 ]\n```\n","primer":"leaves decimal minimum, maximum in List block.","takes":[[0,0]],"leaves":[],"erefs":[[8,77]],"outbound":[82]},{"name":"min","effect":"( Lb -- Min ):","markdown":"leaves decimal minimum in List block. See `minmax`.\n\n```\n[ 1 2 3 ] min leaves: 1\n```\n","primer":"leaves decimal minimum in List block.","takes":[[0,0]],"leaves":[],"erefs":[[8,78]],"outbound":[77]},{"name":"max","effect":"( Lb -- Max ):","markdown":"leaves decimal maximum in List block. See `minmax`.\n\n```\n[ 1 2 3 ] max leaves: 3\n```\n","primer":"leaves decimal maximum in List block.","takes":[[0,0]],"leaves":[],"erefs":[[8,79]],"outbound":[77]},{"name":"sum","effect":"( Lb -- Sum ):","markdown":"leaves decimal sum of List block elements. For more control (or if not always decimal), use `sumBy`.\n\n```\n[ ] sum leaves: 0\n[ 1 ] sum leaves: 1\n[ 1 2 3 ] sum leaves: 6\n```\n","primer":"leaves decimal sum of List block elements.","takes":[[0,0]],"leaves":[],"erefs":[[8,80]],"outbound":[85]},{"name":"product","effect":"( Lb -- Product ):","markdown":"leaves decimal product of List block elements. For more control (or if not always decimal), take a look at `productBy`.\n\n```\n[ ] product leaves: 1\n[ 3 ] product leaves: 3\n[ 5 4 3 2 ] product leaves: 120\n```\n","primer":"leaves decimal product of List block elements.","takes":[[0,0]],"leaves":[],"erefs":[[8,81]],"outbound":[87]},{"name":"minmaxBy","effect":"( Lb Tb -- Min Max ):","markdown":"leaves the minimum and maximum values in List block. Decimal values are obtained via the Transformation block, which is opened with each element of List block on top of an empty stack. If List block is empty, dies, so make sure to handle that yourself.\n\n```\n[ 1 2 3 ] [ ] minmaxBy leaves: [ 1 3 ]\n[ 'A short quote' 'A loooonger quote' 'Veeeeeeeeeeery long quote' ] [ count ] minmaxBy\n  leaves: [ 'A short quote' 'Veeeeeeeeeeery long quote' ]\n\n```\n","primer":"leaves the minimum and maximum values in List block.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[35,82],[8,82]],"outbound":[]},{"name":"minBy","effect":"( Lb Tb -- Min ):","markdown":"leaves the minimum value in List block. Each element of List block is transformed using Transformation block. See `minmaxBy`.\n\n```\n[ 1 2 3 ] [ ] minBy leaves: 1\n```\n","primer":"leaves the minimum value in List block.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[35,83],[8,83]],"outbound":[82]},{"name":"maxBy","effect":"( Lb Tb -- Max ):","markdown":"leaves the maximum value in List block. Each element of List block is transformed using Transformation block. See `minmaxBy`.\n\n```\n[ 1 2 3 ] [ ] maxBy leaves: 3\n```\n","primer":"leaves the maximum value in List block.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[35,84],[8,84]],"outbound":[82]},{"name":"sumBy","effect":"( Lb Tb -- Sum ):","markdown":"leaves Sum of List block elements transformed into decimals by Transformation block. Similar to `minmaxBy`.\n\n```\n[ 'a' 'aaa' 'aa' ] [ count ] sumBy leaves: 6\n```\n","primer":"leaves Sum of List block elements transformed into decimals by Transformation block.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[8,85],[35,85]],"outbound":[82]},{"name":"sumBy:","effect":"( Lb sumBy: Tb -- Sum ):","markdown":"infix version of `sumBy`.\n\n```\n[ 'a' 'aaa' 'aa' ] sumBy: count leaves: 6\n```\n","primer":"infix version of `sumBy`.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[8,85],[35,85]],"outbound":[85]},{"name":"productBy","effect":"( Lb Tb -- P ):","markdown":"leaves Product of List block elements transformed into decimals by Transformation block. Similar to `sumBy`.\n\n```\n[ 'dave' 'john' ] [ count ] productBy leaves: 16 \"4 * 4\"\n```\n","primer":"leaves Product of List block elements transformed into decimals by Transformation block.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[36,87],[8,87],[35,87]],"outbound":[85]},{"name":"productBy:","effect":"( Lb productBy: Tb -- Sum ):","markdown":"infix version of `productBy`.\n\n```\n[ 'dave' 'john' ] productBy: count leaves: 16 \"4 * 4\"\n```\n","primer":"infix version of `productBy`.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[8,87],[35,87]],"outbound":[87]},{"name":"collect","effect":"( N B -- Lb ):","markdown":"leaves a List block with N results of opening Block with the current N. Basically a combo of `times` and `map`. `break` and `next` are available. The current result is skipped if stack is empty after opening Block.\n\n```\n10 collect: [ [ odd? ] ~> drop ]\n       map: [ 2 * ]\n      only: [ 10 < ]\n    leaves: [ [ 0 4 8 ] ]\n```\n","primer":"leaves a List block with N results of opening Block with the current N. Basically a combo of `times` and `map`.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[8,89],[5,89],[6,89]],"outbound":[59,193]},{"name":"collect:","effect":"( N collect: B -- Lb ):","markdown":"infix version of `collect`.\n","primer":"infix version of `collect`.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[8,89],[5,89],[6,89]],"outbound":[89]},{"name":"compiledCollect","effect":"( N B -- Lb ):","markdown":"same as `collect`, but powered by `compiledTimes` under the hood. Faster than `collect` for large N, but slower if opened a lot of times in a row.\n\nPlease read `compiledTimes` to understand why have the whole deal with *unsafe* and *fast*.\n\nDoes **not** support `break` and `next`.\n","primer":"same as `collect`, but powered by `compiledTimes` under the hood.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[6,91],[8,89],[5,195]],"outbound":[195,89]},{"name":"compiledCollect:","effect":"( N compiledCollect: B -- Lb ):","markdown":"infix version of `compiledCollect`.\n","primer":"infix version of `compiledCollect`.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[6,91],[8,89],[5,195]],"outbound":[91]},{"name":"groupBy","effect":"( B Gb -- Gl ):","markdown":"groups forms in Block according to Grouper block. Leaves a Group list. Grouper block is opened with consequent items on top of an empty stack. Grouper block can leave any form except block. Order of groups in Group list is the same as in Block, i.e., if the first item in Block is is in group G1, then the first group in Group list will be G1.\n\nIf necessary, the form Grouper block leaves for a particular group can be accessed with `.id` on each group block in Group list.\n\nNote though, that Group members do not have access to their Grouper block's `id`.\n\n```\n[ 1 2 3 ] [ 1 > ] groupBy leaves: [ [ [ 1 ] [ 2 3 ] ] ]\n[ 1 2 3 ] [ 1 <= ] groupBy leaves: [ [ [ 1 ] [ 2 3 ] ] ]\n\n[ 1 2 3 ] [ 1 <= ] groupBy [ .id ] map\n  leaves: [ [ true false ] ] \"The two groups, true and false.\"\n\n[ 1 2 3 ] [ 1 <= 'foo' 'bar' sel ] groupBy [ dup .id 2enclose ] map\n  leaves: [ [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ] ]\n```\n","primer":"groups forms in Block according to Grouper block.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[5,93],[37,93],[38,93]],"outbound":[]},{"name":"groupBy:","effect":"( B Gb -- Gl ):","markdown":"infix version of `groupBy`. See `groupBy` for information.\n\n```\n[ 1 2 3 ] groupBy: [ 1 > ] leaves: [ [ [ 1 ] [ 2 3 ] ] ]\n[ 1 2 3 ] groupBy: [ 1 <= ] leaves: [ [ [ 1 ] [ 2 3 ] ] ]\n\n[ 1 2 3 ] groupBy: [ 1 <= ] map: [ .id ]\n  leaves: [ [ true false ] ]\n\n[ 1 2 3 ] groupBy: [ 1 <= 'foo' 'bar' sel ] map: [ dup .id 2enclose ]\n  leaves: [ [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ] ]\n```\n","primer":"infix version of `groupBy`.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[5,93],[37,93],[38,93]],"outbound":[93]},{"name":"range","effect":"( B E -- Rb ):","markdown":"leaves Range block containing decimals between the given Begin, End decimal boundaries: [B; E], [E; B] if  E < B.\n\n```\n\"Note: `...` means there's more. These 'leaves:'\n expressions won't run right away.\"\n\n1 100 range leaves: [ 1 2 3 \"...\" 98 99 100 ]\n-10 10 range leaves: [ -10 -9 -8 \"...\" 8 9 10 ]\n10 0 range leaves: [ 10 9 8 \"...\" 0 ]\n```\n","primer":"leaves Range block containing decimals between the given Begin, End decimal boundaries: [B; E], [E; B] if E < B.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[39,95],[31,95],[40,95]],"outbound":[]},{"name":"to:","effect":"( B to: E -- Rb ):","markdown":"infix version of `range`.\n\n```\n\"Note: `...` means there's more. These 'leaves:'\n expressions won't run right away.\"\n\n1 to: 100 leaves: [ 1 2 3 \"...\" 98 99 100 ]\n10 to: 0 leaves: [ 10 9 8 \"...\" 0 ]\n```\n","primer":"infix version of `range`.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[39,95],[31,95],[40,95]],"outbound":[95]},{"name":"from:","effect":"( B from: Bi to: Ei -- Bs ):","markdown":"takes a slice of Block, starting at Begin index, and ending at End index. Both ends are inclusive. Leaves the resulting Block slice.\n\nBlock slice is an orphan. Both ends are clamped to Block bounds.\n\n```\n[ ] from: 0 to: 0 leaves: [ [ ] ]\n[ 1 2 3 4 ] from: 1 to: 2 leaves: [ [ 2 3 ] ]\n[ 1 2 3 4 ] from: 0 to: 200 leaves: [ [ 1 2 3 4 ] ]\n[ 1 2 3 4 ] from: 100 to: 200 leaves: [ [ ] ]\n```\n","primer":"takes a slice of Block, starting at Begin index, and ending at End index.","takes":[[0,0],[1,0],[2,0]],"leaves":[[3,0]],"erefs":[[5,97],[41,97],[42,97],[43,97]],"outbound":[]},{"name":"join","effect":"( Fl -- Q ):","markdown":"stitches enquoted forms from Form list and leaves the resulting Quote.\n\n```\n[ 'A' 'B' 'C' ] join leaves: 'ABC'\n\n1 $: x\n2 $: y\n[ x '; ' y ] here join leaves: '1; 2'\n```\n","primer":"stitches enquoted forms from Form list and leaves the resulting Quote.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[44,98],[12,98]],"outbound":[]},{"name":"sepBy","effect":"( Fl Df -- Q ):","markdown":"stitches enquoted forms from Form list and leaves the resulting Quote. Enquotes and inserts Delimiter form between the pairs.\n\n```\n[ 'a' 'b' '=' 1 ] ' ' sepBy leaves: 'a b = 1'\n```\n","primer":"stitches enquoted forms from Form list and leaves the resulting Quote.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[44,99],[12,99],[45,99]],"outbound":[]},{"name":"sepBy:","effect":"( Fl sepBy:/join: D -- Q ):","markdown":"infix version of `sepBy`.\n","primer":"infix version of `sepBy`.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[44,99],[12,99]],"outbound":[99]},{"name":"join:","effect":"( Fl sepBy:/join: D -- Q ):","markdown":"infix version of `sepBy`.\n","primer":"infix version of `sepBy`.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[44,99],[12,99]],"outbound":[99]},{"name":"concat!","effect":"( B1 B2 -- B1 ):","markdown":"adds elements before cursor in B2 after cursor in B1. Advances the cursor in B1 by the number of added elements.\n\n```\n[ 1 2 3 ] [ 4 5 6 ] concat!\n  leaves: [ [ 1 2 3 4 5 6 ] ]\n```\n","primer":"adds elements before cursor in B2 after cursor in B1.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"concat","effect":"( B1 B2 -- Br ):","markdown":"concatenates two Blocks.\n\n```\n[ 1 2 3 ] [ 4 5 6 ] concat\n  leaves: [ [ 1 2 3 4 5 6 ] \"(a new block!)\" ]\n```\n","primer":"concatenates two Blocks.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"hasDesc?","effect":"( B -- true/false ):","markdown":"leaves whether Block has a description.\n","primer":"leaves whether Block has a description.","takes":[[0,0]],"leaves":[],"erefs":[[5,104]],"outbound":[]},{"name":"|afterOrToEnd?","effect":"( Lb C -- Sfb true/false ):","markdown":"slides right (see `|slideRight`) through List block, executes Condition block for each form under the cursor. Stops *after* form if Condition block left true for it. Leaves Skipped forms block. Leaves true when Condition matched, false when reached the end of List block without a match.\n\nNote: if Condition is not a block, it is wrapped like so: `[ C = ]`.\n\nUseful for writing parsers for Novika DSLs.\n\n```\n[ 1 | 2 3 4 5 6 ] $: a\na [ 4 = ] |afterOrToEnd? leaves: [ [ 2 3 ] true ]\na leaves: [ [ 1 2 3 4 | 5 6 ] ]\n```\n","primer":"slides right (see `|slideRight`) through List block, executes Condition block for each form under the cursor.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,105],[47,105]],"outbound":[40]},{"name":"|afterOrToEnd?:","effect":"( Lb |afterOrToEnd?: C -- Sfb ):","markdown":"infix version of `|afterOrToEnd?`.\n","primer":"infix version of `|afterOrToEnd?`.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,105],[47,105]],"outbound":[105]},{"name":"|afterOrToEnd","effect":"( Lb C -- Sfb ):","markdown":"same as `|afterOrToEnd?`, but disregards whether the end was reached instead of Condition matching.\n","primer":"same as `|afterOrToEnd?`, but disregards whether the end was reached instead of Condition matching.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[46,105],[47,107],[8,105]],"outbound":[105]},{"name":"|afterOrToEnd:","effect":"( Lb |afterOrToEnd: C -- Sfb ):","markdown":"infix version of `|afterOrToEnd`.\n","primer":"infix version of `|afterOrToEnd`.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[46,105],[47,107],[8,105]],"outbound":[107]},{"name":"|afterOrDie","effect":"( Lb C -- Sfb ):","markdown":"same as `|afterOrToEnd?`, but dies when reached end of List block without matching.\n\nWhen Condition is a block, its desc, if available, is displayed as the thing that was expected. Otherwise, Condition itself is displayed.\n\n```\n[ 1 | 2 3 4 5 6 ] $: a\na 4 |afterOrDie leaves: [ [ 2 3 ] ]\na leaves: [ [ 1 2 3 4 | 5 6 ] ]\n```\n","primer":"same as `|afterOrToEnd?`, but dies when reached end of List block without matching.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,109],[47,109]],"outbound":[105]},{"name":"|afterOrDie:","effect":"( Lb |afterOrDie: C -- Sfb ):","markdown":"infix version of `|afterOrDie`.\n","primer":"infix version of `|afterOrDie`.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,109],[47,109]],"outbound":[109]},{"name":"|beforeOrToEnd?","effect":"( Lb C -- Sfb true/false ):","markdown":"similar to `|afterOrToEnd?`, but leaves the cursor in List block *before* the matching item.\n\n```\n[ 1 | 2 3 4 5 6 ] $: a\na 4 |beforeOrToEnd leaves: [ [ 2 3 ] ]\na leaves: [ [ 1 2 3 | 4 5 6 ] ]\n```\n","primer":"similar to `|afterOrToEnd?`, but leaves the cursor in List block *before* the matching item.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,111],[47,105]],"outbound":[105]},{"name":"|beforeOrToEnd?:","effect":"( Lb |beforeOrToEnd?: C -- Sfb true/false ):","markdown":"infix version of `|beforeOrToEnd?`.\n","primer":"infix version of `|beforeOrToEnd?`.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,111],[47,105]],"outbound":[111]},{"name":"|beforeOrToEnd","effect":"( Lb C -- Sfb ):","markdown":"same as `|beforeOrToEnd?`, but disregards whether the end was reached instead of Condition matching.\n","primer":"same as `|beforeOrToEnd?`, but disregards whether the end was reached instead of Condition matching.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,111],[47,113]],"outbound":[111]},{"name":"|beforeOrToEnd:","effect":"( Lb |beforeOrToEnd: C -- Sfb ):","markdown":"infix version of `|beforeOrToEnd`.\n","primer":"infix version of `|beforeOrToEnd`.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,111],[47,113]],"outbound":[113]},{"name":"|beforeOrDie","effect":"( Lb C -- Sfb ):","markdown":"similar to `|afterOrDie`, but leaves the cursor in List block *before* the matching item.\n\n```\n[ 1 | 2 3 4 5 6 ] $: a\na 4 |beforeOrDie leaves: [ [ 2 3 ] ]\na leaves: [ [ 1 2 3 | 4 5 6 ] ]\n```\n","primer":"similar to `|afterOrDie`, but leaves the cursor in List block *before* the matching item.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,115],[47,109]],"outbound":[109]},{"name":"|beforeOrDie:","effect":"( Lb |beforeOrDie: C -- Sfb ):","markdown":"infix version of `|beforeOrDie`.\n","primer":"infix version of `|beforeOrDie`.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[46,105],[8,115],[47,109]],"outbound":[115]},{"name":"tally","effect":"( L B -- S ):","markdown":"opens Block with each `form count` pair, preceded by previous results of Block (if any), as the active Stack. Forms are taken from List block. Resulting Stack is left.\n\n```\n[ 1 2 2 3 3 2 1 ] [ swap 2echo ] tally\n\"STDOUT: 2\u23ce 1\u23ce (two ones)\"\n\"STDOUT: 3\u23ce 2\u23ce (three twos\"\n\"STDOUT: 2\u23ce 3\u23ce (two threes)\"\n\nleaves: [ ] \"all were consumed by 2echo\"\n```\n","primer":"opens Block with each `form count` pair, preceded by previous results of Block (if any), as the active Stack.","takes":[[0,0],[1,0]],"leaves":[[2,0]],"erefs":[[48,117],[5,117],[7,117]],"outbound":[]},{"name":"tally:","effect":"( L tally: B -- ):","markdown":"infix version of `tally`.\n","primer":"infix version of `tally`.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[48,117],[5,117]],"outbound":[117]},{"name":"sortUsing!:","effect":"( B sortUsing!: Cb -- B ):","markdown":"infix version of `sortUsing!`.\n\n```\n[ 3 1 2 4 0 -3 ] sortUsing!: - leaves: [ [ -3 0 1 2 3 4 ] ]\n```\n","primer":"infix version of `sortUsing!`.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[5,470],[49,470]],"outbound":[470]},{"name":"sort!","effect":"( Dlb -- Dlb ):","markdown":"inplace sort of Decimal list block. Chokes on non-decimal forms.\n\n```\n[ 3 1 2 4 0 -3 ] sort! leaves: [ [ -3 0 1 2 3 4 ] ]\n```\n","primer":"inplace sort of Decimal list block.","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[50,120]],"outbound":[]},{"name":"sortBy!","effect":"( B Mb -- B ):","markdown":"inplace sort for Block using the Mapper block, which must be able to map *all* forms in Block to a decimal.\n\n```\n[ 'hi' 'worldish' 'hi' 'foobar' ] [ count ] sortBy! leaves: [ [ 'hi' 'hi' 'foobar' 'worldish' ] ]\n```\n","primer":"inplace sort for Block using the Mapper block, which must be able to map *all* forms in Block to a decimal.","takes":[[1,0],[0,0]],"leaves":[[1,0]],"erefs":[[51,121],[5,121]],"outbound":[]},{"name":"sortBy!:","effect":"( B sortBy!: Mb -- B ):","markdown":"infix version of `sortBy!`.\n\n```\n[ 'hi' 'worldish' 'hi' 'foobar' ] sortBy!: count leaves: [ [ 'hi' 'hi' 'foobar' 'worldish' ] ]\n```\n","primer":"infix version of `sortBy!`.","takes":[[1,0],[0,0]],"leaves":[[1,0]],"erefs":[[51,121],[5,121]],"outbound":[121]},{"name":"|around","effect":"( L N -- Fab ):","markdown":"leaves a Forms around block with N/2 forms before the cursor, and N/2 forms after the cursor in List.\n\nForms around block may consist of less than N forms, but only when there are less than N forms in List (in this case, Forms around block is essentially a shallow copy of List).\n\nForms around block is an orphan with two dictionary entries: `start`, which stores the index of the first item in List, and `end`, which stores the index of the last item in List.\n\nDies when N is zero or when List is empty, because in these cases it is impossible to find the pivot form.\n\n```\n[ 1 2 3 4 ] $: block\nblock 2 |to\nblock echo \"STDOUT: [ 1 2 | 3 4 ]\u23ce \"\nblock 2 |around echo \"STDOUT: [ 2 3 \u00b7 ${start :: 1} ${end :: 3} ]\u23ce \"\n```\n","primer":"leaves a Forms around block with N/2 forms before the cursor, and N/2 forms after the cursor in List.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[52,123],[6,123],[48,123]],"outbound":[]},{"name":"|ring","effect":"( B N -- Rb ):","markdown":"leaves a Ring block of N (if possible) forms left and right of the cursor in Block. If either side contains less forms than N, leaves all forms found in it. Puts cursor in Ring block after last form in the left-hand side of the ring.\n\nDies if N <= 0 (there are only >zero rings). Dies if Block is empty (because it cannot contain >zero rings).\n\nRing block also holds Block index of where the first form of the ring is (entry `firstAt`), and where the last form of the ring is (entry `lastAt`).\n\nHere is a diagram which may help you understand what a ring is:\n\n```text\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 3 |ring               \u2502\n\u2502                       \u2502\n\u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502   \u2502 2 |ring       \u2502   \u2502\n\u2502   \u2502               \u2502   \u2502\n\u2502   \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502   \u2502\n\u2502   \u2502   \u25021 |ring\u2502   \u2502   \u2502\n\u2502   \u2502   \u2502       \u2502   \u2502   \u2502\n\u2502 1 \u2502 2 \u2502 3 | 4 \u2502 5 \u2502 6 \u2502\n\u2502   \u2502   \u2502       \u2502   \u2502   \u2502\n\u2502   \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502   \u2502\n\u2502   \u2502               \u2502   \u2502\n\u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n```\n\nAnd in code:\n\n```\n[ 1 2 3 | 4 5 6 ] $: block\n\nblock 1 |ring toQuote leaves: '[ 3 | 4 \u00b7 ${firstAt :: 2} ${lastAt :: 3} ]'\nblock 2 |ring toQuote leaves: '[ 2 3 | 4 5 \u00b7 ${firstAt :: 1} ${lastAt :: 4} ]'\nblock 3 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 \u00b7 ${firstAt :: 0} ${lastAt :: 5} ]'\nblock 4 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 \u00b7 ${firstAt :: 0} ${lastAt :: 5} ]'\nblock 100 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 \u00b7 ${firstAt :: 0} ${lastAt :: 5} ]'\n```\n","primer":"leaves a Ring block of N (if possible) forms left and right of the cursor in Block.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[53,124],[6,124],[5,124]],"outbound":[]},{"name":"sample","effect":"( B -- Rf ):","markdown":"leaves a Random form from the given Block.\n\n```\n[ 1 2 3 4 ] sample leaves: \"... a random form from the block, let's say 2\"\n```\n","primer":"leaves a Random form from the given Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[54,125],[5,125]],"outbound":[]},{"name":"samples","effect":"( B C samples -- S ):","markdown":"samples the given Block Count times, and leaves the resulting block of Samples.\n\n```\n[ 1 2 3 4 ] 2 samples leaves: \"... [ (a random form) (a random form) ]\"\n'hello world' 2 samples leaves: \"... [ (a random quote) (a random quote) ]\"\n```\n","primer":"samples the given Block Count times, and leaves the resulting block of Samples.","takes":[[0,0],[1,0]],"leaves":[[2,0]],"erefs":[[5,126],[55,126],[56,126]],"outbound":[]},{"name":"sample:","effect":"( B sample: C -- S ):","markdown":"infix version of `samples`.\n\n```\n[ 1 2 3 4 ] sample: 2 leaves: \"... [ (a random form) (a random form) ]\"\n```\n","primer":"infix version of `samples`.","takes":[[0,0],[1,0]],"leaves":[[2,0]],"erefs":[[5,126],[55,126],[56,126]],"outbound":[126]},{"name":"flat:deep","effect":"( B -- Dfb ):","markdown":"leaves Deeply flattened block for the given Block.\n\nSelf-references are ignored. **Most importantly**, deeply flattened block is a child of Block.\n\n```\n[ ] flat leaves: [ [ ] ]\n[ 1 2 3 ] flat leaves: [ [ 1 2 3 ] ]\n[ [ 1 ] [ 2 ] [ 3 ] ] flat leaves: [ [ 1 2 3 ] ]\n\"... etc.\"\n\n[ [ 100 ] $: x ] obj $: foo\n\nfoo flat $: flattened\nflattened leaves: [ [ 100 $: x ] ]\nflattened.x leaves: 100\n\"... etc.\"\n\n[ ] $: bar\nbar bar shove\nbar flat leaves: [ [ ] ]\n```\n","primer":"leaves Deeply flattened block for the given Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[57,128],[5,128]],"outbound":[]},{"name":"flat","effect":"( B -- Dfb ):","markdown":"leaves Deeply flattened block for the given Block.\n\nSelf-references are ignored. **Most importantly**, deeply flattened block is a child of Block.\n\n```\n[ ] flat leaves: [ [ ] ]\n[ 1 2 3 ] flat leaves: [ [ 1 2 3 ] ]\n[ [ 1 ] [ 2 ] [ 3 ] ] flat leaves: [ [ 1 2 3 ] ]\n\"... etc.\"\n\n[ [ 100 ] $: x ] obj $: foo\n\nfoo flat $: flattened\nflattened leaves: [ [ 100 $: x ] ]\nflattened.x leaves: 100\n\"... etc.\"\n\n[ ] $: bar\nbar bar shove\nbar flat leaves: [ [ ] ]\n```\n","primer":"leaves Deeply flattened block for the given Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[57,129],[5,129]],"outbound":[]},{"name":"gsub","effect":"( B P R -- ):","markdown":"global (of all occurences), deep (nesting doesn't matter) substitution of Pattern with Replacement in Block.\n\nSome important points:\n\n* Self-references are skipped.\n\n* This word goes through the whole block, no matter where the cursor was beforehand, sliding the latter *back to front* (from the end to the beginning), and afterwards restoring its position to that before substitution (taking growth or shrinkage due to substitution into account).\n\n* If Pattern is a block, it is opened with Block as the stack and cursor just after the form-to-check. This word then expects Pattern to leave a truthy/falsey value *for whether the visited form should be replaced* with Replacement.\n\n* The stack effect for Pattern, in case it is a block, must be the following: `( ... F -- ... F true/false )`, where F is the form to check. Otherwise, *stable behavior is yours to ensure*!\n\n* If Pattern is not a block, the following template block is used instead: `[ dup Pattern = ]`.\n\n* Replacement, when this word decides it's time to use it, is opened with Block as the stack and cursor as if it was after the form- to-replace, *but without the latter on the stack*. Insertion is expected. Therefore, the stack effect of Replacement is recommended to be `( -- ... )` where `...` stands for one or more forms. Anything is possible, though, even cursor movement. But in this case remember that *stable behavior is yours to ensure*.\n\n```\n[ `a `b + ] $: temp\n\ntemp #`a 100 gsub\ntemp #`b 200 gsub\ntemp leaves: [ [ 100 200 + ] ]\ntemp open leaves: 300\n```\n","primer":"global (of all occurences), deep (nesting doesn't matter) substitution of Pattern with Replacement in Block.","takes":[[0,0],[2,0],[1,0]],"leaves":[],"erefs":[[5,130],[58,130],[59,130]],"outbound":[]},{"name":"gsub:","effect":"( B P gsub: R -- ):","markdown":"infix version of `gsub`.\n\n```\n[ 100 `cmd\n  200 `cmd ] $: block\n\nblock #`cmd gsub: #echo\nblock leaves: [ [ 100 echo 200 echo ] ]\nblock open \"STDOUT: 100\u23ce200\u23ce\"\n```\n","primer":"infix version of `gsub`.","takes":[[0,0],[2,0],[1,0]],"leaves":[],"erefs":[[5,130],[58,130],[59,130]],"outbound":[130]},{"name":"gsubOn:","effect":"( B R gsubOn: P -- ):","markdown":"another infix version of `gsub`.\n\n```\n[ 100 `cmdA\n  200 `cmdB ] $: block\n\nblock [ 2 * #echo ] gsubOn: #`cmdA\nblock [ 4 * #echo ] gsubOn: #`cmdB\n\nblock leaves: [ [ 200 echo 800 echo ] ]\nblock open \"STDOUT: 200\u23ce800\u23ce\"\n```\n","primer":"another infix version of `gsub`.","takes":[[0,0],[1,0],[2,0]],"leaves":[],"erefs":[[5,130],[58,130],[59,130]],"outbound":[130]},{"name":"console:width","effect":"( -- Cw ):","markdown":"leaves Console width (in columns).\n","primer":"leaves Console width (in columns).","takes":[],"leaves":[[0,0]],"erefs":[[60,133]],"outbound":[]},{"name":"console:height","effect":"( -- Ch ):","markdown":"leaves Console height (in rows).\n","primer":"leaves Console height (in rows).","takes":[],"leaves":[[0,0]],"erefs":[[61,134]],"outbound":[]},{"name":"easeInSine","effect":"( X -- Xe ):","markdown":"eases X using easeInSine function.\n","primer":"eases X using easeInSine function.","takes":[[0,0]],"leaves":[],"erefs":[[9,135]],"outbound":[]},{"name":"easeOutSine","effect":"( X -- Xe ):","markdown":"eases X using easeOutSine function.\n","primer":"eases X using easeOutSine function.","takes":[[0,0]],"leaves":[],"erefs":[[9,136]],"outbound":[]},{"name":"easeInOutSine","effect":"( X -- Xe ):","markdown":"eases X using easeInOutSine function.\n","primer":"eases X using easeInOutSine function.","takes":[[0,0]],"leaves":[],"erefs":[[9,137]],"outbound":[]},{"name":"easeInCubic","effect":"( X -- Xe ):","markdown":"eases X using easeInCubic function.\n","primer":"eases X using easeInCubic function.","takes":[[0,0]],"leaves":[],"erefs":[[9,138]],"outbound":[]},{"name":"easeOutCubic","effect":"( X -- Xe ):","markdown":"eases X using easeOutCubic function.\n","primer":"eases X using easeOutCubic function.","takes":[[0,0]],"leaves":[],"erefs":[[9,139]],"outbound":[]},{"name":"easeInOutCubic","effect":"( X -- Xe ):","markdown":"eases X using easeInOutCubic function.\n","primer":"eases X using easeInOutCubic function.","takes":[[0,0]],"leaves":[],"erefs":[[9,140]],"outbound":[]},{"name":"easeInQuint","effect":"( X -- Xe ):","markdown":"eases X using easeInQuint function.\n","primer":"eases X using easeInQuint function.","takes":[[0,0]],"leaves":[],"erefs":[[9,141]],"outbound":[]},{"name":"easeOutQuint","effect":"( X -- Xe ):","markdown":"eases X using easeOutQuint function.\n","primer":"eases X using easeOutQuint function.","takes":[[0,0]],"leaves":[],"erefs":[[9,142]],"outbound":[]},{"name":"easeInOutQuint","effect":"( X -- Xe ):","markdown":"eases X using easeInOutQuint function.\n","primer":"eases X using easeInOutQuint function.","takes":[[0,0]],"leaves":[],"erefs":[[9,143]],"outbound":[]},{"name":"easeInCirc","effect":"( X -- Xe ):","markdown":"eases X using easeInCirc function.\n","primer":"eases X using easeInCirc function.","takes":[[0,0]],"leaves":[],"erefs":[[9,144]],"outbound":[]},{"name":"easeOutCirc","effect":"( X -- Xe ):","markdown":"eases X using easeOutCirc function.\n","primer":"eases X using easeOutCirc function.","takes":[[0,0]],"leaves":[],"erefs":[[9,145]],"outbound":[]},{"name":"easeInOutCirc","effect":"( X -- Xe ):","markdown":"eases X using easeInOutCirc function.\n","primer":"eases X using easeInOutCirc function.","takes":[[0,0]],"leaves":[],"erefs":[[9,146]],"outbound":[]},{"name":"easeInElastic","effect":"( X -- Xe ):","markdown":"eases X using easeInElastic function.\n","primer":"eases X using easeInElastic function.","takes":[[0,0]],"leaves":[],"erefs":[[9,147]],"outbound":[]},{"name":"easeOutElastic","effect":"( X -- Xe ):","markdown":"eases X using easeOutElastic function.\n","primer":"eases X using easeOutElastic function.","takes":[[0,0]],"leaves":[],"erefs":[[9,148]],"outbound":[]},{"name":"easeInOutElastic","effect":"( X -- Xe ):","markdown":"eases X using easeInOutElastic function.\n","primer":"eases X using easeInOutElastic function.","takes":[[0,0]],"leaves":[],"erefs":[[9,149]],"outbound":[]},{"name":"easeInQuad","effect":"( X -- Xe ):","markdown":"eases X using easeInQuad function.\n","primer":"eases X using easeInQuad function.","takes":[[0,0]],"leaves":[],"erefs":[[9,150]],"outbound":[]},{"name":"easeOutQuad","effect":"( X -- Xe ):","markdown":"eases X using easeOutQuad function.\n","primer":"eases X using easeOutQuad function.","takes":[[0,0]],"leaves":[],"erefs":[[9,151]],"outbound":[]},{"name":"easeInOutQuad","effect":"( X -- Xe ):","markdown":"eases X using easeInOutQuad function.\n","primer":"eases X using easeInOutQuad function.","takes":[[0,0]],"leaves":[],"erefs":[[9,152]],"outbound":[]},{"name":"easeInQuart","effect":"( X -- Xe ):","markdown":"eases X using easeInQuart function.\n","primer":"eases X using easeInQuart function.","takes":[[0,0]],"leaves":[],"erefs":[[9,153]],"outbound":[]},{"name":"easeOutQuart","effect":"( X -- Xe ):","markdown":"eases X using easeOutQuart function.\n","primer":"eases X using easeOutQuart function.","takes":[[0,0]],"leaves":[],"erefs":[[9,154]],"outbound":[]},{"name":"easeInOutQuart","effect":"( X -- Xe ):","markdown":"eases X using easeInOutQuart function.\n","primer":"eases X using easeInOutQuart function.","takes":[[0,0]],"leaves":[],"erefs":[[9,155]],"outbound":[]},{"name":"easeInExpo","effect":"( X -- Xe ):","markdown":"eases X using easeInExpo function.\n","primer":"eases X using easeInExpo function.","takes":[[0,0]],"leaves":[],"erefs":[[9,156]],"outbound":[]},{"name":"easeOutExpo","effect":"( X -- Xe ):","markdown":"eases X using easeOutExpo function.\n","primer":"eases X using easeOutExpo function.","takes":[[0,0]],"leaves":[],"erefs":[[9,157]],"outbound":[]},{"name":"easeInOutExpo","effect":"( X -- Xe ):","markdown":"eases X using easeInOutExpo function.\n","primer":"eases X using easeInOutExpo function.","takes":[[0,0]],"leaves":[],"erefs":[[9,158]],"outbound":[]},{"name":"easeInBack","effect":"( X -- Xe ):","markdown":"eases X using easeInBack function.\n","primer":"eases X using easeInBack function.","takes":[[0,0]],"leaves":[],"erefs":[[9,159]],"outbound":[]},{"name":"easeOutBack","effect":"( X -- Xe ):","markdown":"eases X using easeOutBack function.\n","primer":"eases X using easeOutBack function.","takes":[[0,0]],"leaves":[],"erefs":[[9,160]],"outbound":[]},{"name":"easeInOutBack","effect":"( X -- Xe ):","markdown":"eases X using easeInOutBack function.\n","primer":"eases X using easeInOutBack function.","takes":[[0,0]],"leaves":[],"erefs":[[9,161]],"outbound":[]},{"name":"easeInBounce","effect":"( X -- Xe ):","markdown":"eases X using easeInBounce function.\n","primer":"eases X using easeInBounce function.","takes":[[0,0]],"leaves":[],"erefs":[[9,162]],"outbound":[]},{"name":"easeOutBounce","effect":"( X -- Xe ):","markdown":"eases X using easeOutBounce function.\n","primer":"eases X using easeOutBounce function.","takes":[[0,0]],"leaves":[],"erefs":[[9,163]],"outbound":[]},{"name":"easeInOutBounce","effect":"( X -- Xe ):","markdown":"eases X using easeInOutBounce function.\n","primer":"eases X using easeInOutBounce function.","takes":[[0,0]],"leaves":[],"erefs":[[9,164]],"outbound":[]},{"name":"vals","effect":"( B -- S ):","markdown":"activates an empty Stack for the duration of Block.\n\n```\n[ 1 2 3 ] vals leaves: [ 1 2 3 ]\n[ (1 2 + 2 *) 'hello' ] vals leaves: [ 6 'hello' ]\n```\n","primer":"activates an empty Stack for the duration of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[7,165],[5,165]],"outbound":[]},{"name":"val","effect":"( B -- T ):","markdown":"activates an empty stack for the duration of Block, and leaves Top form in the stack. Dies if none.\n\n```\n[ 1 2 3 ] val leaves: 3\n[ 'foo' 'bar' ~ ] val leaves: 'foobar'\n```\n","primer":"activates an empty stack for the duration of Block, and leaves Top form in the stack.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[62,166],[5,166]],"outbound":[]},{"name":"2val","effect":"( B1 B2 -- T1 T2 ):","markdown":"activates individual empty stacks for each of the two Blocks, and leaves their corresponding Top forms.\n\n```\n[ 1 2 + ] [ 3 4 + ] 2val leaves: [ 3 7 ]\n```\n","primer":"activates individual empty stacks for each of the two Blocks, and leaves their corresponding Top forms.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"thruLitBlock","effect":"( B -- Lb ):","markdown":"leaves Literal block after cursor in Block. If form after cursor isn't a block, encloses it and opens it with an empty stack, Block being the enclosing block's parent, and finally asserts the resulting form is a block.\n\n```\n[ 'Hello World' ] $: x\n[ | x [ 4 ] ] $: foo\n\nfoo thruLitBlock leaves: [[ 'Hello World' ]]\nfoo toQuote leaves: '[ x | [ 4 ] ]'\n\nfoo thruLitBlock leaves: [[ 4 ]]\nfoo toQuote leaves: '[ x [ 4 ] ]'\n```\n","primer":"leaves Literal block after cursor in Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[63,168],[5,168]],"outbound":[]},{"name":"thruWord","effect":"( B -- W/dies ):","markdown":"same as `thru asWord`.\n","primer":"same as `thru asWord`.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"thruWord:","effect":"( B W -- /dies ):","markdown":"same as `thruWord`, but also checks if the `thru`-ed word is the same as Word.\n\n```\n[ ahead thruVal $: begin\n  ahead thruWord: to:\n  ahead thruVal $: end\n\n  begin to: end\n] @: from:\n\nfrom: 1 to: 100 leaves: [ 1 2 3 \"\u2026\" 98 99 100 ]\n```\n","primer":"same as `thruWord`, but also checks if the `thru`-ed word is the same as Word.","takes":[[0,0]],"leaves":[],"erefs":[[64,170]],"outbound":[169,466]},{"name":"thruVal","effect":"( B -- F' ):","markdown":"same as `thruBlock val`.\n","primer":"same as `thruBlock val`.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"thruVals","effect":"( B -- [ ... F' ... ] ):","markdown":"same as `thruBlock vals`.\n","primer":"same as `thruBlock vals`.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"obj","effect":"( B -- I ):","markdown":"like `do`, but leaves the resulting Instance of Block. Equivalent to `[ &lt;Block&gt; this ] do`.\n\n```\n[ 100 $: x 200 $: y ] obj \"[ 100 $: x 200 $: y \u00b7 ${x :: 100} {y :: 200} ]\"\n\nbi: [ .x ] [ .y ] leaves: [ 100 200 ]\n```\n","primer":"like `do`, but leaves the resulting Instance of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[33,173],[5,173]],"outbound":[379]},{"name":"sel:","effect":"( ... D sel: T F -- ... T' / ... F' ):","markdown":"infix version of `sel`.\n\n```\n(0 randTo: 100) odd? sel: 'Yay!' 'Nay!' echo\n```\n","primer":"infix version of `sel`.","takes":[[0,0]],"leaves":[],"erefs":[[65,382]],"outbound":[382]},{"name":"br:","effect":"( ... D br: T F -- ... T' / ... F' ):","markdown":"infix version of `br`.\n\n```\n(0 randTo: 100) odd? br:\n  [ 'Yay!' echo ]\n  [ 'Nay!' echo ]\n\n\"Say no to repetition!\"\n(0 randTo: 100) odd? (br: 'Yay!' 'Nay!') echo\n```\n","primer":"infix version of `br`.","takes":[[2,0],[0,0],[1,0]],"leaves":[[0,0],[1,0]],"erefs":[[66,383],[67,383],[65,383]],"outbound":[383]},{"name":"=>","effect":"( D => Tb -- ? ):","markdown":"opens True branch form if Determiner is truthy.\n\n```\n(0 randTo: 100) even? => [ 'Yay!' echo ]\n```\n","primer":"opens True branch form if Determiner is truthy.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[68,176],[65,176]],"outbound":[]},{"name":"~>","effect":"( D ~> Tb -- ? ):","markdown":"opens True branch form if Determiner is truthy.\n\nIf Determiner is a block, creates a copy of the stack and opens Determiner with that stack. If Determiner leaves a truthy form, opens True branch form with the old stack. Otherwise, does nothing.\n\n```\n100 even? ~> 1 leaves: [ 1 ]\n101 even? ~> 1 leaves: [ ]\n\n100 ([ even? ] ~> [ 2 * ]) leaves: [ 200 ]\n101 ([ even? ] ~> [ 2 * ]) leaves: [ 101 ]\n\n2 4 ([ * even? ] ~> +) leaves: 6\n5 5 ([ * even? ] ~> +) leaves: [ 5 5 ]\n```\n","primer":"opens True branch form if Determiner is truthy.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[68,177],[65,177]],"outbound":[]},{"name":"and","effect":"( A B -- A/false ):","markdown":"leaves whether both A and B are truthy.\n\nSupports short-circuiting. Remember that in Novika, only `false` itself is falsey. Everything else is truthy.\n\n```\n(false false and) leaves: false\n(true false and) leaves: false\n(false true and) leaves: false\n(true true and) leaves: true\n\n(100 200 and) leaves: true\n(100 false and) leaves: false\n\n[ 100 even? ] [ 200 odd? ] and leaves: false\n```\n","primer":"leaves whether both A and B are truthy.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[30,178],[31,178]],"outbound":[]},{"name":"or","effect":"( A B -- true/A ):","markdown":"leaves whether A or B or both are truthy.\n\nSupports short-circuiting. Remember that in Novika, only `false` itself is falsey. Everything else is truthy.\n\n```\n(false false or) leaves: false\n(true false or) leaves: true\n(false true or) leaves: true\n(true true or) leaves: true\n\n(100 200 or) leaves: true\n(100 false or) leaves: true\n\n[ 100 even? ] [ 200 odd? ] or leaves: false\n```\n","primer":"leaves whether A or B or both are truthy.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[30,179],[31,179]],"outbound":[]},{"name":"neither?","effect":"( A B -- true/A ):","markdown":"same as `or not`, leaves whether neither A nor B is truthy.\n\nSupports short-circuiting. Remember that in Novika, only `false` itself is falsey. Everything else is truthy.\n\n```\n[ 100 odd? ] [ 201 even? ] neither? leaves: true\n```\n","primer":"same as `or not`, leaves whether neither A nor B is truthy.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[30,180],[31,180]],"outbound":[]},{"name":"continues","effect":"( B -- ):","markdown":"makes shallow copy of continuations stack the stack for the duration of Block. Replaces substrate of the continuation stack with the modified shallow copy after Block is opened.\n","primer":"makes shallow copy of continuations stack the stack for the duration of Block.","takes":[[0,0]],"leaves":[],"erefs":[[5,181]],"outbound":[]},{"name":"repeat","effect":"( -- ):","markdown":"executes caller again. Looping primitive. Too low- level for users, prefer not to use (use `loop` instead). Beware that it does not re-instantiate the block.\n\n```\n[\n  'Looping indefinitely, yay!' echo\n\n  repeat\n] do\n```\n","primer":"executes caller again.","takes":[],"leaves":[],"erefs":[],"outbound":[187]},{"name":"dropContinuationsUntil","effect":"( B -- ):","markdown":"drops all continuations before (and including) those for which Block leaves truthy value when opened with the continuation on top of an empty stack, coming from the right-hand side.\n","primer":"drops all continuations before (and including) those for which Block leaves truthy value when opened with the continuation on top of an empty stack, coming from the right-hand side.","takes":[[0,0]],"leaves":[],"erefs":[[5,183]],"outbound":[]},{"name":"^","effect":"( -- ):","markdown":"closes blocks all the way up to, and including, its *opener's parent*.\n","primer":"closes blocks all the way up to, and including, its *opener's parent*.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"createLoop","effect":"( Ib -- Sh Bh Nh ):","markdown":"takes an Iteration body block and leaves three handles: Start handle to start the loop, Next handle to continue the loop, and Break handle to break the loop.\n\n```\n[ '> ' readLine not => nextCycle\n  [ 'quit' quitLoop\n    'next' nextCycle\n  ] choose\n  'You have entered: ' swap ~ echo\n] createLoop\n  @: nextCycle\n  @: quitLoop\n  @: startLoop\n\n'Hello! Type `quit` to quit!' echo\n  startLoop\n'Bye!' echo\n```\n","primer":"takes an Iteration body block and leaves three handles: Start handle to start the loop, Next handle to continue the loop, and Break handle to break the loop.","takes":[[0,0]],"leaves":[[1,0],[3,0],[2,0]],"erefs":[[69,185],[70,185],[71,185],[72,185]],"outbound":[]},{"name":"createDetachedLoop","effect":"( Bb C Cb -- Sh ):","markdown":"defines `break` and `next` for a Body block that is being evaluated indirectly by a Control block, and only if Condition leaves a truthy value on top of the stack it hydrated. `next` resumes the Control block. Leaves Start handle to start the loop.\n\n```\n\"Body block is the 'client' block of sorts:\"\n[ dup even? (br: ' is even!' ' is odd!') ~ echo\n] $: bodyBlock\n\n\n0 $: n\n\n\"Control block chooses whether, and how to run\nthe body block.\"\n[ n enclose bodyBlock hydrate\n  n 1 + =: n\n] $: controlBlock\n\n\"Condition block chooses whether to stop looping.\"\n[ n 5 <\n] $: conditionBlock\n\nbodyBlock conditionBlock controlBlock createDetachedLoop\n  @: startLoop\n\nstartLoop\n\n\"STDOUT: 0 is even!\u23ce\"\n\"STDOUT: 1 is odd!\u23ce\"\n\"STDOUT: 2 is even!\u23ce\"\n\"STDOUT: 3 is odd!\u23ce\"\n\"STDOUT: 4 is even!\u23ce\"\n\nn leaves: 5\n```\n","primer":"defines `break` and `next` for a Body block that is being evaluated indirectly by a Control block, and only if Condition leaves a truthy value on top of the stack it hydrated.","takes":[[0,0],[1,0],[3,0]],"leaves":[[2,0]],"erefs":[[73,186],[47,186],[70,186],[74,186]],"outbound":[]},{"name":"loop","effect":"( Ib -- ):","markdown":"basic infinite loop over an Iteration body block. `break` and `next` are available in the block. A new stack created for each iteration.\n\n```\n'Hello! Type `quit` to quit!' echo\n\n[ '> ' readLine not => next\n  [ 'quit' break\n    'next' next\n  ] choose\n  'You have entered: ' swap ~ echo\n] loop\n\n'Bye!' echo\n```\n","primer":"basic infinite loop over an Iteration body block.","takes":[[0,0]],"leaves":[],"erefs":[[69,187]],"outbound":[]},{"name":"loop:","effect":"( loop: Ib -- ):","markdown":"prefix version of `loop`.\n","primer":"prefix version of `loop`.","takes":[[0,0]],"leaves":[],"erefs":[[69,187]],"outbound":[187]},{"name":"while","effect":"( C B -- ):","markdown":"hydrates an empty stack with Condition; if ToS is truthy afterwards, Block is opened over an empty stack. Repeats until ToS is false. Similar to `loop`, words `break` and `next` are available in Block.\n\n```\n1 to: 10 sample: 10 p $: numbers\n\n0 $: index\n\nwhile: [ numbers index fromLeft even? ]\n[\n  index 1 + =: index\n  index (numbers count) = => [\n    'No odd numbers :(' echo\n    okbye\n  ]\n]\n\n'First odd number is: ' (numbers index fromLeft) ~ echo\n```\n","primer":"hydrates an empty stack with Condition; if ToS is truthy afterwards, Block is opened over an empty stack.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[47,189],[5,189]],"outbound":[187]},{"name":"while:","effect":"( while: C B -- ):","markdown":"prefix version of `while`.\n","primer":"prefix version of `while`.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[47,189],[5,189]],"outbound":[189]},{"name":"until","effect":"( C B -- ):","markdown":"inverse of `while` (opens Block while Condition is **false**), for more info see `while`.\n\n```\n1 to: 10 sample: 10 p $: numbers\n\n0 $: index\n\nuntil: [ numbers index fromLeft odd? ]\n[\n  index 1 + =: index\n  index (numbers count) = => [\n    'No odd numbers :(' echo\n    okbye\n  ]\n]\n\n'First odd number is: ' (numbers index fromLeft) ~ echo\n```\n","primer":"inverse of `while` (opens Block while Condition is **false**), for more info see `while`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,191],[47,191]],"outbound":[189]},{"name":"until:","effect":"( until: C B -- ):","markdown":"prefix version of `until`.\n","primer":"prefix version of `until`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,191],[47,191]],"outbound":[191]},{"name":"times","effect":"( C B -- ):","markdown":"opens Block Count times. For each iteration of Block, a new stack block is activated with current Count on top. `break` and `next` available.\n\n```\n16 times: [\n  even? ~> next\n  9 >= ~> break\n  echo\n]\n\n\"STDOUT: 1\u23ce\"\n\"STDOUT: 3\u23ce\"\n\"STDOUT: 5\u23ce\"\n\"STDOUT: 7\u23ce\"\n```\n","primer":"opens Block Count times.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,193],[55,193]],"outbound":[]},{"name":"times:","effect":"( C times: B -- ):","markdown":"infix version of `times`.\n","primer":"infix version of `times`.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,193],[55,193]],"outbound":[193]},{"name":"compiledTimes","effect":"( N B -- ):","markdown":"**unsafe** `times` alternative for when you *really* need to iterate a lot.\n\nThis word basically strips off all steps in the `createDetachedLoop` (aka structured control flow) abstraction ladder.\n\nInternally, it's a bit like your Block being followed by a GOTO back to the beginning, plus a counter *on the stack*.\n\nNote that the loop is *compiled* from a template when you use this word. **This means that opening this word multiple times in a row is inefficient**, as such compilation is expensive. However, if you need to *iterate* quickly, you can try using this word.\n\nThe stack your Block is given is *not* owned by you. You must not leave junk, and you must not drop the index. The effect of your block **must** be `( I -- I )`.\n\n`next` and `break` are **not** supported.\n\n```\n10_000 compiledTimes: [ $: index\n  index 2 * echo\n  index\n]\n```\n","primer":"**unsafe** `times` alternative for when you *really* need to iterate a lot.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[75,195],[5,195]],"outbound":[186,193]},{"name":"compiledTimes:","effect":"( N compiledTimes: B -- ):","markdown":"infix version of `compiledTimes`.\n\n```\n0 $: acc\n100_000 compiledTimes: [ \"( I -- I )\"\n  dup acc + =: acc\n]\nacc echo \"STDOUT: 5000050000\u23ce\"\n```\n","primer":"infix version of `compiledTimes`.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[75,195],[5,195]],"outbound":[195]},{"name":"withColorEcho","effect":"( F -- ):","markdown":"echoes Form like `withColorAppendEcho`, then echoes a newline character.\n\n```\n0 100 0 rgb withEchoFg\n100 0 0 rgb withEchoBg\n  'Hi!' withColorEcho\ndropEchoBg\n  'Bye!' withColorEcho\ndropEchoFg\n```\n","primer":"echoes Form like `withColorAppendEcho`, then echoes a newline character.","takes":[[0,0]],"leaves":[],"erefs":[[1,197]],"outbound":[341]},{"name":"withEmphasisEcho","effect":"( F -- ):","markdown":"echoes Form like `withEmphasisAppendEcho`, then echoes a newline character.\n","primer":"echoes Form like `withEmphasisAppendEcho`, then echoes a newline character.","takes":[[0,0]],"leaves":[],"erefs":[[1,198]],"outbound":[340]},{"name":"withReverseEcho","effect":"( F -- ):","markdown":"echoes Form like `withReverseAppendEcho`, then echoes a newline character.\n","primer":"echoes Form like `withReverseAppendEcho`, then echoes a newline character.","takes":[[0,0]],"leaves":[],"erefs":[[1,199]],"outbound":[339]},{"name":"2asc","effect":"( A B -- Min Max ):","markdown":"sorts two decimals, A and B, in ascending (min to max) order. In case A = B, order is unchanged.\n\n```\n1 2 2asc leaves: [ 1 2 ]\n2 1 2asc leaves: [ 1 2 ]\n```\n","primer":"sorts two decimals, A and B, in ascending (min to max) order.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[30,200],[31,200]],"outbound":[]},{"name":"2desc","effect":"( A B -- Max Min ):","markdown":"sorts two decimals, A and B, in descending (max to min) order. In case A = B, order is unchanged.\n\n```\n1 2 2desc leaves: [ 2 1 ]\n2 1 2desc leaves: [ 2 1 ]\n```\n","primer":"sorts two decimals, A and B, in descending (max to min) order.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[30,201],[31,201]],"outbound":[]},{"name":"2min","effect":"( A B -- M ):","markdown":"leaves Minimum of two decimals, A and B.\n\n```\n3 10 2min leaves: 3\n```\n","primer":"leaves Minimum of two decimals, A and B.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[76,202],[30,202],[31,202]],"outbound":[]},{"name":"2max","effect":"( A B -- M ):","markdown":"leaves Maximum of two decimals, A and B.\n\n```\n3 10 2max leaves: 10\n```\n","primer":"leaves Maximum of two decimals, A and B.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[77,203],[30,203],[31,203]],"outbound":[]},{"name":"randFromTo","effect":"( L H -- N ):","markdown":"generates random Number between Low and High, *including* both Low and High.\n","primer":"generates random Number between Low and High, *including* both Low and High.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[78,204],[79,204],[80,204]],"outbound":[]},{"name":"randTo:","effect":"( L randTo: H -- N ):","markdown":"infix version of `randFromTo`.\n","primer":"infix version of `randFromTo`.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[78,204],[79,204],[80,204]],"outbound":[204]},{"name":"clamp:","effect":"( N clamp: L H -- N/L/H ):","markdown":"clamps Number between Low and High: if Number is less than Low, leaves low; if Number is greater than High, leaves High.\n\n```\n1 clamp: 5 10 leaves: 5\n5 clamp: 5 10 leaves: 5\n7 clamp: 5 10 leaves: 7\n10 clamp: 5 10 leaves: 10\n100 clamp: 5 10 leaves: 10\n```\n","primer":"clamps Number between Low and High: if Number is less than Low, leaves low; if Number is greater than High, leaves High.","takes":[[1,0],[0,0],[2,0]],"leaves":[[1,0],[0,0],[2,0]],"erefs":[[79,206],[78,206],[80,206]],"outbound":[]},{"name":"flipSign","effect":"( N -- -N ):","markdown":"flips the sign of N.\n\n```\n-1 flipSign leaves: 1\n0 flipSign leaves: 0\n1 flipSign leaves: -1\n```\n","primer":"flips the sign of N. ``` -1 flipSign leaves: 1 0 flipSign leaves: 0 1 flipSign leaves: -1 ```","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[6,207]],"outbound":[]},{"name":"abs","effect":"( N -- Av ):","markdown":"leaves the Absolute value of N.\n\n```\n0 abs leaves: 0\n100 abs leaves: 100\n-100 abs leaves: 100\n```\n","primer":"leaves the Absolute value of N. ``` 0 abs leaves: 0 100 abs leaves: 100 -100 abs leaves: 100 ```","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[81,208],[6,208]],"outbound":[]},{"name":"%","effect":"( D -- R ):","markdown":"leaves Reciprocal of Decimal (`1/D`). Leaves 0 if Decimal is 0. Note: as in `12 % 12 *`, this may not always leave `1` because of math imprecisions.\n\n```\n0 % leaves: 0\n20 % leaves: 0.05\n100 % 100 * leaves: 1\n```\n","primer":"leaves Reciprocal of Decimal (`1/D`).","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[82,209],[83,209]],"outbound":[]},{"name":"rangesMap","effect":"( D R1b R1e R2b R2e -- D' ):","markdown":"leaves Decimal in range [R1b; R1e] mapped to the range [R2b; R2e].\n\nNote: Decimal is clamped into the range [R1b; R1e]. Note: implementation taken from https://www.arduino.cc/reference/en/language/functions/math/map/\n\n```\n100  0 100  1.5 255  rangesMap leaves: 255\n  0  0 100  1.5 255  rangesMap leaves: 1.5\n\n\"Reverse range:\"\n\n10  0 100  100 0  rangesMap leaves: 90\n```\n","primer":"leaves Decimal in range [R1b; R1e] mapped to the range [R2b; R2e].","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[83,210]],"outbound":[]},{"name":"mapFromRange:","effect":"( D mapFromRange: R1b R1e toRange: R2b R2e -- D' ):","markdown":"infix version of `rangesMap`.\n\n```\n100 mapFromRange: 0 100 toRange: 1.5 255 leaves: [ 255 ]\n  0 mapFromRange: 0 100 toRange: 1.5 255 leaves: [ 1.5 ]\n```\n","primer":"infix version of `rangesMap`.","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[83,210]],"outbound":[210]},{"name":"mapToRange","effect":"( P Rb Re -- D ):","markdown":"leaves Decimal in range [Range begin; Range end] corresponding to the given Percentage (in [0; 1]).\n\nSee `rangesMap` for more details.\n\n```\n\"...etc..\"\n-100  0 100  mapToRange leaves: 0\n   0  0 100  mapToRange leaves: 0\n 0.1  0 100  mapToRange leaves: 10\n   1  0 100  mapToRange leaves: 100\n   2  0 100  mapToRange leaves: 100\n\"...etc..\"\n```\n","primer":"leaves Decimal in range [Range begin; Range end] corresponding to the given Percentage (in [0; 1]).","takes":[[3,0],[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[83,212],[84,212],[85,212],[86,212]],"outbound":[210]},{"name":"mapToRange:","effect":"( P mapToRange: Rb Re -- D ):","markdown":"infix version of `mapToRange`.\n","primer":"infix version of `mapToRange`.","takes":[[3,0],[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[83,212],[84,212],[85,212],[86,212]],"outbound":[212]},{"name":"%of:","effect":"( Hp %of: Rb Re -- D ):","markdown":"leaves Decimal, which is Human percentage (0-100) mapped to [Range begin; Range end] range. Human percentage is clamped to 0-100.\n\n```\n\"What is 30% of John's salary, $10 000? \"\n(30 %of: 0 10_000) leaves: 3000\n(60 %of: 64 255) leaves: 178.6\n```\n","primer":"leaves Decimal, which is Human percentage (0-100) mapped to [Range begin; Range end] range.","takes":[[3,0],[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[83,214],[84,214],[85,214],[87,214]],"outbound":[]},{"name":"to%:","effect":"( D to%: Rb Re -- Hp ):","markdown":"leaves Human percentage for Decimal in the given range [Range begin; Range end]. Inverse of `%of:`.\n\n```\n(100 to%: 0 256) leaves: 39.0625\n\n\"You can verify the result like so:\"\n(39.0625 %of: 0 256) leaves: 100\n```\n","primer":"leaves Human percentage for Decimal in the given range [Range begin; Range end].","takes":[[1,0],[2,0],[3,0]],"leaves":[[0,0]],"erefs":[[87,215],[83,215],[84,215],[85,215]],"outbound":[214]},{"name":"deg->rad","effect":"( Aid -- Air ):","markdown":"leaves Angle in radians for the given Angle in degrees.\n","primer":"leaves Angle in radians for the given Angle in degrees.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[88,216],[89,216]],"outbound":[]},{"name":"rad->deg","effect":"( Air -- Aid ):","markdown":"leaves Angle in degrees for the given Angle in radians.\n","primer":"leaves Angle in degrees for the given Angle in radians.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[89,217],[88,217]],"outbound":[]},{"name":"approx=","effect":"( A B -- B ):","markdown":"leaves Boolean for whether A and B are approximately equal (their difference is less than or equal to `EPSILON`).\n","primer":"leaves Boolean for whether A and B are approximately equal (their difference is less than or equal to `EPSILON`).","takes":[[0,0],[1,0]],"leaves":[[1,0]],"erefs":[[30,218],[31,218]],"outbound":[]},{"name":"<=","effect":"( A B -- true/false ):","markdown":"leaves whether A <= B.\n","primer":"leaves whether A <= B.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[30,219],[31,219]],"outbound":[]},{"name":">","effect":"( A B -- true/false ):","markdown":"leaves whether A > B.\n","primer":"leaves whether A > B.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[30,220],[31,220]],"outbound":[]},{"name":">=","effect":"( A B -- true/false ):","markdown":"leaves whether A >= B.\n","primer":"leaves whether A >= B.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[30,221],[31,221]],"outbound":[]},{"name":"zero?","effect":"( A -- true/false ):","markdown":"leaves whether A = 0\n","primer":"leaves whether A = 0","takes":[[0,0]],"leaves":[],"erefs":[[30,222]],"outbound":[]},{"name":"positive?","effect":"( A -- true/false ):","markdown":"leaves whether A >= 0\n","primer":"leaves whether A >= 0","takes":[[0,0]],"leaves":[],"erefs":[[30,223]],"outbound":[]},{"name":"negative?","effect":"( A -- true/false ):","markdown":"leaves whether A < 9\n","primer":"leaves whether A < 9","takes":[[0,0]],"leaves":[],"erefs":[[30,224]],"outbound":[]},{"name":"/?","effect":"( A B -- true/false ):","markdown":"leaves whether A is divisible by B.\n","primer":"leaves whether A is divisible by B.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[30,225],[31,225]],"outbound":[]},{"name":"even?","effect":"( N -- true/false ):","markdown":"leaves whether A is even (divisible by two).\n","primer":"leaves whether A is even (divisible by two).","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"odd?","effect":"( N -- true/false ):","markdown":"leaves whether A is odd.\n","primer":"leaves whether A is odd.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"empty?","effect":"( B -- true/false ):","markdown":"leaves whether Block is empty.\n","primer":"leaves whether Block is empty.","takes":[[0,0]],"leaves":[],"erefs":[[5,228]],"outbound":[]},{"name":"false?","effect":"( F -- true/false ):","markdown":"Leaves whether Form is `false`.\n","primer":"Leaves whether Form is `false`.","takes":[[0,0]],"leaves":[],"erefs":[[1,229]],"outbound":[]},{"name":"true?","effect":"( F --  true/false ):","markdown":"converts Form into boolean.\n","primer":"converts Form into boolean.","takes":[[0,0]],"leaves":[],"erefs":[[1,230]],"outbound":[]},{"name":"not","effect":"( F -- true/false ):","markdown":"leaves inverse boolean for Form.\n","primer":"leaves inverse boolean for Form.","takes":[[0,0]],"leaves":[],"erefs":[[1,231]],"outbound":[]},{"name":"toCapitalized","effect":"( Q -- Q' ):","markdown":"capitalizes Quote: transforms the first letter of Quote to uppercase.\n","primer":"capitalizes Quote: transforms the first letter of Quote to uppercase.","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[12,232]],"outbound":[]},{"name":"~","effect":"( A B -- Q ):","markdown":"obtains Quote by stitching (and enquoting, if necessary) two forms, A and B.\n\n```\n100 200 ~ leaves: '100200'\n'hello' 'world' ~ leaves: 'helloworld'\n```\n","primer":"obtains Quote by stitching (and enquoting, if necessary) two forms, A and B.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[12,233],[30,233],[31,233]],"outbound":[]},{"name":"~*","effect":"( F -- Q ):","markdown":"like `here join`, but faster and not recursive in case Form is a block. Else, same as `toQuote`. Leaves the resulting Quote.\n\n```\n123 ~* leaves: '123'\n[ 1 2 3 ] ~* leaves: '123'\n\n'John' $: name\n[ 'My name is ' name '!' ] ~* leaves: 'My name is John!'\n```\n\nBeware that the referenced entries are only resolved. They are not opened. Consider using `vals join` if you want to stitch results instead.\n\n```\n[ 1 2 + ] @: foo\n\n[ 'foo = ' foo ] ~* leaves: 'foo = [ 1 2 + ]'\n\n\"You can use this if you want to evaluate first:\"\n[ 'foo = ' foo ] vals join leaves: 'foo = 3'\n```\n","primer":"like `here join`, but faster and not recursive in case Form is a block.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[1,234],[12,234]],"outbound":[472]},{"name":"parseDecimal","effect":"( Q -- D ):","markdown":"converts Quote to Decimal. Dies if Quote does not contain a decimal, or if couldn't parse it out.\n\nQuote is parsed by Novika. This word only ensures the result of that is a decimal. Aside from error messages that leak this fact, you generally shouldn't care about this.\n\n```\n'1234' parseDecimal leaves: 1234\n'-1234.5678' parseDecimal leaves: -1234.5678\n```\n","primer":"converts Quote to Decimal.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[83,235],[12,235]],"outbound":[]},{"name":"2drop","effect":"( A B -- ):","markdown":"drops a pair of forms.\n\n```\n1 2 2drop leaves: [ ]\n```\n","primer":"drops a pair of forms.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"nip","effect":"( A B -- B ):","markdown":"drops a form under the top.\n\n```\n1 2 nip leaves: [ 2 ]\n```\n","primer":"drops a form under the top.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"nup","effect":"( A B -- A A B ):","markdown":"duplicates a form under the top.\n\n```\n1 2 nup leaves: [ 1 1 2 ]\n```\n","primer":"duplicates a form under the top.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"over","effect":"( A B -- A B A ):","markdown":"duplicates a form over the top.\n\n```\n1 2 over leaves: [ 1 2 1 ]\n```\n","primer":"duplicates a form over the top.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"tuck","effect":"( A B - B A B ):","markdown":"puts a duplicate of the top form before the second-from-top form.\n\n```\n1 2 tuck leaves: [ 2 1 2 ]\n```\n","primer":"puts a duplicate of the top form before the second-from-top form.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"2dup","effect":"( A B -- A B A B ):","markdown":"duplicates a pair of forms.\n\n```\n1 2 2dup leaves: [ 1 2 1 2 ]\n```\n","primer":"duplicates a pair of forms.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"rot","effect":"( A B C -- B C A ):","markdown":"moves thirdmost form to the top.\n\n```\n1 2 3 rot leaves: [ 2 3 1 ]\n      rot leaves: [ 3 1 2 ]\n      rot leaves: [ 1 2 3 ]\n```\n","primer":"moves thirdmost form to the top.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"-rot","effect":"( A B C -- C A B ):","markdown":"moves top form so it's thirdmost.\n\n```\n1 2 3 -rot leaves: [ 3 1 2 ]\n      -rot leaves: [ 2 3 1 ]\n      -rot leaves: [ 1 2 3 ]\n```\n","primer":"moves top form so it's thirdmost.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"asStack","effect":"( B -- ):","markdown":"replaces current stack with Block in-place. Cursor position is saved (clamped to Block end if Block is smaller)\n","primer":"replaces current stack with Block in-place.","takes":[[0,0]],"leaves":[],"erefs":[[5,244]],"outbound":[]},{"name":"dip","effect":"( ... T dip: F -- ... F' T ):","markdown":"opens Form behind Top.\n\n```\n1 2 4 [ + ] dip leaves: [ 3 4 ]\n1 2 4 100 dip leaves: [ 1 2 100 4 ]\n```\n","primer":"opens Form behind Top.","takes":[[1,0],[0,0]],"leaves":[[0,0],[1,0]],"erefs":[[1,245],[62,245]],"outbound":[]},{"name":"dip:","effect":"( ... T dip: F -- ... F' T ):","markdown":"infix version of `dip`.\n","primer":"infix version of `dip`.","takes":[[1,0],[0,0]],"leaves":[[0,0],[1,0]],"erefs":[[1,245],[62,245]],"outbound":[245]},{"name":"keep","effect":"( ... T F -- ... F' T ):","markdown":"opens Form with Top on top of the stack, restoring Top after it is opened.\n\n```\n1 2 4 [ + ] keep leaves: [ 1 6 4 ]\n1 2 4 'hello' keep leaves: [ 1 2 4 'hello' 4 ]\n```\n","primer":"opens Form with Top on top of the stack, restoring Top after it is opened.","takes":[[1,0],[0,0]],"leaves":[[0,0],[1,0]],"erefs":[[1,247],[62,247]],"outbound":[]},{"name":"keep:","effect":"( ... T keep: F -- ... F' T ):","markdown":"infix version of `keep`.\n","primer":"infix version of `keep`.","takes":[[1,0],[0,0]],"leaves":[[0,0],[1,0]],"erefs":[[1,247],[62,247]],"outbound":[247]},{"name":"bi","effect":"( F A B -- A' B' ):","markdown":"opens two blocks, A and B, with Form placed on top of the stack for each one, and leaves their results in order.\n\n```\n[ 1 2 3 ] [ sum ] [ count ] bi / leaves: 2\n```\n","primer":"opens two blocks, A and B, with Form placed on top of the stack for each one, and leaves their results in order.","takes":[[2,0],[0,0],[1,0]],"leaves":[[0,0],[1,0]],"erefs":[[30,249],[31,249],[1,249]],"outbound":[]},{"name":"bi:","effect":"( F bi: A B -- A' B' ):","markdown":"infix version of `bi`.\n\n```\n[ 1 2 3 ] bi: sum count / leaves: 2\n```\n","primer":"infix version of `bi`.","takes":[[2,0],[0,0],[1,0]],"leaves":[[0,0],[1,0]],"erefs":[[30,249],[31,249],[1,249]],"outbound":[249]},{"name":"bi*","effect":"( Af Bf A B -- A' B' ):","markdown":"opens block A with A form, block B with B form, and leaves the results.\n\nNote: the result of opening A is available to B.\n\n```\n[ 1 2 ] [ 3 4 ] [ first ] [ last ] bi* leaves: [ 1 4 ]\n\n\"Note how we use the result of the first block in the\n second block:\"\n[ 1 2 ] [ 3 4 ] [ first ] [ last + ] bi* leaves: [ 5 ]\n```\n","primer":"opens block A with A form, block B with B form, and leaves the results.","takes":[[0,0],[1,0],[2,0],[3,0]],"leaves":[[2,0],[3,0]],"erefs":[[90,251],[91,251],[30,251],[31,251]],"outbound":[]},{"name":"bi*:","effect":"( Af Bf bi*: A B -- A' B' ):","markdown":"infix version of `bi*`.\n","primer":"infix version of `bi*`.","takes":[[0,0],[1,0],[2,0],[3,0]],"leaves":[[2,0],[3,0]],"erefs":[[90,251],[91,251],[30,251],[31,251]],"outbound":[251]},{"name":"bi@","effect":"( X Y B -- Bx By ):","markdown":"leaves the results of applying Block first to X form, and then to Y form.\n\n```\n1 2 [ 'X =' swap ~ ] bi@ leaves: [ 'X = 1' 'X = 2' ]\n```\n","primer":"leaves the results of applying Block first to X form, and then to Y form.","takes":[[0,0],[2,0],[1,0]],"leaves":[],"erefs":[[9,253],[5,253],[10,253]],"outbound":[]},{"name":"bi@:","effect":"( X Y bi@: B -- Bx By ):","markdown":"infix version of `bi@`.\n","primer":"infix version of `bi@`.","takes":[[0,0],[2,0],[1,0]],"leaves":[],"erefs":[[9,253],[5,253],[10,253]],"outbound":[253]},{"name":"<<|","effect":"( -- ):","markdown":"moves cursor left twice in the active stack, opposite of `|&gt;&gt;`. Same as `&lt;| &lt;|` but looks nicer.\n\n```\n[ a b c | ] |: [ <<| 123 |>> 456 ] leaves: [ [ a 123 b c 456 ] ]\n```\n","primer":"moves cursor left twice in the active stack, opposite of `|&gt;&gt;`.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"|>>","effect":"( -- ):","markdown":"moves cursor right twice in the active stack, opposite of `&lt;&lt;|`. Same as `|&gt; |&gt;` but looks nicer.\n\nSee `&lt;&lt;|` for an example of how you can use this word.\n","primer":"moves cursor right twice in the active stack, opposite of `&lt;&lt;|`.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"echo","effect":"( F -- ):","markdown":"enquotes Form, and appends the resulting quote, followed by newline, to the standard output stream.\n","primer":"enquotes Form, and appends the resulting quote, followed by newline, to the standard output stream.","takes":[[0,0]],"leaves":[],"erefs":[[1,257]],"outbound":[]},{"name":"help","effect":"( help F -- ):","markdown":"echoes help for Form. If form is a word, fetches it in caller first.\n","primer":"echoes help for Form.","takes":[[0,0]],"leaves":[],"erefs":[[1,258]],"outbound":[]},{"name":"2echo","effect":"( F1 F2 -- ):","markdown":"echoes a pair of Forms.\n","primer":"echoes a pair of Forms.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"p","effect":"( F -- F ):","markdown":"echoes a Form but leaves it on the stack.\n","primer":"echoes a Form but leaves it on the stack.","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[1,260]],"outbound":[]},{"name":"2p","effect":"( F1 F2 -- F1 F2 ):","markdown":"echoes a pair of Forms but leaves them on the stack.\n","primer":"echoes a pair of Forms but leaves them on the stack.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"measure","effect":"( B -- Mt ):","markdown":"leaves Monotonic time difference in milliseconds for Block (leaves the time Block took to execute, in ms).\n","primer":"leaves Monotonic time difference in milliseconds for Block (leaves the time Block took to execute, in ms).","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[92,262],[5,262]],"outbound":[]},{"name":"okbye","effect":"( -- ):","markdown":"ends the program with the exit code 1 (an error).\n","primer":"ends the program with the exit code 1 (an error).","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"newBlockSet","effect":"( -- ::set:: ):","markdown":"a set-like data structure for storing blocks (and only blocks) by their address, or some other property based on the key (mapper) block, see `::set::/keyBy` .\n\nEntry order (and iteration order) is exactly the insertion order.\n\nExposes the following words: `add[:]`, `remove[:]`, `has?` and `has:`, `each[:]`, `keyBy[:]`.\n\n```\nnewBlockSet $: set\n\n[ 1 2 ] $: foo\n[ 3 4 ] $: bar\n[ 1 2 ] $: baz\n\nset.add: foo\nset.add: bar\n\nset.has: foo leaves: true\nset.has: bar leaves: true\nset.has: baz leaves: false\n\nset.remove: bar\nset.has: bar leaves: false\n\nset.add: baz\nset.has: baz leaves: true\n\nset.each: [ echo ]\n\"STDOUT: [ 1 2 ]\u23ce[ 1 2 ]\u23ce\"\n\n\"The first printed block is `foo` and the second is `baz`.\n Despite looking the same, they are different blocks stored\n at different addresses!\"\n```\n","primer":"a set-like data structure for storing blocks (and only blocks) by their address, or some other property based on the key (mapper) block, see `::set::/keyBy` .","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"${","effect":"( E... -- ):","markdown":"same as `$:` but allows to define multiple pusher Entries simultaneously, and in the 'human-readable' order.\n\n```\n[ ${ x y } this ] @: point\n\n100 200 point -> [ x y ]\n  leaves: [ [ 100 200 ] ]\n```\n","primer":"same as `$:` but allows to define multiple pusher Entries simultaneously, and in the 'human-readable' order.","takes":[[0,0]],"leaves":[],"erefs":[[93,265]],"outbound":[2]},{"name":"@{","effect":"( E... -- ):","markdown":"same as `@:`, but allows to define multiple opener Entries simultaneously, and in the 'human-readable' order.\n\n```\n[ @{ x y }\n\n  [ bi*: [x +] [y +] ={ x y } ] @: move\n\n  this\n] @: point\n\n\"Point A has decimals under X and Y\"\n100 200 point $: A\n\n\"Point B is inset some...\"\n[ A.x 10 + ] [ A.y 5 + ] point $: B\n\nA.x A.y leaves: [ 100 200 ]\nB.x B.y leaves: [ 110 205 ]\n\n\"Move A some...\"\n10 10 A.move\n\nA.x A.y leaves: [ 110 210 ]\nB.x B.y leaves: [ 120 215 ]\n```\n","primer":"same as `@:`, but allows to define multiple opener Entries simultaneously, and in the 'human-readable' order.","takes":[[0,0]],"leaves":[],"erefs":[[93,266]],"outbound":[1]},{"name":"={","effect":"( E... -- ):","markdown":"same as `=:`, but allows to submit multiple Entries simultaneously, and in the 'human-readable' order.\n\n```\n[ @{ x y }\n\n  [ ={ x y } ] @: update\n\n  this\n] @: point\n\n0 0 point $: A\n\nA.x A.y leaves: [ 0 0 ]\n\n100 200 A.update\n\nA.x A.y leaves: [ 100 200 ]\n```\n","primer":"same as `=:`, but allows to submit multiple Entries simultaneously, and in the 'human-readable' order.","takes":[[0,0]],"leaves":[],"erefs":[[93,267]],"outbound":[3]},{"name":"choose","effect":"( F Cl -- Cb' ):","markdown":"high-level conditional. Acts similar to `case` or `switch` in other languages. Takes a Form to match over, and a Case list in the form `[ Condition Case-Body Condition Case-Body ... ]`. Leaves the result of Case body corresponding to the condition that matched Form, otherwise (if no cases matched), Form itself.\n\n```novika\n1 to: 100 each: [\n  [ [ 15 /? ] 'FizzBuzz'\n    [  5 /? ] 'Buzz'\n    [  3 /? ] 'Fizz'\n  ] choose echo\n]\n```\n","primer":"high-level conditional.","takes":[[2,0],[0,0]],"leaves":[[1,0]],"erefs":[[94,268],[95,268],[1,268]],"outbound":[]},{"name":"_","effect":"( A B -- B A ):","markdown":"same as `swap`, but is more readable and compact in certain scenarios.\n\n```\n[ 'Judy' 'Mark' 'Fabian' 'Huggee' ] $: pets\n\norphan $: ages\n\npets each: [\n  ages _ (0 randTo: 15) pushes\n]\n\n\"Your numbers will probably be different because we're\n generating them randomly:\"\nages -> 'Judy' leaves: 1\nages -> 'Mark' leaves: 8\nages -> 'Fabian' leaves: 11\nages -> 'Huggee' leaves: 14\n```\n","primer":"same as `swap`, but is more readable and compact in certain scenarios.","takes":[],"leaves":[],"erefs":[],"outbound":[374]},{"name":"runTestsInGroup:","effect":"( runTestsInGroup: G -- B ):","markdown":"runs all test cases under Group. Reports the results on-the-fly. Dies if Group doesn't exist. Leaves Boolean for whether all tests in Group succeeded.\n","primer":"runs all test cases under Group.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[96,270],[97,270]],"outbound":[]},{"name":"describe","effect":"( describe Dq B -- ):","markdown":"groups multiple test cases (listed in Block) under a single Description quote.\n\nDescribes can be grouped under so-called *test groups*. Unless you provide a group (or several) yourself, the describe will belong to the test group called 'rogue'.\n\nYou can specify one or more groups the describe will belong to using `in`. The following describes are grouped under 'rogue':\n\n```\ndescribe 'Foo' [\n  it should 'work' [ \"...\" ]\n]\n\ndescribe 'Bar' [\n  it should 'a' [ \"...\" ]\n  it should 'b' [ \"...\" ]\n]\n```\n\nThe following describes are grouped under 'foo':\n\n```\ndescribe 'Foo' [\n  in foo\n\n  it should 'work' [ \"...\" ]\n]\n\ndescribe 'Bar' [\n  in foo\n\n  it should 'a' [ \"...\" ]\n  it should 'b' [ \"...\" ]\n]\n```\n\nYou can run a test group using the word `runTestsInGroup:`. It will run all tests and echo the test report to the standard output on the fly. With describes as above, that is, belonging to the group 'foo', you can run them like so:\n\n```\nrunTestsInGroup: foo\n```\n\nDescribes can belong to multiple groups:\n\n```\ndescribe 'Foo' [\n  in a\n  in b\n\n  it should 'happy path' [ true true assert= ]\n]\n\ndescribe 'Bar' [\n  in a\n\n  it should 'sad path' [ true false assert= ]\n]\n\nrunTestsInGroup: a  \"runs Foo and Bar\"\nrunTestsInGroup: b  \"runs Foo\"\n```\n","primer":"groups multiple test cases (listed in Block) under a single Description quote.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,271],[98,271]],"outbound":[270]},{"name":"leaves:","effect":"( ... leaves: B -- ... ):","markdown":"compares active stack with Block: noop if equal via `=`, otherwise, dies. Note that only N last items in active stack are compared with Block, where N is the amount of items in Block.\n\n```\n100 leaves: [ 100 ] \"Stack has 100 now.\"\n200 leaves: [ 100 200 ] \"Stack has 100 and 200.\"\n300 leaves: [ 300 ] \"Stack has 100 and 200 and 300\"\n```\n","primer":"compares active stack with Block: noop if equal via `=`, otherwise, dies.","takes":[[0,0]],"leaves":[],"erefs":[[5,272]],"outbound":[386]},{"name":"sdl:keysym","effect":"","markdown":"The SDL keysym structure, used in key events.\n\nIf you are looking for translated character input, see the `sdl:textInputEvent`.\n\n* `scancode`: SDL physical key code (see `sdl:scancode:*`)\n* `keycode`: SDL virtual key code.\n* `mod`: current key modifiers.\n","primer":"The SDL keysym structure, used in key events.","takes":[],"leaves":[],"erefs":[],"outbound":[439,280]},{"name":"sdl:commonEvent","effect":"","markdown":"Fields shared by every event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n","primer":"Fields shared by every event.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:displayEvent","effect":"","markdown":"Display state change event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `display`: the associated display index.\n* `event`: one of `sdl:displayEvent:*`.\n* `data1`: event dependent data.\n","primer":"Display state change event.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:windowEvent","effect":"","markdown":"Window state change event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: the associated window.\n* `event`: one of `sdl:windowEvent:*`.\n* `data1`: event dependent data.\n* `data2`: event dependent data.\n","primer":"Window state change event.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:keyboardEvent","effect":"","markdown":"Keyboard button event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with keyboard focus, if any.\n* `state`: `sdl:pressedState` or `sdl:releasedState`\n* `repeat`: non-zero if this is a key repeat\n* `event`: one of `sdl:windowEvent:*`.\n* `keysym`: the key that was pressed or released, see `sdl:keysym`.\n","primer":"Keyboard button event.","takes":[],"leaves":[],"erefs":[],"outbound":[182,306,273]},{"name":"sdl:textEditingEvent","effect":"","markdown":"Keyboard text editing event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with keyboard focus, if any.\n* `text`: points to 32 `u8`s of the the editing text.\n* `start`: the start cursor of selected editing text.\n* `length`: the length of selected editing text.\n","primer":"Keyboard text editing event.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:textEditingEvent*","effect":"","markdown":"Extended keyboard text editing event when text would be truncated if stored in the text buffer `sdl:textEditingEvent`.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with keyboard focus, if any.\n* `text`: the editing text, which should be freed with `sdl:free`, and will not be NULL.\n* `start`: the start cursor of selected editing text.\n* `length`: the length of selected editing text.\n","primer":"Extended keyboard text editing event when text would be truncated if stored in the text buffer `sdl:textEditingEvent`.","takes":[],"leaves":[],"erefs":[],"outbound":[306,278]},{"name":"sdl:textInputEvent","effect":"","markdown":"Keyboard text input event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with keyboard focus, if any.\n* `text`: points to 32 `u8`s of the the editing text.\n","primer":"Keyboard text input event.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:mouseMotionEvent","effect":"","markdown":"Mouse motion event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with mouse focus, if any.\n* `which`: the mouse instance id, or `sdl:touchMouseId`\n* `state`: the current button state (`sdl:pressedState` or `sdl:releasedState`).\n* `x`: X coordinate, relative to window.\n* `y`: Y coordinate, relative to window.\n* `xrel`: The relative motion in the X direction.\n* `yrel`: The relative motion in the Y direction.\n","primer":"Mouse motion event.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:mouseButtonEvent","effect":"","markdown":"Mouse button event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with mouse focus, if any.\n* `which`: the mouse instance id, or `sdl:touchMouseId`.\n* `button`: the mouse button index.\n* `state`: the current button state (`sdl:pressedState` or `sdl:releasedState`).\n* `clicks`: 1 for single-click, 2 for double-click, etc.\n* `x`: X coordinate, relative to window.\n* `y`: Y coordinate, relative to window.\n","primer":"Mouse button event.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:mouseWheelEvent","effect":"","markdown":"Mouse wheel event structure.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with mouse focus, if any.\n* `which`: the mouse instance id, or `sdl:touchMouseId`.\n* `x`: the amount scrolled horizontally, positive to the right and negative to the left.\n* `y`: the amount scrolled vertically, positive away from the user and negative toward the user.\n* `direction`: set to one of `sdl:mouseWheel:*`. When `sdl:mouseWheel:flipped`, the values in X and Y will be opposite. Multiply by -1 to change them back.\n* `preciseX`: the amount scrolled horizontally, positive to the right and negative to the left, with float precision.\n* `preciseY`: The amount scrolled vertically, positive away from the user and negative toward the user, with float precision.\n* `mouseX`: X coordinate, relative to window.\n* `mouseY`: Y coordinate, relative to window.\n","primer":"Mouse wheel event structure.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:dropEvent","effect":"","markdown":"An event used to request a file open by the system. This event is enabled by default, you can disable it with `sdl:eventState`.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `file`: points to the file name, which should be freed with `sdl:free`. Is NULL on begin/complete.\n* `windowID`: the window that was dropped on, if any.\n","primer":"An event used to request a file open by the system.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:quitEvent","effect":"","markdown":"The \"quit requested\" event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n","primer":"The \"quit requested\" event.","takes":[],"leaves":[],"erefs":[],"outbound":[306]},{"name":"sdl:event","effect":"","markdown":"General event structure.\n\n* `type`: event type, shared with all events.\n\nThe following is a list of event types/fields that are implemented. Those that are simply `pointer`s are unimplemented.\n\n* `common`: common event data (see `sdl:commonEvent`).\n* `display`: display event data (see `sdl:displayEvent`).\n* `window`: window event data (see `sdl:windowEvent`).\n* `key`: keyboard event data (see `sdl:keyboardEvent`).\n* `edit`: text editing event data (see `sdl:textEditingEvent`).\n* `edit*`: extended text editing event data (see `sdl:textEditingEvent*`).\n* `text`: text input event data (see `sdl:textInputEvent`).\n* `motion`: mouse motion event data (see `sdl:mouseMotionEvent`).\n* `button`: mouse button event data (see `sdl:mouseButtonEvent`).\n* `wheel`: mouse wheel event data (see `sdl:mouseWheelEvent`).\n* `quit`: quit request event data (see `sdl:quitEvent`).\n* `drop`: drag and drop event data (see `sdl:dropEvent`).\n","primer":"General event structure.","takes":[],"leaves":[],"erefs":[],"outbound":[282,275,279,284,276,283,280,277,274,373,278,281,285]},{"name":"sdl:intPoint","effect":"","markdown":"The structure that defines a point (integer).\n\n* `x`: the X coordinate of the point.\n* `y`: the Y coordinate of the point.\n","primer":"The structure that defines a point (integer).","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:floatPoint","effect":"","markdown":"The structure that defines a point (floating point).\n\n* `x`: the X coordinate of the point.\n* `y`: the Y coordinate of the point.\n","primer":"The structure that defines a point (floating point).","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:intRect","effect":"","markdown":"A rectangle, with the origin at the upper left (integer).\n\n* `x`: the X coordinate of the rectangle.\n* `y`: the Y coordinate of the rectangle.\n* `w`: width of the rectangle.\n* `h`: height of the rectangle.\n","primer":"A rectangle, with the origin at the upper left (integer).","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:floatRect","effect":"","markdown":"A rectangle, with the origin at the upper left (floating point).\n\n* `x`: the X coordinate of the rectangle.\n* `y`: the Y coordinate of the rectangle.\n* `w`: width of the rectangle.\n* `h`: height of the rectangle.\n","primer":"A rectangle, with the origin at the upper left (floating point).","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:intRectsIntersect?","effect":"( R1 R2 -- 0/1 ):","markdown":"leaves whether the two integer Rectangles intersect. If either is null will leave 0.\n","primer":"leaves whether the two integer Rectangles intersect.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:floatRectsIntersect?","effect":"( R1 R2 -- 0/1 ):","markdown":"leaves whether the two floating point Rectangles intersect. If either is null will leave 0.\n","primer":"leaves whether the two floating point Rectangles intersect.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:writeIntRectIntersection?","effect":"( R1 R2 Rh -- 0/1 ):","markdown":"calculate the intersection of two integer Rectangles and writes it into Result hole.\n","primer":"calculate the intersection of two integer Rectangles and writes it into Result hole.","takes":[[0,0]],"leaves":[],"erefs":[[99,293]],"outbound":[]},{"name":"sdl:writeFloatRectIntersection?","effect":"( R1 R2 Rh -- 0/1 ):","markdown":"calculate the intersection of two floating point Rectangles and writes it into Result hole.\n","primer":"calculate the intersection of two floating point Rectangles and writes it into Result hole.","takes":[[0,0]],"leaves":[],"erefs":[[99,294]],"outbound":[]},{"name":"sdl:writeIntRectUnion?","effect":"( R1 R2 Rh -- 0/1 ):","markdown":"calculate the union of two integer Rectangles and writes it into Result hole.\n","primer":"calculate the union of two integer Rectangles and writes it into Result hole.","takes":[[0,0]],"leaves":[],"erefs":[[99,295]],"outbound":[]},{"name":"sdl:writeFloatRectUnion?","effect":"( R1 R2 Rh -- 0/1 ):","markdown":"calculate the union of two floating point Rectangles and write it into Result hole.\n","primer":"calculate the union of two floating point Rectangles and write it into Result hole.","takes":[[0,0]],"leaves":[],"erefs":[[99,296]],"outbound":[]},{"name":"sdl:color","effect":"","markdown":"Represents a color.\n\n* `r`: the red component in the range 0-255.\n* `g`: the green component in the range 0-255.\n* `b`: the blue component in the range 0-255.\n* `a`: the alpha component in the range 0-255.\n","primer":"Represents a color.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:palette","effect":"","markdown":"Palette information.\n\n* `ncolors`: the number of colors in the palette.\n* `colors`: an array of `sdl:color`s representing the palette.\n","primer":"Palette information.","takes":[],"leaves":[],"erefs":[],"outbound":[297]},{"name":"sdl:pixelFormat","effect":"","markdown":"Pixel format information. Everything is read-only.\n\n* `format`: one of `sdl:pixelFormat:*`\n* `palette`: an `sdl:palette` structure associated with this pixel format, or null if the format doesn't have a palette.\n* `bitsPerPixel`: the number of significant bits in a pixel value, e.g.: 8, 15, 16, 24, 32.\n* `bytesPerPixel`: the number of bytes required to hold a pixel value, e.g.: 1, 2, 3, 4.\n* `rmask`: a mask representing the location of the red component of the pixel.\n* `gmask`: a mask representing the location of the green component of the pixel.\n* `bmask`: a mask representing the location of the blue component of the pixel.\n* `amask`: a mask representing the location of the alpha component of the pixel or 0 if the pixel format doesn't have any alpha information.\n","primer":"Pixel format information.","takes":[],"leaves":[],"erefs":[],"outbound":[298]},{"name":"sdl:surface","effect":"","markdown":"A collection of pixels used in software blitting.\n\n* Read-only `format`: the format of the pixels stored in the surface.  See `sdl:pixelFormat`.\n* Read-only `w`, `h`: the width and height in pixels.\n* Read-only `pitch`: the length of a row of pixels in bytes.\n* Read-write `pixels`: the pointer to the actual pixel data.\n* Read-write `userdata`: an arbitrary pointer you can set.\n* Read-only `clipRect`: an `sdl:intRect` structure used to clip blits to the surface. Can be set by `sdl:setClipRect`.\n","primer":"A collection of pixels used in software blitting.","takes":[],"leaves":[],"erefs":[],"outbound":[289,299]},{"name":"sdl:init","effect":"( F -- S ):","markdown":"initializes the SDL library given subsystem initialization Flags (any of `sdl:init:*` OR'd together). Leaves 0 on success or a negative error code on failure; use `sdl:error` for more information.\n","primer":"initializes the SDL library given subsystem initialization Flags (any of `sdl:init:*` OR'd together).","takes":[[0,0]],"leaves":[],"erefs":[[100,301]],"outbound":[305]},{"name":"sdl:deinit","effect":"( F -- ):","markdown":"shuts down specific SDL subsystems given any of the flags used by `sdl:init`.\n\nYou still need to call `sdl:quit` even if you close all open subsystems with `sdl:deinit`.\n","primer":"shuts down specific SDL subsystems given any of the flags used by `sdl:init`.","takes":[[0,0]],"leaves":[],"erefs":[[100,301]],"outbound":[321,301]},{"name":"sdl:createWindow","effect":"( T X Y W H F -- P ):","markdown":"creates a window and leaves a Pointer to it (or null if there was an error).\n\nThe window is created with the given Title, at the specified X and Y coordinates (these can also be set to `sdl:window:centered` or `sdl:window:positionUndefined`), with the specified Width and Height (in screen coordinates), and according to Flags.\n\nSee `sdl:window:*` for Flags.\n","primer":"creates a window and leaves a Pointer to it (or null if there was an error).","takes":[[0,0],[2,0],[3,0],[4,0],[5,0],[6,0]],"leaves":[[1,0]],"erefs":[[101,303],[102,303],[9,303],[10,303],[103,303],[104,303],[100,303]],"outbound":[]},{"name":"sdl:createRenderer","effect":"( Wp I F -- P ):","markdown":"creates a 2D rendering context for a Window pointer and leaves a pointer to it (or null if there was an error).\n\nWindow pointer is a pointer to the window where rendering is displayed.\n\nIndex is the index of the rendering driver to initialize, or -1 to initialize the first one supporting the requested flags.\n\nFlags is one or more `sdl:renderer:*` flags OR'd together.\n","primer":"creates a 2D rendering context for a Window pointer and leaves a pointer to it (or null if there was an error).","takes":[[2,0],[0,0],[1,0]],"leaves":[],"erefs":[[105,304],[100,304],[106,304]],"outbound":[]},{"name":"sdl:error","effect":"","markdown":"[foreign function: SDL_GetError]\n","primer":"[foreign function: SDL_GetError]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:ticks","effect":"","markdown":"[foreign function: SDL_GetTicks]\n","primer":"[foreign function: SDL_GetTicks]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:renderClear","effect":"","markdown":"[foreign function: SDL_RenderClear]\n","primer":"[foreign function: SDL_RenderClear]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:setRenderDrawColor","effect":"","markdown":"[foreign function: SDL_SetRenderDrawColor]\n","primer":"[foreign function: SDL_SetRenderDrawColor]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:fillRect","effect":"","markdown":"[foreign function: SDL_RenderFillRect]\n","primer":"[foreign function: SDL_RenderFillRect]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:textureFromSurface","effect":"","markdown":"[foreign function: SDL_CreateTextureFromSurface]\n","primer":"[foreign function: SDL_CreateTextureFromSurface]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:destroyTexture","effect":"","markdown":"[foreign function: SDL_DestroyTexture]\n","primer":"[foreign function: SDL_DestroyTexture]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:destroyWindow","effect":"","markdown":"[foreign function: SDL_DestroyWindow]\n","primer":"[foreign function: SDL_DestroyWindow]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:window:setTitle","effect":"","markdown":"[foreign function: SDL_SetWindowTitle]\n","primer":"[foreign function: SDL_SetWindowTitle]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:window:setSize","effect":"","markdown":"[foreign function: SDL_SetWindowSize]\n","primer":"[foreign function: SDL_SetWindowSize]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:destroyRenderer","effect":"","markdown":"[foreign function: SDL_DestroyRenderer]\n","primer":"[foreign function: SDL_DestroyRenderer]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:renderCopy","effect":"","markdown":"[foreign function: SDL_RenderCopy]\n","primer":"[foreign function: SDL_RenderCopy]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:renderPresent","effect":"","markdown":"[foreign function: SDL_RenderPresent]\n","primer":"[foreign function: SDL_RenderPresent]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:pollEvent","effect":"","markdown":"[foreign function: SDL_PollEvent]\n","primer":"[foreign function: SDL_PollEvent]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:waitEvent","effect":"","markdown":"[foreign function: SDL_WaitEvent]\n","primer":"[foreign function: SDL_WaitEvent]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:freeSurface","effect":"","markdown":"[foreign function: SDL_FreeSurface]\n","primer":"[foreign function: SDL_FreeSurface]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:quit","effect":"","markdown":"[foreign function: SDL_Quit]\n","primer":"[foreign function: SDL_Quit]","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"sdl:ensure","effect":"( S -- ):","markdown":"dies with `sdl:error` if Status is negative.\n\nSome SDL and SDL TTF functions return negative integers to signal an error. In this case, this word will die preventing the following code to be executed, so you don't have to worry about handling SDl errors.\n\nNote that by dying you may cause some resources to *not* be freed. Keeping track of that is a task for a higher- level wrapper around these bingings. This word nor any word that is part of these bindings won't do anything about it.\n","primer":"dies with `sdl:error` if Status is negative.","takes":[[0,0]],"leaves":[],"erefs":[[107,322]],"outbound":[305]},{"name":"sdl:notNull","effect":"( P -- ):","markdown":"dies if Pointer is NULL, that is, if Pointer is equal to `0`.\n\nNovika uses decimals to represent pointers, which is unsafe but OK for such low-level code. This word allows you to catch and die on NULLs rather than handling them explicitly, which is a bit more tedious.\n\nNote that by dying you may cause some resources to *not* be freed. Keeping track of that is a task for a higher- level wrapper around these bingings. This word nor any word that is part of these bindings won't do anything about it.\n","primer":"dies if Pointer is NULL, that is, if Pointer is equal to `0`.","takes":[[0,0]],"leaves":[],"erefs":[[102,323]],"outbound":[]},{"name":"sdl:ttf:init","effect":"( -- 0/-1 ):","markdown":"initializes the truetype font API.\n\nMust be called before using other functions in this library, except `sdl:ttf:init?`. SDL does not have to be initialized before this call.\n\nLeaves 0 if initialization was successful or -1 if an error occured. Use `sdl:error` to get a human-readable error message for this word and for words in this library which leave 0/-1 to signal an error.\n","primer":"initializes the truetype font API.","takes":[],"leaves":[],"erefs":[],"outbound":[305]},{"name":"sdl:ttf:quit","effect":"( -- ):","markdown":"shuts down and cleans up the truetype font API.\n\nAfter calling this the `sdl:ttf` library functions should not be used, except for `sdl:ttf:init?`. You may, of course, use `sdl:ttf:init` to use the functionality again.\n","primer":"shuts down and cleans up the truetype font API.","takes":[],"leaves":[],"erefs":[],"outbound":[324]},{"name":"sdl:ttf:open","effect":"( Fn Ps -- Fp/0 ):","markdown":"loads and leaves Font pointer from the provided File name, uses the given Point size. The latter basically translates to pixel height.\n\nLeaves NULL (0) on error.\n","primer":"loads and leaves Font pointer from the provided File name, uses the given Point size.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[108,326],[109,326],[110,326]],"outbound":[]},{"name":"sdl:ttf:close","effect":"( Fp -- ):","markdown":"free the memory used by font at Foint pointer, and free font itself as well. Do not use font after this without loading a new font to it.\n","primer":"free the memory used by font at Foint pointer, and free font itself as well.","takes":[[0,0]],"leaves":[],"erefs":[[111,327]],"outbound":[]},{"name":"sdl:ttf:putSize","effect":"( Fp Q Wh Hh -- 0/-1 ):","markdown":"calculates the resulting surface size of Quote rendered using the font behind Font pointer. Width is put into Width hole, and height is put into Height hole.\n\nConsider using `sdl:ttf:size` which create and read from the holes for you.\n","primer":"calculates the resulting surface size of Quote rendered using the font behind Font pointer.","takes":[[1,0],[0,0],[2,0],[3,0]],"leaves":[],"erefs":[[12,328],[108,328],[112,328],[113,328]],"outbound":[332]},{"name":"sdl:ttf:getSolidSurface","effect":"( Fp Q Fc -- Sp ):","markdown":"renders Quote painted with Foreground `sdl:color` using font behind Font pointer. Leaves Surface pointer to a new surface containing the rendered quote, *which you must free when it becomes unused*.\n","primer":"renders Quote painted with Foreground `sdl:color` using font behind Font pointer.","takes":[[1,0],[0,0]],"leaves":[[2,0]],"erefs":[[12,329],[108,329],[114,329]],"outbound":[297]},{"name":"sdl:ttf:getShadedSurface","effect":"( Fp Q Fc Bc -- Sp ):","markdown":"renders Quote painted with Foreground color (an `sdl:color~`) with background of Background color (also an `sdl:color~`), using font behind Font pointer. Leaves Surface pointer to a new surface containing the rendered quote, *which you must free when it becomes unused*.\n\nSlower but sharper than `sdl:ttf:getSolidSurface`.\n","primer":"renders Quote painted with Foreground color (an `sdl:color~`) with background of Background color (also an `sdl:color~`), using font behind Font pointer.","takes":[[3,0],[0,0],[1,0],[2,0]],"leaves":[[4,0]],"erefs":[[12,330],[115,330],[116,330],[108,330],[114,330]],"outbound":[329]},{"name":"sdl:ttf:getBlendedSurface","effect":"( Fp Q Fc -- Sp ):","markdown":"renders Quote painted with Foreground color (an `sdl:color~`), using font behind Font pointer. Leaves Surface pointer to a new surface containing the rendered quote, *which you must free when it becomes unused*.\n\nThe sharpest but slowest way to render text. Text is blended with whatever is behind.\n","primer":"renders Quote painted with Foreground color (an `sdl:color~`), using font behind Font pointer.","takes":[[2,0],[0,0],[1,0]],"leaves":[[3,0]],"erefs":[[12,331],[115,331],[108,331],[114,331]],"outbound":[]},{"name":"sdl:ttf:size","effect":"( Fp Q -- W H ):","markdown":"calculates and leaves Width and Height of Quote rendered using the font behind Font pointer.\n","primer":"calculates and leaves Width and Height of Quote rendered using the font behind Font pointer.","takes":[[3,0],[2,0]],"leaves":[[0,0],[1,0]],"erefs":[[103,332],[104,332],[12,332],[108,332]],"outbound":[]},{"name":"novika:version","effect":"( -- Vq ):","markdown":"leaves Version of the frontend as a quote.\n","primer":"leaves Version of the frontend as a quote.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"novika:capabilities","effect":"( -- Lb ):","markdown":"lists the ids of capabilities provided by the frontend in List block.\n\n```\n\"Yours may differ!\"\nnovika:capabilities leaves: [ [ 'essential' 'colors' 'console' ] ]\n```\n","primer":"lists the ids of capabilities provided by the frontend in List block.","takes":[],"leaves":[[0,0]],"erefs":[[8,334]],"outbound":[]},{"name":"withEchoFg","effect":"( C -- ):","markdown":"pushes Color form onto the echo foreground color stack.\n","primer":"pushes Color form onto the echo foreground color stack.","takes":[[0,0]],"leaves":[],"erefs":[[117,335]],"outbound":[]},{"name":"withEchoBg","effect":"( C -- ):","markdown":"pushes Color form onto the echo background color stack.\n","primer":"pushes Color form onto the echo background color stack.","takes":[[0,0]],"leaves":[],"erefs":[[117,336]],"outbound":[]},{"name":"dropEchoFg","effect":"( -- ):","markdown":"drops a color from the echo foreground color stack.\n","primer":"drops a color from the echo foreground color stack.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"dropEchoBg","effect":"( -- ):","markdown":"drops a color from the echo background color stack.\n","primer":"drops a color from the echo background color stack.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"withReverseAppendEcho","effect":"( F -- ):","markdown":"appends Form with foreground and background colors swapped with each other (background color is set to foreground color, and vice versa).\n\nNote: if unsupported by the output stream, will print Form as-is.\n","primer":"appends Form with foreground and background colors swapped with each other (background color is set to foreground color, and vice versa).","takes":[[0,0]],"leaves":[],"erefs":[[1,339]],"outbound":[]},{"name":"withEmphasisAppendEcho","effect":"( F -- ):","markdown":"same as `withColorAppendEcho`, but also emphasizes echo of Form. Bold style is used by default, but implementors may choose e.g. italic.\n","primer":"same as `withColorAppendEcho`, but also emphasizes echo of Form.","takes":[[0,0]],"leaves":[],"erefs":[[1,340]],"outbound":[341]},{"name":"withColorAppendEcho","effect":"( F -- ):","markdown":"appends Form with last color from the echo foreground color stack set as foreground color, and last color from the echo background stack set as background color, to the standard output stream.\n\nNote: some implementations (particularly Novika's default implementation) choose to restrict foreground and background colors to system's basic 16 colors for compatibility & portability. If you want more cross-platform control over colors (and pretty much everything else), take a look at console capability.\n","primer":"appends Form with last color from the echo foreground color stack set as foreground color, and last color from the echo background stack set as background color, to the standard output stream.","takes":[[0,0]],"leaves":[],"erefs":[[1,341]],"outbound":[]},{"name":"appendEcho","effect":"( F -- ):","markdown":"enquotes and appends Form to the standard output stream.\n","primer":"enquotes and appends Form to the standard output stream.","takes":[[0,0]],"leaves":[],"erefs":[[1,342]],"outbound":[]},{"name":"readLine","effect":"( Pf -- Aq true / false ):","markdown":"enquotes and prints Prompt form to the standard output stream. Waits for the user to answer, enquotes the answer and leaves it.\n\nIf user answered the prompt, leaves Answer quote followed by boolean true. Otherwise, leaves boolean false.\n\n```\n'What is your name? ' readLine => echo\n\n\"INPUT: What is your name? John Doe\u23ce\"\n\"STDOUT: John Doe\u23ce\"\n\n\"INPUT: What is your name? <Ctrl-D>\"\n\"[Program exits]\"\n```\n","primer":"enquotes and prints Prompt form to the standard output stream.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[118,343],[119,343]],"outbound":[]},{"name":"readLine*","effect":"( Cb -- Aq true / false ):","markdown":"extended (contextful) version of `readLine`. Accepts Configuration block and leaves Answer quote followed by `true`, otherwise, if the prompt was rejected, leaves just `false`.\n\n## Configuring the prompt\n\nTo configure the prompt you should create a Configuration block and populate it with settings according to how you want the prompt to look like and work.\n\n### Empty or meaningless configuration block\n\nIf you pass an empty Configuration block or one that has no entries that are of interest to `readLine*`, then you will get an empty prompt but a prompt nonetheless (i.e. everything will work fine; *all of the settings below are opt-in*).\n\n### Available settings\n\n#### `prompt`\n\n`prompt` allows you to assign the prompt quote. In case it is an opener entry it will be opened like so: `( L -- Pq )` where P is the prompt quote and L is the line number (because multiline editing is supported). So you can set custom prompts for every line, or use only one for all of them.\n\n```\n[ '>>> ' $: prompt ] obj readLine*\n\n\"\"\"\n>>> example inp|ut\n\n>>> example multiline\n>>> inp|ut\n\"\"\"\n\n[ [ 1 = sel: '>>> ' '... ' ] @: prompt ] readLine*\n\n\"\"\"\n>>> example multiline\n... inp|ut\n\"\"\"\n```\n\n#### `history`\n\nIf Configuration block has a `history` entry (a quote), then history is going to be saved to, and loaded from that entry.\n\nIf there is no `history` entry in the Configuration block, then history is not going to be persisted.\n\n```\n[ ('>>> ' $: prompt) ('' $: history) ] obj $: config\n\nloop: [\n  config readLine* not => break\n\n  [\n    'h' [ config.history echo ]\n    [ ] [ echo ]\n  ] choose\n]\n\n\"Do something with the history after the loop breaks...\"\n\n'History after the loop: ' config.history 2echo\n```\n\n#### `more?`\n\n`more?` allows to specify whether more of the input should be expected, that is, if the prompt should continue on another line.\n\nBy default it is `false`, and is expected to be boolean `false` or anything else (interpreted as `true`). If `more?` is an opener, it is expected to be compatible with the following signature: `( Paq -- true / false )`, where Paq is the partial answer quote. If the block leaves anything other than `true` or `false`, that is interpreted as `true`.\n\n```\n[ [ 1 = sel: '>>> ' '... ' ] @: prompt\n\n  [ orphan swap\n\n    false $: result \"< Don't need anything else...\"\n\n    [ \"Oops, probably 'slurp' died, so let's try to wait\n       for enough input to not make slurp die...\"\n      true =: result\n    ] @: __died__\n\n    slurp \"Regardless of whether `slurp` dies, we end up here\" result\n  ] @: more?\n] obj $: config\n\n'Enter parseable Novika code or I will go multiline:' echo\n\nloop: [ config readLine* br: echo break ]\n```\n\n#### `delimiters`\n\n`delimiters` is a quote (or a block that leaves a quote in case `delimiters` is an opener entry) that lists *word delimiter* characters, useful for jumping through words and autocompletion.\n\n```\n[ ('Enter your name> ' $: prompt) (' .,-' $: delimiters) ] obj $: config\n\nconfig readLine* not => okbye $: name\n\n[ 'Your name is: ' name ] ~* echo\n```\n\n#### `suggest`\n\nIf `suggest` is a pusher entry, it should be a block of the following shape: `[ title [ ...suggestion ] ]`, where `title` and every one of `suggestion`s are quotes.\n\n`title` followed by colon ':' is displayed above the list of suggestions. The list can be opened using the Tab key, escaped from using Escape.\n\n```\n[ 'Enter your name> ' $: prompt\n\n  [ 'Possible names'\n    [ 'John'\n      'Alice'\n      'Mary'\n      'David' ]\n  ] $: suggest\n] obj $: config\n\nconfig readLine*\n```\n\nIn case `suggest` is an opener, it is expected to be compatible with the following signature: `( P W -- Tq Sb )` where W is the current word (as per `delimiters`), P is the prior quote (all that precedes W), Tq is the title quote, and Sb is the suggestions block.\n\n```\n[ 'Enter expression> ' $: prompt\n\n  ' ' $: delimiters\n\n  [ $: word $: prior\n\n    'Possible evaluations (+, -, *)'\n\n    [ [ ] prior slurp [+] 0 reduce\n      [ ] prior slurp [-] 0 reduce\n      [ ] prior slurp [*] 1 reduce\n    ] vals\n  ] @: suggest\n] obj $: config\n\nconfig readLine*\n```\n","primer":"extended (contextful) version of `readLine`.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[119,344],[120,344]],"outbound":[343]},{"name":"reportError","effect":"( Eo -- ):","markdown":"reports about an error to the standard error stream, given an Error object.\n\nYou can obtain an error object by, e.g., catching it in `__died__`.\n","primer":"reports about an error to the standard error stream, given an Error object.","takes":[[0,0]],"leaves":[],"erefs":[[121,345]],"outbound":[]},{"name":"monotonic","effect":"( -- R ):","markdown":"leaves a Reading from the monotonic clock to measure elapsed time, in milliseconds.\n\nValues from the monotonic clock and wall clock are not comparable. Monotonic clock should be independent from discontinuous jumps in the system time, such as leap seconds, time zone adjustments or manual changes to the computer's clock.\n\n```\nmonotonic $: start\n20 nap\nmonotonic $: end\nend start - echo\n\"STDOUT: 20\u23ce (approximately)\"\n```\n","primer":"leaves a Reading from the monotonic clock to measure elapsed time, in milliseconds.","takes":[],"leaves":[[0,0]],"erefs":[[122,346]],"outbound":[]},{"name":"nap","effect":"( D -- ):","markdown":"sleeps a Duration of time, given in *milliseconds*.\n","primer":"sleeps a Duration of time, given in *milliseconds*.","takes":[[0,0]],"leaves":[],"erefs":[[123,347]],"outbound":[]},{"name":"bye","effect":"( Ec -- ):","markdown":"ends the program with the given decimal Exit code.\n","primer":"ends the program with the given decimal Exit code.","takes":[[0,0]],"leaves":[],"erefs":[[124,348]],"outbound":[]},{"name":"rgb","effect":"( R G B -- Cf ):","markdown":"creates a Color form from three decimals Red (0-255), Green (0-255), and Blue (0-255).\n\n```\n36 255 255 rgb toQuote leaves: 'rgb(36, 255 ,255)'\n```'\n```\n","primer":"creates a Color form from three decimals Red (0-255), Green (0-255), and Blue (0-255).","takes":[[1,0],[2,0],[3,0]],"leaves":[[0,0]],"erefs":[[125,349],[126,349],[127,349],[128,349]],"outbound":[]},{"name":"getRGB","effect":"( Cf -- R G B ):","markdown":"leaves Red, Green, Blue values for a Color form.\n\n```\n0 25 3 rgb \"rgb(0, 25, 3)\" getRGB leaves: [ 0 25 3 ]\n```\n","primer":"leaves Red, Green, Blue values for a Color form.","takes":[[3,0]],"leaves":[[0,0],[1,0],[2,0]],"erefs":[[126,350],[127,350],[128,350],[125,350]],"outbound":[]},{"name":"hsl","effect":"( H S L -- Cf ):","markdown":"creates a Color form from three decimals Hue (0-360, degrees), Saturation (0-100, percents), Lightness (0-100, percents).\n\nSince color forms are stored in RGB, the HSL color is first converted into RGB.\n\n```\n206 35 46 hsl toQuote leaves: 'rgb(76, 123, 158)'\n```\n","primer":"creates a Color form from three decimals Hue (0-360, degrees), Saturation (0-100, percents), Lightness (0-100, percents).","takes":[[2,0],[0,0],[3,0]],"leaves":[[1,0]],"erefs":[[129,351],[125,351],[130,351],[131,351]],"outbound":[]},{"name":"getHSL","effect":"( Cf -- H S L ):","markdown":"leaves Hue, Saturation, Lightness for a Color form.\n\n```\n206 35 46 hsl \"rgb(76, 123, 158)\" getHSL leaves: [ 206 35 46 ]\n```\n","primer":"leaves Hue, Saturation, Lightness for a Color form.","takes":[[3,0]],"leaves":[[0,0],[1,0],[2,0]],"erefs":[[130,352],[129,352],[131,352],[125,352]],"outbound":[]},{"name":"hsv","effect":"( H S V -- Cf ):","markdown":"creates a Color form from three decimals Hue (0-360, degrees), Saturation (0-100, percents), Value (0-100, percents).\n\nSince color forms are stored in RGB, the HSV color is first converted into RGB.\n\n```\n120 100 100 hsv toQuote leaves: 'rgb(0, 255, 0)'\n```\n","primer":"creates a Color form from three decimals Hue (0-360, degrees), Saturation (0-100, percents), Value (0-100, percents).","takes":[[2,0],[0,0],[3,0]],"leaves":[[1,0]],"erefs":[[129,353],[125,353],[130,353],[132,353]],"outbound":[]},{"name":"getHSV","effect":"( Cf -- H S V ):","markdown":"leaves Hue, Saturation, Value for a Color form.\n\n```\n180 100 50 hsv \"rgb(0,128,128)\" getHSV leaves: [ 180 100 50 ]\n```\n","primer":"leaves Hue, Saturation, Value for a Color form.","takes":[[3,0]],"leaves":[[0,0],[1,0],[2,0]],"erefs":[[130,354],[129,354],[132,354],[125,354]],"outbound":[]},{"name":"lch","effect":"( L C H -- Cf ):","markdown":"creates a Color form from three decimals Lightness (0-100), Chroma (0-132), Hue (0-360).\n\nSince color forms are stored as RGB, the LCH color is first converted into RGB.\n\nLCH colors are tricky to implement but very fun to use. That's why they're in Novika's standard library.\n\nCIELAB encloses more colors than sRGB, so some conversion imprecisions *are* to be expected because some colors just fall out of sRGB gamut (lossiness is especially noticeable in LCH -> RGB -> LCH conversions, but it stabilizes on the last step because the last step's LCH is guraranteed to be inside the sRGB gamut).\n\nAny color out of the sRGB gamut is brought into the sRGB gamut by lowering chroma until it's in the sRGB bounds.\n\nHere is a 'good' conversion, meaning it nicely closes on itself:\n\n```\n78 74 133 lch $: color\n\ncolor toQuote leaves: 'rgb(122, 215, 85)'\ncolor getLCH leaves: [ 78 74 133 ]\ncolor getLCH lch toQuote leaves: 'rgb(122, 215, 85)''\n\"And so on...\"\n```\n\nAnd here is a bad conversion. At first, though, for it does stabilize after a few rounds as it falls firmly into the sRGB color space.\n\n```\n74 107 26 lch $: color\ncolor toQuote leaves: 'rgb(255, 154, 151)'\n\n\"Note how many chroma units we lose! Plus, Lab and\n LCH have hue shift on chroma changes, hence 26 -> 25.\"\ncolor getLCH leaves: [ 74 41 25 ]\n\ncolor getLCH lch toQuote leaves: 'rgb(255, 154, 152)'\n\ncolor getLCH lch getLCH leaves: [ 74 41 25 ]\n\"... and so on, conversion had stabilized ...\"\n```\n\nYou don't necessarily have to think about this, because the resulting colors do look very similar, differing in points rather than magnitudes. Just be aware that the conversion method used by this word and `getLCH` is lossy in some cases.\n","primer":"creates a Color form from three decimals Lightness (0-100), Chroma (0-132), Hue (0-360).","takes":[[2,0],[3,0],[0,0]],"leaves":[[1,0]],"erefs":[[130,355],[125,355],[131,355],[133,355]],"outbound":[356]},{"name":"getLCH","effect":"( Cf -- L C H ):","markdown":"leaves Lightness, Chroma, Hue for a Color form. Please read documentation for `lch` to understand why `a b c lch getLCH` might not leave `a b c`.\n\n```\n78 74 133 lch toQuote leaves: 'rgb(122, 215, 85)'\n78 74 133 lch getLCH leaves: [ 78 74 133 ]\n\n74 107 26 lch toQuote leaves: 'rgb(255, 154, 152)'\n\n\"Chroma lowered to fit into sRGB. Lab and LCH have hue\n shift on chroma changes, 26 -> 25\"\n74 107 26 lch getLCH leaves: [ 74 41 25 ]\n```\n","primer":"leaves Lightness, Chroma, Hue for a Color form.","takes":[[3,0]],"leaves":[[1,0],[2,0],[0,0]],"erefs":[[130,356],[131,356],[133,356],[125,356]],"outbound":[355]},{"name":"withAlpha","effect":"( Cf A -- Cf' ):","markdown":"leaves Color form with alpha channel set to Alpha (0-255).\n\n```\n0 25 3 rgb toQuote leaves: 'rgb(0, 25, 3)'\n0 25 3 rgb 100 withAlpha toQuote leaves: 'rgba(0, 25, 3, 100)'\n```\n","primer":"leaves Color form with alpha channel set to Alpha (0-255).","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[125,357],[134,357]],"outbound":[]},{"name":"getAlpha","effect":"( Cf -- A ):","markdown":"leaves Alpha for the given Color form.\n\n```\n0 25 3 rgb getAlpha leaves: 255 \"Opaque = 255\"\n0 25 3 rgb 100 withAlpha getAlpha leaves: 100\n```\n","primer":"leaves Alpha for the given Color form.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[134,358],[125,358]],"outbound":[]},{"name":"fromPalette","effect":"( Cf Pb -- Cc ):","markdown":"leaves the Closest color form to Color from a Palette block. How close the color is is determined by distance: the Closest color is that color in Palette block to which Color has least (minimum) distance.\n\n```\n[ 0 0 0 rgb\n  255 0 0 rgb\n  0 255 0 rgb\n  0 0 255 rgb\n  255 255 255 rgb\n] vals $: pal\n\n0 0 0 rgb pal fromPalette toQuote leaves: 'rgb(0, 0, 0)'\n76 175 80 rgb pal fromPalette \"greenish\" toQuote leaves: 'rgb(0, 255, 0)'\n220 237 200 rgb pal fromPalette \"very light green\" toQuote leaves: 'rgb(255, 255, 255)'\n74 20 140 rgb pal fromPalette \"very dark purple\" toQuote leaves: 'rgb(255, 0, 0)'\n```\n","primer":"leaves the Closest color form to Color from a Palette block.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[135,359],[136,359],[137,359]],"outbound":[]},{"name":"prototype","effect":"( B -- P ):","markdown":"leaves the Prototype of Block.\n","primer":"leaves the Prototype of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[138,360],[5,360]],"outbound":[]},{"name":"parent","effect":"( B -- P ):","markdown":"leaves the Parent of Block.\n","primer":"leaves the Parent of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[19,361],[5,361]],"outbound":[]},{"name":"address","effect":"( B -- A ):","markdown":"leaves pointer Address of Block.\n","primer":"leaves pointer Address of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[139,362],[5,362]],"outbound":[]},{"name":"conts","effect":"( -- Cb ):","markdown":"pushes the Continuations block.\n","primer":"pushes the Continuations block.","takes":[],"leaves":[[0,0]],"erefs":[[140,363]],"outbound":[]},{"name":"cont","effect":"( -- Cb ):","markdown":"pushes the Continuation block.\n","primer":"pushes the Continuation block.","takes":[],"leaves":[[0,0]],"erefs":[[141,364]],"outbound":[]},{"name":"newContinuation","effect":"( S B -- C ):","markdown":"creates a Continuation from a Stack and a Block.\n","primer":"creates a Continuation from a Stack and a Block.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[142,365],[7,365],[5,365]],"outbound":[]},{"name":"getContBlock","effect":"( C -- Cb ):","markdown":"leaves the Code block of a Continuation.\n","primer":"leaves the Code block of a Continuation.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[143,366],[142,366]],"outbound":[]},{"name":"getContStack","effect":"( C -- Sb ):","markdown":"leaves the Stack block of a Continuation.\n","primer":"leaves the Stack block of a Continuation.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[144,367],[142,367]],"outbound":[]},{"name":"this","effect":"( -- B ):","markdown":"pushes the Block it's opened in.\n\n```\n[ this ] open echo\n\"STDOUT: [ this ]\u23ce (instance of `[ this ]`)\"\n```\n","primer":"pushes the Block it's opened in.","takes":[],"leaves":[[0,0]],"erefs":[[5,368]],"outbound":[]},{"name":"stack","effect":"( -- S ):","markdown":"pushes the Stack it's opened in.\n\n```\nstack dup echo\n\"STDOUT: [ \u2b6e ]\u23ce\"\n\n'foo' <<\nstack echo\n\"STDOUT: [ \u2b6e 'foo' ]\u23ce\"\n```\n","primer":"pushes the Stack it's opened in.","takes":[],"leaves":[[0,0]],"erefs":[[7,369]],"outbound":[]},{"name":"ahead","effect":"( -- B ):","markdown":"leaves the block that will be executed after `this` finishes.\n\n```\n100 [ ahead 1 inject ] open + leaves: 101 \"(i.e. 100 1 +)\"\n```\n","primer":"leaves the block that will be executed after `this` finishes.","takes":[],"leaves":[[0,0]],"erefs":[[5,368]],"outbound":[368]},{"name":"resume","effect":"( B -- ):","markdown":"closes blocks all the way up to, but not including, Block.\n","primer":"closes blocks all the way up to, but not including, Block.","takes":[[0,0]],"leaves":[],"erefs":[[5,371]],"outbound":[]},{"name":"dup","effect":"( F -- F F ):","markdown":"duplicates the Form before cursor.\n\n```\n'hello' dup leaves: [ 'hello' 'hello' ]\n\n[ 1 2 | 3 ] $: block\nblock [ dup ] hydrate\nblock leaves: [ [ 1 2 2 | 3 ] ]\n```\n","primer":"duplicates the Form before cursor.","takes":[[0,0]],"leaves":[[0,0],[0,1]],"erefs":[[1,372]],"outbound":[]},{"name":"drop","effect":"( F -- ):","markdown":"drops the Form before cursor.\n\n```\n'hello' drop leaves: [ ]\n\n[ 1 2 | 3 ] $: block\nblock [ drop ] hydrate\nblock leaves: [ [ 1 | 3 ] ]\n```\n","primer":"drops the Form before cursor.","takes":[[0,0]],"leaves":[],"erefs":[[1,373]],"outbound":[]},{"name":"swap","effect":"( A B -- B A ):","markdown":"swaps two Forms before cursor.\n\n```\n1 2 swap leaves: [ 2 1 ]\n\n[ 1 2 | 3 ] $: block\nblock [ swap ] hydrate\nblock leaves: [ [ 2 1 | 3 ] ]\n```\n","primer":"swaps two Forms before cursor.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"hydrate","effect":"( S F -- ):","markdown":"opens (evaluates) Form with Stack set as the active stack. If Form is not a block, it is added to Stack (equivalent to `&lt;&lt;`), If Form is a block, its instance is opened. To open a block without creating an instance of it (unsafe), use `hydrate!`.\n","primer":"opens (evaluates) Form with Stack set as the active stack.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[1,375],[7,375]],"outbound":[376]},{"name":"hydrate!","effect":"( S F -- ):","markdown":"opens (evaluates) Form with Stack set as the active stack. If Form is not a block, the behavior is the same as in `hydrate`. If Form is a block, performs unsafe hydration (hydrates without making an instance of the block). For a safer alternative, see `hydrate`. Use if you know what you're doing, or if you're ready to make an instance yourself.\n\nDetails: `hydrate!` is considered unsafe because hydration artifacts are exposed to the user and/or its blocks. The contents of a block after hydration may differ from its contents before unsafe hydration. Indeed, `hydrate!` is almost as unsafe as pushing into `conts`; the only benefit it provides is that it is able to catch infinite/very deep recursion.\n","primer":"opens (evaluates) Form with Stack set as the active stack.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[1,376],[7,376]],"outbound":[363,375]},{"name":"open","effect":"( F -- F' ):","markdown":"opens Form in the active stack. Equivalent to `stack F hydrate`.\n\n```\n100 open leaves: 100\n\n1 [ 2 + ] open leaves: 3\n```\n","primer":"opens Form in the active stack.","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[1,377]],"outbound":[]},{"name":"there","effect":"( S B -- S ):","markdown":"opens Block with Stack set as the active stack. Leaves Stack. Ahead is transferred to block.\n\n```\n[ 1 2 ] [ + ] there leaves: [ [ 3 ] ]\n[ 1 2 ] [ ahead thruBlock open ] there + leaves: [ [ 3 ] ]\n```\n","primer":"opens Block with Stack set as the active stack.","takes":[[1,0],[0,0]],"leaves":[[1,0]],"erefs":[[5,378],[7,378]],"outbound":[]},{"name":"do","effect":"( F -- ):","markdown":"opens Form with an empty stack activated, and disposed when Form has been evaluated.\n\n```\n[ 'Hi!' echo ] do\n\"STDOUT: Hi!\u23ce\"\n```\n","primer":"opens Form with an empty stack activated, and disposed when Form has been evaluated.","takes":[[0,0]],"leaves":[],"erefs":[[1,379]],"outbound":[]},{"name":"new","effect":"( B -- I ):","markdown":"leaves an Instance of a Block.\n","primer":"leaves an Instance of a Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[33,380],[5,380]],"outbound":[]},{"name":"shallowNew","effect":"( B -- Si ):","markdown":"leaves a Shallow instance of Block.\n\n`shallowNew` is different from `new` in that it does not reparent sub-blocks to the parent instance recursively. Instead, it only creates an instance of Block, and does not look at skips its content entirely.\n\n```\n[ $: x [ x ] ] @: newBox\n\n1 newBox $: fooBox1\n2 newBox $: fooBox2\n3 newBox $: fooBox3\n\nfooBox1 open leaves: 1\nfooBox2 open leaves: 2\nfooBox3 open leaves: 3\n\n[ fooBox1 fooBox2 fooBox3 ] vals $: boxes\n\nboxes shallowNew $: shallowBoxesInstance\nshallowBoxesInstance 0 fromLeft open leaves: 1\nshallowBoxesInstance 1 fromLeft open leaves: 2\nshallowBoxesInstance 2 fromLeft open leaves: 3\n\n\"Works as expected! Note that sub-blocks are exactly the same as\n those in the original 'boxes' block. However, 'shallowBoxesInstance'\n and 'boxes' are different blocks now:\"\n\n(shallowBoxesInstance 0 fromLeft) (boxes 0 fromLeft) same? leaves: true\n(shallowBoxesInstance 1 fromLeft) (boxes 1 fromLeft) same? leaves: true\n(shallowBoxesInstance 2 fromLeft) (boxes 2 fromLeft) same? leaves: true\n\nboxes shallowBoxesInstance same? leaves: false\n\n\"... and 'shallowBoxesInstance' does indeed have 'boxes' as its parent:\"\n\n(shallowBoxesInstance parent) boxes same? leaves: true\n```\n","primer":"leaves a Shallow instance of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[145,381],[5,381]],"outbound":[380]},{"name":"sel","effect":"( D A B -- A/B ):","markdown":"selects A (Determiner is truthy) or B (Determiner is falsey)\n","primer":"selects A (Determiner is truthy) or B (Determiner is falsey)","takes":[[2,0],[0,0],[1,0]],"leaves":[[0,0],[1,0]],"erefs":[[30,382],[31,382],[65,382]],"outbound":[]},{"name":"br","effect":"( D T F -- ? ):","markdown":"opens True/False forms depending on Determiner being true/false.\n","primer":"opens True/False forms depending on Determiner being true/false.","takes":[[2,0],[0,0],[1,0]],"leaves":[],"erefs":[[66,383],[67,383],[65,383]],"outbound":[]},{"name":"<","effect":"( A B -- S ):","markdown":"leaves whether A is smaller than (less than) B.\n","primer":"leaves whether A is smaller than (less than) B.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[30,384],[31,384]],"outbound":[]},{"name":"same?","effect":"( F1 F2 -- true/false ):","markdown":"leaves whether two Forms are the same (by reference for block, by value for any other form).\n\n```\n1 2 same? leaves: false\n1 1 same? leaves: true\n\n'hello' 'hello world' same? leaves: false\n'hello' 'hello' same? leaves: true\n\n\"etc...\"\n\n[ 1 2 + ] $: b1\n[ 1 2 + ] $: b2\n\nb1 b2 same? leaves: false \"They're different blocks, content doesn't matter!\"\n\nb1 b1 same? leaves: true\nb2 b2 same? leaves: true\n```\n","primer":"leaves whether two Forms are the same (by reference for block, by value for any other form).","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"=","effect":"( F1 F2 -- true/false ):","markdown":"leaves whether two Forms are equal by content (they may or may not be the same forms reference-wise, i.e., those for which `same?` would leave true).\n\n```\n1 2 = leaves: false\n1 1 = leaves: true\n\n'hello' 'hello world' = leaves: false\n'hello' 'hello' = leaves: true\n\n\"etc...\"\n\n[ 1 2 + ] $: b1\n[ 1 2 + ] $: b2\n\nb1 b2 = leaves: true \"They're equal by content!\"\n\nb1 b1 = leaves: true\nb2 b2 = leaves: true\n\n\"Supports self-reference:\"\n[ ] $: b3\nb3 b3 shove\nb3 b3 = leaves: true\n(b3 first) b3 = leaves: true\n\"etc...\"\n```\n","primer":"leaves whether two Forms are equal by content (they may or may not be the same forms reference-wise, i.e., those for which `same?` would leave true).","takes":[],"leaves":[],"erefs":[],"outbound":[385]},{"name":"anyof?","effect":"( F B -- true/false ):","markdown":"leaves whether any form in Block is equal (via `=`) to Form.\n\n```\n1 [ 1 2 3 ] anyof? leaves: true\n'hello' [ 'hello' 'world' 1 ] anyof? leaves: true\n'hello' [ 1 2 3 ] anyof? leaves: false\n```\n","primer":"leaves whether any form in Block is equal (via `=`) to Form.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[5,387],[1,387]],"outbound":[386]},{"name":"occurrences","effect":"( B/Q Pf/Pq -- Bi ):","markdown":"leaves Begin indices of all occurrences of Pattern form/Pattern quote in Block/Quote. Begin indices is an orphan with no entries.\n\nWorks in a similar way to `anyof?` in that it compares each element of the Block/Quote with Pattern form/Pattern quote like `=` (but not using `=`, at least in the quote case where KMP is used).\n\n```\n[ ] 123 occurrences leaves: [ [ ] ]\n\n[ 1 1 2 0 0 1 2 1 3 4 8 ] $: haystack\nhaystack 0 occurrences leaves: [ [ 3 4 ] ]\nhaystack 1 occurrences leaves: [ [ 0 1 5 7 ] ]\nhaystack 'foo' occurrences leaves: [ [ ] ]\n\n'' 'foobar' occurrences leaves: [ [ ] ]\n'foobar' '' occurrences leaves: [ [ ] ]\n\n'foobra' $: haystack\nhaystack 'o' occurrences leaves: [ [ 1 2 ] ]\nhaystack 'foo' occurrences leaves: [ [ 0 ] ]\nhaystack 'ra' occurrences leaves: [ [ 4 ] ]\n\n'GATCCATATG' $: haystack\nhaystack 'ATAAT' occurrences leaves: [ [ ] ]\nhaystack 'ATAT' occurrences leaves: [ [ 5 ] ]\n```\n","primer":"leaves Begin indices of all occurrences of Pattern form/Pattern quote in Block/Quote.","takes":[[3,0],[4,0],[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[146,388],[147,388],[148,388],[5,388],[12,388]],"outbound":[387,386]},{"name":"uppercase?","effect":"( Q -- true/false ):","markdown":"leaves whether Quote is all-uppercase. If Quote is empty, leaves false.\n\n```\n'' uppercase? leaves: false\n'A' uppercase? leaves: true\n'hello' uppercase? leaves: false\n'Hello' uppercase? leaves: false\n'HELLO' uppercase? leaves: true\n'HELLO WORLD' uppercase? leaves: false\n```\n","primer":"leaves whether Quote is all-uppercase.","takes":[[0,0]],"leaves":[],"erefs":[[12,389]],"outbound":[]},{"name":"toUppercase","effect":"( Q -- Uq ):","markdown":"leaves all- Uppercase quote for Quote: converts lowercase character(s) in Quote to uppercase. If Quote is empty, leaves empty quote.\n\n```\n'' toUppercase leaves: ''\n'hello' toUppercase leaves: 'HELLO'\n'hello world' toUppercase? leaves: 'HELLO WORLD'\n```\n","primer":"leaves all- Uppercase quote for Quote: converts lowercase character(s) in Quote to uppercase.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[149,390],[12,390]],"outbound":[]},{"name":"block?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a block.\n","primer":"leaves whether Form is a block.","takes":[[0,0]],"leaves":[],"erefs":[[1,391]],"outbound":[]},{"name":"asBlock","effect":"( F -- B ):","markdown":"asserts that Form is a Block, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asBlock\n```\n\nEt cetera for all other forms, except:\n\n```\n[] asBlock leaves: [ [] \"(the same block)\" ]\n```\n","primer":"asserts that Form is a Block, dies if it's not.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[1,392],[5,392]],"outbound":[]},{"name":"word?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a word form, or a block that implements '**word**'.\n\n```\n#foo word? leaves: true\n\n[ #foo $: __word__ this ] open word? leaves: true\n```\n","primer":"leaves whether Form is a word form, or a block that implements '**word**'.","takes":[[0,0]],"leaves":[],"erefs":[[1,393]],"outbound":[]},{"name":"private?","effect":"( W -- true/false ):","markdown":"leaves whether Word is private (by convention).\n\nA Word prefixed by one or more underscores '_' *but that which does not end with one(s)* is considered private by convention. Hook words such as `__quote__` are *not* considered private.\n\nThe fact that privacy is defined \"by convention\" means that nothing actually stops anyone from obtaining the word's associated value form.\n\n```\n#hello private? leaves: false\n#_hello private? leaves: true\n#_ private? leaves: false \"Beware!\"\n```\n","primer":"leaves whether Word is private (by convention).","takes":[[0,0]],"leaves":[],"erefs":[[64,394]],"outbound":[]},{"name":"toWord","effect":"( F -- W ):","markdown":"converts Form into Word.\n\n1. If Form is a word, behaves as noop\n2. If Form is a quote, dies only if quote contains Unicode whitespace characters or is itself empty.\n3. If Form is a quoted word, peels off **all** quoting\n","primer":"converts Form into Word.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[64,395],[1,395]],"outbound":[]},{"name":"asWord","effect":"( F -- W ):","markdown":"asserts that Form is a Word form, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asWord\n```\n\nEt cetera for all other forms, except:\n\n```\n#foo asWord leaves: [ foo ]\n```\n\n`__word__` hook can make a block usable in place of a word, provided its definition leaves a word or a block which implements '**word**':\n\n```\n[ $: x x $: __word__ this ] @: a\n#foo a asWord \"beware: leaves instance of a\"\n#boo a a asWord \"beware: leaves instance of a\"\n```\n","primer":"asserts that Form is a Word form, dies if it's not.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[1,396],[64,396]],"outbound":[]},{"name":"quotedWord?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a quoted word form, or a block that implements '**quotedWord**'.\n\n```\n##foo quotedWord? leaves: true\n[ ##foo $: __quotedWord__ this ] open quotedWord? leaves: true\n```\n","primer":"leaves whether Form is a quoted word form, or a block that implements '**quotedWord**'.","takes":[[0,0]],"leaves":[],"erefs":[[1,397]],"outbound":[]},{"name":"asQuotedWord","effect":"( F -- Qw ):","markdown":"asserts that Form is a Quoted word form, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asQuotedWord\n```\n\nEt cetera for all other forms, except:\n\n```\n##foo asQuotedWord leaves: #foo\n```\n\n`__quotedWord__` hook can make a block usable in place of a quoted word, provided its definition leaves a quoted word or a block that implements `__quotedWord__`:\n\n```\n[ $: x x $: __quotedWord__ this ] @: a\n##foo a asQuotedWord \"beware: leaves instance of a\"\n##boo a a asQuotedWord \"beware: leaves instance of a\"\n```\n","primer":"asserts that Form is a Quoted word form, dies if it's not.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[150,398],[1,398]],"outbound":[]},{"name":"decimal?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a decimal form, or a block that implements '**decimal**'.\n\n```\n123 decimal? leaves: true\n[ 123 $: __decimal__ this ] open decimal? leaves: true\n```\n","primer":"leaves whether Form is a decimal form, or a block that implements '**decimal**'.","takes":[[0,0]],"leaves":[],"erefs":[[1,399]],"outbound":[]},{"name":"toQuotedWord","effect":"( Qw/W -- #Qw/#W ):","markdown":"adds a layer of \"quoting\" to Quoted word or Word.\n\n```\n\"Note that in quoted word literals (here on the left hand\n side) one layer of quoting is 'eaten off' by the parser!\"\n\n#foo toQuotedWord leaves: #foo\n##foo toQuotedWord leaves: ##foo\n```\n","primer":"adds a layer of \"quoting\" to Quoted word or Word.","takes":[[0,0],[1,0]],"leaves":[[0,0],[1,0]],"erefs":[[150,400],[64,400]],"outbound":[]},{"name":"asDecimal","effect":"( F -- D ):","markdown":"asserts that Form is a Decimal form, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n'foo' asDecimal\n```\n\nEt cetera for all other forms, except:\n\n```\n100 asDecimal leaves: 100\n```\n\n`__decimal__` hook can make a block usable in place of a decimal, provided its definition leaves a decimal or a block that implements `__decimal__`:\n\n```\n[ $: x x $: __decimal__ this ] @: a\n100 a asDecimal \"beware: leaves an instance of a\"\n200 a a asDecimal \"beware: leaves an instance of a\"\n```\n","primer":"asserts that Form is a Decimal form, dies if it's not.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[83,401],[1,401]],"outbound":[]},{"name":"quote?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a quote form, or a block that implements '**quote**'.\n\n```\n'foo' quote? leaves: true\n[ 'foo' $: __quote__ this ] open quote? leaves: true\n```\n","primer":"leaves whether Form is a quote form, or a block that implements '**quote**'.","takes":[[0,0]],"leaves":[],"erefs":[[1,402]],"outbound":[]},{"name":"asQuote","effect":"( F -- Q ):","markdown":"asserts that Form is a Quote form, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asQuote\n```\n\nEt cetera for all other forms, except:\n\n```\n'foo' asQuote leaves: 'foo'\n```\n\n`__quote__` hook can make a block usable in place of a quote, provided its definition leaves a quote or a block that implements `__quote__`:\n\n```\n[ $: x x $: __quote__ this ] @: a\n'foo' a asQuote \"beware: leaves instance of a\"\n'boo' a a asQuote \"beware: leaves instance of a\"\n```\n","primer":"asserts that Form is a Quote form, dies if it's not.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[12,403],[1,403]],"outbound":[]},{"name":"boolean?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a boolean form, or a block that implements '**boolean**'.\n\n```\ntrue boolean? leaves: true\n[ true $: __boolean__ this ] open boolean? leaves: true\n```\n","primer":"leaves whether Form is a boolean form, or a block that implements '**boolean**'.","takes":[[0,0]],"leaves":[],"erefs":[[1,404]],"outbound":[]},{"name":"asBoolean","effect":"( F -- B ):","markdown":"asserts that Form is a Boolean form, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asBoolean\n```\n\nEt cetera for all other forms, except:\n\n```\ntrue asBoolean leaves: true\nfalse asBoolean leaves: false\n```\n\n`__boolean__` hook can make a block usable in place of a boolean, provided its definition leaves a boolean or a block that implements `__boolean__`:\n\n```\n[ $: x x $: __boolean__ this ] @: a\ntrue a asBoolean \"beware: leaves an instance of a\"\ntrue a a asBoolean \"beware: leaves an instance of a\"\n```\n","primer":"asserts that Form is a Boolean form, dies if it's not.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[96,405],[1,405]],"outbound":[]},{"name":"builtin?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a builtin form.\n","primer":"leaves whether Form is a builtin form.","takes":[[0,0]],"leaves":[],"erefs":[[1,406]],"outbound":[]},{"name":"asBuiltin","effect":"( F -- B ):","markdown":"asserts Form is a Builtin, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n'foo' asBuiltin\n```\n\nEt cetera for all other forms, except:\n\n```\n#+ here asBuiltin toQuote leaves: '[ native code ]'\n```\n","primer":"asserts Form is a Builtin, dies if it's not.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[1,407],[151,407]],"outbound":[]},{"name":"color?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a color form, or a block that implements '**color**'.\n\n```\n0 0 0 rgb color? leaves: true\n[ 0 0 0 rgb $: __color__ this ] open color? leaves: true\n```\n","primer":"leaves whether Form is a color form, or a block that implements '**color**'.","takes":[[0,0]],"leaves":[],"erefs":[[1,408]],"outbound":[]},{"name":"asColor","effect":"( F -- C ):","markdown":"asserts that Form is a Color form, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asColor\n```\n\nEt cetera for all other forms, except:\n\n```\n0 0 0 rgb asColor toQuote leaves: 'rgb(0, 0, 0)'\n```\n\n`__color__` hook can make a block usable in place of a color, provided its definition leaves a color or a block that implements `__color__`:\n\n```\n[ $: x x $: __color__ this ] @: a\n0 0 0 rgb a asColor \"beware: leaves an instance of a\"\n0 0 0 rgb a a asColor \"beware: leaves an instance of a\"\n```\n","primer":"asserts that Form is a Color form, dies if it's not.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[1,409],[117,409]],"outbound":[]},{"name":"byteslice?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a byteslice form, or a block that implements '**byteslice**'.\n\n```\n'hello world' toByteslice byteslice? leaves: true\n[ [ 'Hi!' toByteslice ] $: __byteslice__ this ] open byteslice? leaves: true\n```\n","primer":"leaves whether Form is a byteslice form, or a block that implements '**byteslice**'.","takes":[[0,0]],"leaves":[],"erefs":[[1,410]],"outbound":[]},{"name":"asByteslice","effect":"( F -- B ):","markdown":"asserts that Form is a Byteslice form, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asByteslice\n```\n\nEt cetera for all other forms, except:\n\n```\n'hello world' toByteslice asByteslice leaves: '[byteslice, consists of 11 mutable byte(s)]'\n```\n\n`__byteslice__` hook can make a block usable in place of a byteslice, provided its definition leaves a byteslice or a block that implements `__byteslice__`:\n\n```\n[ $: x x $: __byteslice__ this ] @: a\n'foo' toByteslice a asByteslice \"beware: leaves an instance of a\"\n'foo' toByteslice a a asByteslice \"beware: leaves an instance of a\"\n```\n","primer":"asserts that Form is a Byteslice form, dies if it's not.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[1,411],[152,411]],"outbound":[]},{"name":"pushes","effect":"( B N F -- ):","markdown":"creates a definition for Name in Block that pushes Form when resolved there.\n","primer":"creates a definition for Name in Block that pushes Form when resolved there.","takes":[[1,0],[0,0],[2,0]],"leaves":[],"erefs":[[0,412],[5,412],[1,412]],"outbound":[]},{"name":"opens","effect":"( B N F -- ):","markdown":"creates a definition for Name in Block that opens Form when resolved there.\n","primer":"creates a definition for Name in Block that opens Form when resolved there.","takes":[[1,0],[0,0],[2,0]],"leaves":[],"erefs":[[0,413],[5,413],[1,413]],"outbound":[]},{"name":"entry:submit","effect":"( Ss N F -- ):","markdown":"replaces the value form of an existing definition for Name in Submittable store (usually a block) to Form. Does not change whether the definition opens or pushes.\n\n```\n[ 'John Doe' $: fullName\n  [ fullName count ] @: fullNameLength\n] obj $: person\n\nperson.fullName leaves: 'John Doe'\nperson.fullNameLength leaves: 8\n\n\"Let's try to change the name:\"\nperson #fullName 'Alice Bobette' entry:submit\nperson.fullName leaves: 'Alice Bobette'\nperson.fullNameLength leaves: 13\n\n\"Now let's change the way we compute the length; let's count\n how many double-Ts there are in the full name.\"\nperson #fullNameLength [ person.fullName 'tt' occurrences count ] entry:submit\n\n\"... just one:\"\nperson.fullNameLength leaves: 1\n\n\"... or maybe multiple:\"\nperson #fullName 'Tette Mopettitte' entry:submit\nperson.fullName leaves: 'Tette Mopettitte'\nperson.fullNameLength leaves: 3\n```\n","primer":"replaces the value form of an existing definition for Name in Submittable store (usually a block) to Form.","takes":[[0,0],[1,0],[2,0]],"leaves":[],"erefs":[[153,414],[0,414],[1,414]],"outbound":[]},{"name":"entry:exists?","effect":"( Rs N -- true/false ):","markdown":"leaves whether Readable store (usually a block) can fetch value for Name.\n\n```\n[ orphan $: table\n  orphan extendWith: [\n    [ ${ name age score }\n      [ name $: name\n        age  $: age ] obj toDict $: record\n      table record score pushes\n    ] @: set\n    [ ${ name age } table (this toDict) entry:fetch ] @: get\n    [ ${ name age } table (this toDict) entry:exists? ] @: has?\n    [ table entry:names map: [ $: record\n        [\n          record.name (31 ' ' lpad) (31 '...' fit)\n          record.age toQuote (15 ' ' lpad) (15 '...' fit)\n          (table record entry:fetch) toQuote (16 ' ' lpad) (16 '...' fit)\n        ] vals sepBy: ' |'\n      ] sepBy: '\n'\n    ] @: __quote__\n  ]\n] @: newScoreboard\n\nnewScoreboard $: scoreboard\n\n'John Doe' 42 '100 points' scoreboard.set\n'Johnanna Doe' 28 '170 points' scoreboard.set\n'Alice H.' 19 '250 points' scoreboard.set\n'David A.' 67 '90 points' scoreboard.set\n\nscoreboard echo\n\n\"\"\"STDOUT:\n                 John Doe |             42 |      100 points\u23ce\n             Johnanna Doe |             28 |      170 points\u23ce\n                 Alice H. |             19 |      250 points\u23ce\n                 David A. |             67 |       90 points\u23ce\n\"\"\"\n\n'John Doe' 42 scoreboard.get leaves: '100 points'\n'Alice H.' 19 scoreboard.get leaves: '250 points'\n\n'David A.' 67 scoreboard.has? leaves: true\n'David A.' 123 scoreboard.has? leaves: false\n'Peter Peterson' 19 scoreboard.has? leaves: false\n```\n","primer":"leaves whether Readable store (usually a block) can fetch value for Name.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[154,415],[0,415]],"outbound":[]},{"name":"entry:fetch","effect":"( Rs N -- F ):","markdown":"leaves the value Form with the given Name in Readable store (usually a block). Does not open the value form. Dies if Store does not contain an entry for Name.\n\n```\n[ 100 $: x 200 $: y ] obj $: a\n\na #x entry:fetch leaves: 100\na #y entry:fetch leaves: 200\na #a entry:fetch leaves: a \"via inheritance\"\n```\n","primer":"leaves the value Form with the given Name in Readable store (usually a block).","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[154,416],[1,416],[0,416]],"outbound":[]},{"name":"entry:fetch?","effect":"( Rs N -- F true / false ):","markdown":"leaves value Form of the entry with the given Name in Readable store (usually a block), follows it with `true`. If there is no entry with the given name leaves `false` only. Does not open the value form.\n\n```\n[ 100 $: x ] obj toOrphan $: a\n\na #x entry:fetch? leaves: [ 100 true ]\na #y entry:fetch? leaves: false\n\na ('Enter name> ' readLine not => okbye toWord) entry:fetch? br:\n  [ 'Here is its value: ' _ ~ ]\n  'Entry does not exist :('\necho\n```\n","primer":"leaves value Form of the entry with the given Name in Readable store (usually a block), follows it with `true`.","takes":[[0,0],[2,0]],"leaves":[[1,0]],"erefs":[[154,417],[1,417],[0,417]],"outbound":[]},{"name":"entry:open","effect":"( Rs C N -- ... ):","markdown":"resolves Name in Readable store and *opens* it if it is an opener, assuming Caller to be the opener block.\n","primer":"resolves Name in Readable store and *opens* it if it is an opener, assuming Caller to be the opener block.","takes":[[1,0],[2,0],[0,0]],"leaves":[],"erefs":[[0,418],[154,418],[155,418]],"outbound":[]},{"name":"entry:flatFetch?","effect":"( B N -- F true / false ):","markdown":"leaves the value Form of the entry with the given Name in Block's dictionary. Follows it by `true` if it exists. Leaves only `false` if there is no such entry in Block. Block hierarchy (friends, parents) is not traversed. This word only looks at Block's own dictionary). Does not open the value Form.\n\n```\n[ 100 $: x 200 $: y ] obj $: myParent\n[ 'hello' $: x ] obj $: myChild\n\n(myParent -- myChild) drop\n\nmyParent #x entry:flatFetch? leaves: [ 100 true ]\nmyParent #y entry:flatFetch? leaves: [ 200 true ]\nmyChild #foobar entry:flatFetch? leaves: false\n\nmyChild #x entry:flatFetch? leaves: [ 'hello' true ]\nmyChild #foobar entry:flatFetch? leaves: false\n\n\"Even though myChild is a child of myParent and has access to 'y',\n `entry:flatFetch?` doesn't care.\"\nmyChild #y entry:flatFetch? leaves: false \"doesn't inherit!\"\n\n\"Compare it with `entry:fetch?`:\"\nmyChild #y entry:fetch? leaves: [ 200 true ]\n```\n","primer":"leaves the value Form of the entry with the given Name in Block's dictionary.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[1,419],[0,419],[5,419]],"outbound":[]},{"name":"entry:opener?","effect":"( Rs N -- true/false ):","markdown":"leaves whether an entry with the given Name is an opener entry in Readable store (usually a block). Dies if Readable store has no entry with the given Name.\n\n```\n[ 100 $: x ] obj toOrphan $: foo\n\nfoo #x entry:opener? leaves: false\nfoo.x leaves: 100\n\n\"Change not only the value form for 'x' but also its type: make\n it an opener.\"\nfoo extend: [ [ 1 2 + ] @: x ]\n\nfoo #x entry:opener? leaves: true\nfoo.x leaves: 3\n```\n","primer":"leaves whether an entry with the given Name is an opener entry in Readable store (usually a block).","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[154,420],[0,420]],"outbound":[]},{"name":"entry:delete","effect":"( B N -- ):","markdown":"removes the entry corresponding to Name form from the dictionary of Block if it exists there. Otherwise, does nothing.\n\n```\n100 $: x\n\n[ 200 $: x ] obj $: foo\n\n\"'x' of foo shadows 'x' of toplevel block\"\nfoo.x leaves: 200\n\n\"Let's try to remove it so it doesn't:\"\nfoo #x entry:delete\nfoo.x leaves: 100\n```\n","primer":"removes the entry corresponding to Name form from the dictionary of Block if it exists there.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[0,421],[5,421]],"outbound":[]},{"name":"entry:wipeout","effect":"( B -- ):","markdown":"removes all *owned* dictionary entries in Block.\n\n```\n[ 100 $: x\n  200 $: y\n] obj $: numbers\n\nnumbers entry:names leaves: [ [x y] ]\n\nnumbers entry:wipeout\nnumbers entry:names leaves: [ [] ]\n```\n","primer":"removes all *owned* dictionary entries in Block.","takes":[[0,0]],"leaves":[],"erefs":[[5,422]],"outbound":[]},{"name":"entry:pathTo?","effect":"( B N -- P F true / false ):","markdown":"leaves Path, a block describing the path to Form (including Block itself) under the corresponding Name (like `entry:fetch?`). Follows Path and Form with `true` indicating success, otherwise *only* `false` indicating that there is no Form corresponding to Name in Block or any of the blocks reachable from Block.\n\nThis word exists mainly for testing word lookup sanity. Feel free to use it if you find any reason to!\n\n```\n[ 100 $: x  'a' $: __quote__ ] obj $: a\n[ 200 $: y  'b' $: __quote__ ] obj $: b\n[ 300 $: z  'c' $: __quote__ ] obj $: c\n\na -- b -- c drop\n\n[ a #x entry:pathTo? ] vals sepBy: ' ' leaves: '[ a ] 100 true'\n[ b #x entry:pathTo? ] vals sepBy: ' ' leaves: '[ b a ] 100 true'\n[ c #x entry:pathTo? ] vals sepBy: ' ' leaves: '[ c b a ] 100 true'\n\n[ b #y entry:pathTo? ] vals sepBy: ' ' leaves: '[ b ] 200 true'\n[ c #y entry:pathTo? ] vals sepBy: ' ' leaves: '[ c b ] 200 true'\n\n[ c #z entry:pathTo? ] vals sepBy: ' ' leaves: '[ c ] 300 true'\n\n[ c #foo entry:pathTo? ] vals sepBy: ' ' leaves: 'false'\n```\n","primer":"leaves Path, a block describing the path to Form (including Block itself) under the corresponding Name (like `entry:fetch?`).","takes":[[3,0],[2,0]],"leaves":[[1,0],[0,0]],"erefs":[[1,423],[156,423],[0,423],[5,423]],"outbound":[417]},{"name":"entry:names","effect":"( B -- Nb ):","markdown":"gathers all *owned* dictionary entry names of Block into Name block.\n\n```\n[ 100 200 ${ x y } ] obj $: myParent\n[ 300 $: z ] obj $: myChild\n[ 'Hello World' $: greeting ] obj $: myFriend\n\nmyParent -- myChild drop\nmyParent \u00b7> myFriend drop\nmyChild \u00b7> myFriend drop \"for good measure :)\"\n\nmyParent entry:names leaves: [ [y x] ]\nmyChild entry:names leaves: [ [z] ]\nmyFriend entry:names leaves: [ [greeting] ]\n```\n","primer":"gathers all *owned* dictionary entry names of Block into Name block.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[5,424],[157,424]],"outbound":[]},{"name":"entry:names*","effect":"( B -- Nb ):","markdown":"gathers all dictionary entry names *reachable* from Block to Name block. That is, gathers all entry names in Block, Block's parents, Block's friends, and so on. Explores the entire relative graph of Block.\n\nOrder is not guaranteed, and mainly depends on the appearance of Block's relative graph.\n\n```\n[ 100 200 ${ x y } ] obj toOrphan $: myParent\n[ 300 $: z ] obj toOrphan $: myChild\n[ 'Hello World' $: greeting ] obj toOrphan $: myFriend\n\nmyParent -- myChild drop\nmyParent \u00b7> myFriend drop\nmyChild \u00b7> myFriend drop\n\nmyParent entry:names* leaves: [ [y x greeting] ]\nmyChild entry:names* leaves: [ [z y x greeting] ]\nmyFriend entry:names* leaves: [ [greeting] ]\n```\n","primer":"gathers all dictionary entry names *reachable* from Block to Name block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[157,425],[5,425]],"outbound":[]},{"name":"entry:values","effect":"( B -- Vb ):","markdown":"gathers all *owned* dictionary entry value forms of Block into Value block.\n\n```\n[ 100 200 ${ x y } ] obj $: myParent\n[ 300 $: z ] obj $: myChild\n[ 'Hello World' $: greeting ] obj $: myFriend\n\nmyParent -- myChild drop\nmyParent \u00b7> myFriend drop\nmyChild \u00b7> myFriend drop\n\nmyParent entry:values leaves: [ [200 100] ]\nmyChild entry:values leaves: [ [300] ]\nmyFriend entry:values leaves: [ ['Hello World'] ]\n```\n","primer":"gathers all *owned* dictionary entry value forms of Block into Value block.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[5,426],[158,426]],"outbound":[]},{"name":"entry:values*","effect":"( B -- Nb ):","markdown":"gathers all dictionary entry values *reachable* from Block to Name block. That is, gathers all entry values in Block, Block's parents, Block's friends, and so on. Explores the entire relative graph of Block.\n\nOrder is not guaranteed, and mainly depends on the appearance of Block's relative graph. Values may repeat if some blocks in this graph define entries with the same name.\n\n```\n[ 100 200 ${ x y } ] obj toOrphan $: myParent\n[ 300 $: z ] obj toOrphan $: myChild\n[ 'Hello World' $: greeting ] obj toOrphan $: myFriend\n\nmyParent -- myChild drop\nmyParent \u00b7> myFriend drop\nmyChild \u00b7> myFriend drop\n\nmyParent entry:values* leaves: [ [200 100 'Hello World'] ]\nmyChild entry:values* leaves: [ [300 200 100 'Hello World'] ]\nmyFriend entry:values* leaves: [ ['Hello World'] ]\n```\n","primer":"gathers all dictionary entry values *reachable* from Block to Name block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[157,427],[5,427]],"outbound":[]},{"name":"entry:count","effect":"( B -- Ec ):","markdown":"leaves Entry count, that is, the amount of entries owned by (defined in) Block.\n\n```\n[ 100 200 ${ x y } ] obj $: myBlock\n\nmyBlock entry:count leaves: 2 \"'x' and 'y'\"\n```\n","primer":"leaves Entry count, that is, the amount of entries owned by (defined in) Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[159,428],[5,428]],"outbound":[]},{"name":"shallowCopy","effect":"( B -- C ):","markdown":"makes a shallow copy (sub-blocks are not copied) of Block's tape and dictionary, and leaves a Copy block with the tape copy, dictionary copy set as its tape, dictionary.\n\n```\n[ 1 2 3 ] $: a\na shallowCopy $: b\na #x 0 pushes\nb #y 1 pushes\nb 1 shove\na b 2echo\n\"STDOUT: [ 1 2 3 \u00b7 ${x :: 0} ]\u23ce\"\n\"STDOUT: [ 1 2 3 1 \u00b7 ${y :: 1} ]\u23ce\"\n```\n","primer":"makes a shallow copy (sub-blocks are not copied) of Block's tape and dictionary, and leaves a Copy block with the tape copy, dictionary copy set as its tape, dictionary.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[5,429],[160,429]],"outbound":[]},{"name":"resub","effect":"( O B -- ):","markdown":"replaces the substrate of Block with Other's substrate. This is useful if you want to swap Block's contents with Other's without changing Block's identity:\n\n```\n[ 1 2 3 ] $: a\n[ 'a' 'b' 'c' ] $: b\nb #x 0 pushes\nb echo\n\"STDOUT: [ 'a' 'b' 'c' \u00b7 ${x :: 0} ]\u23ce\"\n\na b resub\nb echo\n\"STDOUT: [ 1 2 3 \u00b7 ${x :: 0} ]\u23ce\"\n```\n\nNote that since *substrate* is replaced, not *tape*, the cursor position is saved:\n\n```\na b 2echo\n\"STDOUT: [ 1 2 3 ]\u23ce\"\n\"STDOUT: [ 'a' 'b' 'c' \u00b7 ${x :: 0} ]\u23ce\"\n\nb 2 |-\na b 2echo\n\"STDOUT: [ 1 2 3 ]\u23ce\"\n\"STDOUT: [ 'a' | 'b' 'c' \u00b7 ${x :: 0} ]\u23ce\"\n\na b resub\nb echo\n\"STDOUT: [ 1 | 2 3 \u00b7 ${x :: 0} ]\u23ce\"\n```\n","primer":"replaces the substrate of Block with Other's substrate.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[161,430],[5,430]],"outbound":[]},{"name":"fromLeft","effect":"( B/Q/Bf I -- E ):","markdown":"leaves Index-th Element from the left in Block, Quote, or Byteslice form.\n\n```\n[ 1 2 3 ] 0 fromLeft leaves: 1\n```\n","primer":"leaves Index-th Element from the left in Block, Quote, or Byteslice form.","takes":[[1,0],[2,0],[3,0]],"leaves":[[0,0]],"erefs":[[162,431],[5,431],[12,431],[163,431]],"outbound":[]},{"name":"fromRight","effect":"( B/Q/Bf I -- E ):","markdown":"leaves Index-th Element from the right in Block, Quote, or Byteslice form.\n\n```\n[ 1 2 3 ] 0 fromRight leaves: 3\n[ 1 2 3 ] 1 fromRight leaves: 2\n[ 1 2 3 ] 2 fromRight leaves: 1\n```\n","primer":"leaves Index-th Element from the right in Block, Quote, or Byteslice form.","takes":[[1,0],[2,0],[3,0]],"leaves":[[0,0]],"erefs":[[162,432],[5,432],[12,432],[163,432]],"outbound":[]},{"name":"fromLeft*","effect":"( B/Q/Bf N -- Eb/Rq/Rbf ):","markdown":"leaves Elements block (if given a Block), Result quote (if given a Quote), or Result byteslice form (if given a Byteslice form) with N forms/ chars/bytes from left in Block/Quote/Byteslice form. If N is larger than Block/Quote/Byteslice form count, it is made equal to Block/Quote/Byteslice form count. Dies if N is negative.\n\n```\n[ 1 2 3 ] 1 fromLeft* leaves: [ [ 1 ] ]\n[ 1 2 3 ] 2 fromLeft* leaves: [ [ 1 2 ] ]\n[ 1 2 3 ] 3 fromLeft* leaves: [ [ 1 2 3 ] ]\n[ 1 2 3 ] 100 fromLeft* leaves: [ [ 1 2 3 ] ]\n'hello' 3 fromLeft* leaves: 'hel'\n```\n","primer":"leaves Elements block (if given a Block), Result quote (if given a Quote), or Result byteslice form (if given a Byteslice form) with N forms/ chars/bytes from left in Block/Quote/Byteslice form.","takes":[[4,0],[5,0],[6,0],[3,0]],"leaves":[[0,0],[1,0],[2,0]],"erefs":[[164,433],[165,433],[166,433],[6,433],[5,433],[12,433],[163,433]],"outbound":[]},{"name":"fromRight*","effect":"( B/Q/Bf N -- Fb/Rq/Rbf ):","markdown":"leaves Elements block (if given a Block), Result quote (if given a Quote), or Result byteslice form (if given a Byteslice form) with N forms/ chars/bytes from right in Block/Quote/Byteslice form. If N is larger than Block/Quote/Byteslice form count, it is made equal to Block/Quote/Byteslice form count. Dies if N is negative.\n\n```\n[ 1 2 3 ] 1 fromRight* leaves: [ [ 3 ] ]\n[ 1 2 3 ] 2 fromRight* leaves: [ [ 2 3 ] ]\n[ 1 2 3 ] 3 fromRight* leaves: [ [ 1 2 3 ] ]\n[ 1 2 3 ] 100 fromRight* leaves: [ [ 1 2 3 ] ]\n```\n","primer":"leaves Elements block (if given a Block), Result quote (if given a Quote), or Result byteslice form (if given a Byteslice form) with N forms/ chars/bytes from right in Block/Quote/Byteslice form.","takes":[[3,0],[4,0],[5,0],[2,0]],"leaves":[[0,0],[1,0]],"erefs":[[165,434],[166,434],[6,434],[5,434],[12,434],[163,434]],"outbound":[]},{"name":"+","effect":"( A B -- S ):","markdown":"leaves the Sum of two decimals.\n","primer":"leaves the Sum of two decimals.","takes":[],"leaves":[[0,0]],"erefs":[[167,435]],"outbound":[]},{"name":"-","effect":"( A B -- D ):","markdown":"leaves the Difference of two decimals.\n","primer":"leaves the Difference of two decimals.","takes":[],"leaves":[[0,0]],"erefs":[[168,436]],"outbound":[]},{"name":"*","effect":"( A B -- P ):","markdown":"leaves the Product of two decimals.\n","primer":"leaves the Product of two decimals.","takes":[],"leaves":[[0,0]],"erefs":[[36,437]],"outbound":[]},{"name":"/","effect":"( A B -- Q ):","markdown":"leaves the Quotient of two decimals.\n","primer":"leaves the Quotient of two decimals.","takes":[],"leaves":[[0,0]],"erefs":[[169,438]],"outbound":[]},{"name":"mod","effect":"( A B -- M ):","markdown":"leaves the Modulo of two decimals.\n","primer":"leaves the Modulo of two decimals.","takes":[],"leaves":[[0,0]],"erefs":[[170,439]],"outbound":[]},{"name":"**","effect":"( A B -- R ):","markdown":"raises A to the power B, leaves Result.\n","primer":"raises A to the power B, leaves Result.","takes":[[0,0],[1,0]],"leaves":[[2,0]],"erefs":[[30,440],[31,440],[171,440]],"outbound":[]},{"name":"round","effect":"( D -- Rd ):","markdown":"rounds Decimal towards the nearest integer, leaves the corresoinding Rounded decimal. If both neighboring integers are equidistant, rounds towards the even neighbor (Banker's rounding).\n\n```\n1 round leaves: 1\n1.23 round leaves: 1\n\n1.5 round leaves: 2\n1.67 round leaves: 2\n\n2.5 round leaves: 2 \"rounds towards the even neighbor\"\n```\n","primer":"rounds Decimal towards the nearest integer, leaves the corresoinding Rounded decimal.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[83,441],[172,441]],"outbound":[]},{"name":"floor","effect":"( D -- Rd ):","markdown":"rounds Decimal *down* towards the nearest integer, leaves the corresoinding Rounded decimal.\n\n```\n1 floor leaves: 1\n1.23 floor leaves: 1\n\n1.5 floor leaves: 1\n1.67 floor leaves: 1\n\n2.5 floor leaves: 2\n\n-2.5 floor leaves: -3 \"rounds down!\"\n```\n","primer":"rounds Decimal *down* towards the nearest integer, leaves the corresoinding Rounded decimal.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[83,442],[172,442]],"outbound":[]},{"name":"ceil","effect":"( D -- Rd ):","markdown":"rounds Decimal *up* towards the nearest integer, leaves the corresoinding Rounded decimal.\n\n```\n1 ceil leaves: 1\n1.23 ceil leaves: 2\n\n1.5 ceil leaves: 2\n1.67 ceil leaves: 2\n\n2.5 ceil leaves: 3\n\n-2.5 ceil leaves: -2 \"rounds up!\"\n```\n","primer":"rounds Decimal *up* towards the nearest integer, leaves the corresoinding Rounded decimal.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[83,443],[172,443]],"outbound":[]},{"name":"trunc","effect":"( D -- Rd ):","markdown":"rounds Decimal towards zero, leaves the resulting Rounded decimal.\n\n```\n1 trunc leaves: 1\n1.23 trunc leaves: 1\n1.5 trunc leaves: 1\n1.67 trunc leaves: 1\n2.5 trunc leaves: 2\n\n-2.3 trunc leaves:  -2\n```\n","primer":"rounds Decimal towards zero, leaves the resulting Rounded decimal.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[83,444],[172,444]],"outbound":[]},{"name":"sqrt","effect":"( D -- R ):","markdown":"leaves the square Root of Decimal.\n","primer":"leaves the square Root of Decimal.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[173,445],[83,445]],"outbound":[]},{"name":"cos","effect":"( Air -- Dc ):","markdown":"leaves Decimal cosine of Angle in radians.\n","primer":"leaves Decimal cosine of Angle in radians.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[174,446],[88,446]],"outbound":[]},{"name":"sin","effect":"( Air -- Ds ):","markdown":"leaves Decimal sine of Angle in radians.\n","primer":"leaves Decimal sine of Angle in radians.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[175,447],[88,447]],"outbound":[]},{"name":"rand","effect":"( -- Rd ):","markdown":"leaves a Random decimal between 0 and 1.\n","primer":"leaves a Random decimal between 0 and 1.","takes":[],"leaves":[[0,0]],"erefs":[[176,448]],"outbound":[]},{"name":"sliceQuoteAt","effect":"( Q Sp -- Pb Pa ):","markdown":"for the given Quote, leaves the Part before and Part after Slice point.\n\n```\n'hello world' 2 sliceQuoteAt leaves: [ 'he' 'llo world' ]\n```\n","primer":"for the given Quote, leaves the Part before and Part after Slice point.","takes":[[0,0],[3,0]],"leaves":[[1,0],[2,0]],"erefs":[[12,449],[177,449],[178,449],[179,449]],"outbound":[]},{"name":"count","effect":"( B/Q/Bf -- N ):","markdown":"leaves N, the amount of elements/graphemes/ bytes in Block/Quote/Byteslice form.\n","primer":"leaves N, the amount of elements/graphemes/ bytes in Block/Quote/Byteslice form.","takes":[[1,0],[2,0],[3,0]],"leaves":[[0,0]],"erefs":[[6,450],[5,450],[12,450],[163,450]],"outbound":[]},{"name":"chr","effect":"( Uc -- Q ):","markdown":"leaves a quote that consists of a single character with the given Unicode codepoint.\n","primer":"leaves a quote that consists of a single character with the given Unicode codepoint.","takes":[[0,0]],"leaves":[],"erefs":[[180,451]],"outbound":[]},{"name":"ord","effect":"( Q -- Uc ):","markdown":"leaves the Unicode codepoint for the first character in Quote. Dies if Quote is empty.\n","primer":"leaves the Unicode codepoint for the first character in Quote.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[180,452],[12,452]],"outbound":[]},{"name":"lpad","effect":"( Q Tl Pq -- Jq ):","markdown":"appends consecutive characters from Padding quote (the last one is repeated if no more follow) to the left of Quote, until Quote count becomes equal to Total length. Leaves the resulting Justified quote. If Quote count is greater than or equal to Total length, Quote is left unchanged as the Justified quote.\n\n```\n'hello' 10 '-' lpad leaves: '-----hello'\n'hello' 10 ':-' lpad leaves: ':----hello'\n'hello' 7 'XYZABC' lpad leaves: 'XYhello'\n'hello' 9 'XYZABC' lpad leaves: 'XYZAhello'\n```\n","primer":"appends consecutive characters from Padding quote (the last one is repeated if no more follow) to the left of Quote, until Quote count becomes equal to Total length.","takes":[[3,0],[1,0],[0,0]],"leaves":[[2,0]],"erefs":[[181,453],[182,453],[183,453],[12,453]],"outbound":[]},{"name":"rpad","effect":"( Q Tl Pq -- Jq ):","markdown":"appends consecutive characters from Padding quote (the last one is repeated if no more follow) to the right of Quote, until Quote count becomes equal to Total length. Leaves the resulting Justified quote. If Quote count is greater than or equal to Total length, Quote is left unchanged as the Justified quote.\n\n```\n'hello' 10 '-' rpad leaves: 'hello-----'\n'hello' 10 ' -' rpad leaves: 'hello ----'\n'hello' 7 'foobar' rpad leaves: 'hellofo'\n```\n","primer":"appends consecutive characters from Padding quote (the last one is repeated if no more follow) to the right of Quote, until Quote count becomes equal to Total length.","takes":[[3,0],[1,0],[0,0]],"leaves":[[2,0]],"erefs":[[181,454],[182,454],[183,454],[12,454]],"outbound":[]},{"name":"fit","effect":"( Q Tl Eq -- Fq ):","markdown":"if Quote is longer than Total length, truncates it so that it can fit Ellipsis quote, and stitches the truncated Quote with the Ellipsis quote, forming Fit quote which is then left on the stack.\n\nEssentially, Fit quote is guaranteed to be of Total length characters **or less!**.\n\n```\n'hello' 10 '\u2026' fit leaves: 'hello'\n'hello world' 10 '\u2026' fit leaves: 'hello wor\u2026'\n'hello world' 8 '' fit leaves: 'hello wo'\n'Lorem ipsum dolor sit amet' 10 '-' fit leaves: 'Lorem ipsu-'\n'Lorem ipsum dolor sit amet' 24 '\u2026 (hidden)' fit leaves: 'Lorem ipsum do\u2026 (hidden)'\n```\n","primer":"if Quote is longer than Total length, truncates it so that it can fit Ellipsis quote, and stitches the truncated Quote with the Ellipsis quote, forming Fit quote which is then left on the stack.","takes":[[1,0],[0,0],[2,0]],"leaves":[[3,0]],"erefs":[[182,455],[12,455],[184,455],[185,455]],"outbound":[]},{"name":"|at","effect":"( B -- N ):","markdown":"leaves N, the position of the cursor in Block.\n","primer":"leaves N, the position of the cursor in Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[6,456],[5,456]],"outbound":[]},{"name":"|to","effect":"( B N -- ):","markdown":"moves the cursor in Block to N.\n","primer":"moves the cursor in Block to N.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[5,457],[6,457]],"outbound":[]},{"name":"<|","effect":"( -- ):","markdown":"moves stack cursor once to the left.\n","primer":"moves stack cursor once to the left.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"|>","effect":"( -- ):","markdown":"moves stack cursor once to the left.\n","primer":"moves stack cursor once to the left.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"|slice","effect":"( B -- Lh Rh ):","markdown":"slices Block at cursor. Leaves Left half and Right half.\n","primer":"slices Block at cursor.","takes":[[0,0]],"leaves":[[1,0],[2,0]],"erefs":[[5,460],[186,460],[187,460]],"outbound":[]},{"name":"cherry","effect":"( [ ... E | ... ]B ~> [ ... | ... ]B -- E ):","markdown":"drops Block and Element before cursor in Block (and moves cursor back once), leaves Element.\n","primer":"drops Block and Element before cursor in Block (and moves cursor back once), leaves Element.","takes":[[1,0],[0,0],[0,1]],"leaves":[[1,0]],"erefs":[[5,461],[162,461]],"outbound":[]},{"name":"shove","effect":"( [ ... | ... ]B E ~> [ ... E | ... ]B -- ):","markdown":"adds Element before cursor in Block (and moves cursor forward once), drops both.\n","primer":"adds Element before cursor in Block (and moves cursor forward once), drops both.","takes":[[1,0],[0,0],[0,1],[1,1]],"leaves":[],"erefs":[[162,462],[5,462]],"outbound":[]},{"name":"shove*","effect":"( [ ...bl | ...br ]B [ ...el | ...er ]Eb ~> [ ...bl ...el | ...br ]B -- ):","markdown":"adds elements before cursor in Element block after the cursor in Block.\n\n```\n[ 1 2 3 ] $: xs\nxs [ 4 5 6 ] shove*\nxs leaves: [ [ 1 2 3 4 5 6 \"|\" ] ]\n\n[ 1 | 2 3 ] $: ys\nys [ 100 200 300 ] shove*\nys leaves: [ 1 100 200 300 | 2 3 ]\n```\n","primer":"adds elements before cursor in Element block after the cursor in Block.","takes":[[1,0],[0,0],[1,1]],"leaves":[],"erefs":[[188,463],[5,463]],"outbound":[]},{"name":"eject","effect":"( [ ... | F ... ]B ~> [ ... | ... ]B -- F ):","markdown":"drops and leaves the Form after cursor in Block.\n","primer":"drops and leaves the Form after cursor in Block.","takes":[[0,0],[1,0],[1,1]],"leaves":[[0,0]],"erefs":[[1,464],[5,464]],"outbound":[]},{"name":"inject","effect":"( B F -- ):","markdown":"inserts Form to Block: adds Form to Block, and moves cursor back again.\n","primer":"inserts Form to Block: adds Form to Block, and moves cursor back again.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[5,465],[1,465]],"outbound":[]},{"name":"thru","effect":"( [ ... | F ... ] -> [ ... F | ... ] -- F ):","markdown":"moves cursor after Form, and leaves Form. Dies if cursor is at the end.\n\nNote: prefer `thru` to `eject` because `eject` modifies the block, and that may cause a tape copy which uses up a bit of memory and resources. The difference would matter only in high load scenarios, though.\n\nNote: anything that *does not* `ahead inject` will be OK with `ahead thru`. And even if it does `ahead inject`, still, there are ways to overcome the problems from not `ahead eject`ing.\n","primer":"moves cursor after Form, and leaves Form.","takes":[[0,0],[0,1]],"leaves":[[0,0]],"erefs":[[1,466]],"outbound":[464]},{"name":"thruBlock","effect":"( B -- Bf / [ Vf ] ):","markdown":"similar to `thru` for Block. If form after cursor is a Block form, it is left. If it is a Value form, then it is enclosed in a new block whose parent is Block.\n","primer":"similar to `thru` for Block.","takes":[[2,0]],"leaves":[[0,0],[1,0]],"erefs":[[189,467],[190,467],[5,467]],"outbound":[466]},{"name":"top","effect":"( [ ... F | ... ]B -- F ):","markdown":"leaves the top Form in Block.\n","primer":"leaves the top Form in Block.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[1,468],[5,468]],"outbound":[]},{"name":"mergeDicts","effect":"( Rb Db -- ):","markdown":"copies entries from Donor block's dictionary to Recipient block's dictionary. Donor entries override same-named entries in Recipient. Donor entries starting with one or more underscores are not imported.\n\n```\n[ ] $: a\na #x 100 pushes\na #_private 'Fool!' pushes\n[ ] $: b\nb #y 200 pushes\n\na b 2echo\n\"STDOUT: [ \u00b7 ${x :: 100} ${_private :: 'Fool!'} ]\u23ce\"\n\"STDOUT: [ \u00b7 ${y :: 200} ]\u23ce\"\n\nb a mergeDicts\nb echo\n\"STDOUT: [ \u00b7 ${y :: 200} ${x :: 100} ]\u23ce\"\n```\n","primer":"copies entries from Donor block's dictionary to Recipient block's dictionary.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[191,469],[192,469]],"outbound":[]},{"name":"sortUsing!","effect":"( B Cb -- B ):","markdown":"leaves Block sorted inplace. Forms in Block are compared using Comparator block.\n\nComparator block is opened with two forms on the stack; let's call them A and B. If Comparator block leaves a negative decimal (conventionally `-1`), then `A &lt; B`. If Comparator block leaves `0`, then `A = B`. If Comparator block leaves a positive decimal (conventionally `1`), then `A &gt; B`.\n\nDies if Comparator block leaves any other (kind of) form.\n\nIgnores all forms but the topmost for Comparator block.\n\n```\n[ 3 2 1 ] [ - ] sortUsing! leaves: [ 1 2 3 ]\n```\n","primer":"leaves Block sorted inplace.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[5,470],[49,470]],"outbound":[]},{"name":"getErrorDetails","effect":"( Eo -- Dq ):","markdown":"leaves Details quote containing error details of an Error object.\n","primer":"leaves Details quote containing error details of an Error object.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[193,471],[121,471]],"outbound":[]},{"name":"toQuote","effect":"( F -- Qr ):","markdown":"leaves Quote representation of Form.\n","primer":"leaves Quote representation of Form.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[194,472],[1,472]],"outbound":[]},{"name":"toByteslice","effect":"( Q -- B ):","markdown":"leaves immutable Byteslice for Quote.\n","primer":"leaves immutable Byteslice for Quote.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[152,473],[12,473]],"outbound":[]},{"name":"replaceAll","effect":"( Sq Pq Q -- Rq ):","markdown":"replaces all instances of Pattern quote in Source quote with Quote. Leaves the Resulting quote.\n\n```\n'hello' 'l' 'y' replaceAll leaves: 'heyyo'\n```\n","primer":"replaces all instances of Pattern quote in Source quote with Quote.","takes":[[1,0],[0,0],[2,0]],"leaves":[[3,0]],"erefs":[[148,474],[195,474],[12,474],[196,474]],"outbound":[]},{"name":"effect","effect":"( F -- Eq ):","markdown":"leaves Effect quote for Form.\n\nIf Form is not a block nor a builtin, it is simply converted to quote in the same way as `toQuote`.\n\nIf Form is a block or a builtin, an attempt is made at extracting a stack effect expression from its comment. If the attempt fails, Form's description is left. If the attempt was successful, the extracted stack effect quote is added onto the stack as Effect quote.\n\n```\n100 effect leaves: '100'\ntrue effect leaves: 'true'\n\n[] effect leaves: 'a block'\n[ \"Hello World\" ] effect leaves: 'a block'\n[ \"( -- ) \"] effect leaves: '( -- )'\n\n#+ here effect leaves: '( A B -- S )' \"(yours may differ)\"\n#map: here effect leaves: '( Lb B -- MLb )'\n```\n","primer":"leaves Effect quote for Form.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[197,475],[1,475]],"outbound":[472]},{"name":"die","effect":"( D/Eo -- ):","markdown":"dies with Details quote/Error object.\n","primer":"dies with Details quote/Error object.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[198,476],[121,476]],"outbound":[]},{"name":"stitch","effect":"( Q1 Q2 -- Q3 ):","markdown":"quote concatenation.\n","primer":"quote concatenation.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"reparent","effect":"( C P -- C ):","markdown":"changes the parent of Child to Parent. Lookup cycles are allowed and handled gracefully.\n","primer":"changes the parent of Child to Parent.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[18,478],[19,478]],"outbound":[]},{"name":"befriend","effect":"( B F -- ):","markdown":"adds Friend to Block's friend list.\n\nFriends are asked for word entries after parents, grandparents etc. have failed to retrieve them. This recurses, e.g. friends ask their own friends and so on, until the entry is found. Lookup cycles are allowed and handled gracefully.\n\n```\n[ 100 $: x this ] open $: a\n[ 200 $: y this ] open $: b\na b befriend\nb a befriend\na.x echo\n\"STDOUT: 100\u23ce\"\n\na.y echo\n\"STDOUT: 200\u23ce\"\n\nb.x echo\n\"STDOUT: 100\u23ce\"\n\nb.y echo\n\"STDOUT: 200\u23ce\"\n\na #x [ 'I've changed!' echo ] opens\n\na.x\n\"STDOUT: I've changed!\u23ce\"\nb.x\n\"STDOUT: I've changed!\u23ce\"\n```\n","primer":"adds Friend to Block's friend list.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[20,479],[5,479]],"outbound":[]},{"name":"unfriend","effect":"( B F -- ):","markdown":"removes Friend from Block's friend list. Does nothing if Friend is not in the friend list. See `befriend`.\n\n```\n[ 100 $: x this ] open $: a\n[ 200 $: y this ] open $: b\na b befriend\na.x echo\n\"STDOUT: 100\u23ce\"\na.y echo\n\"STDOUT: 200\u23ce\"\na b unfriend\na.x echo\n\"STDOUT: 100\u23ce\"\na.y echo\n\"Sorry: no value form found for 'y'.\"\n```\n","primer":"removes Friend from Block's friend list.","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[20,480],[5,480]],"outbound":[479]},{"name":"friends","effect":"( B -- Fl ):","markdown":"leaves Friend list of Block. See `befriend`.\n\n```\n[ 100 $: x this ] open $: a\n[ 200 $: y this ] open $: b\na b befriend\na friends count echo\n\"STDOUT: 1\u23ce\"\na friends first b same? echo\n\"STDOUT: true\u23ce\"\na.y echo\n\"STDOUT: 200\u23ce\"\na friends [ drop ] hydrate\na friends count echo\n\"STDOUT: 0\u23ce\"\na.y echo\n\"Sorry: no value form found for 'y'.\"\n```\n","primer":"leaves Friend list of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[199,481],[5,481]],"outbound":[479]},{"name":"slurp","effect":"( B Q -- B ):","markdown":"parses Quote and adds all forms from Quote to Block.\n","primer":"parses Quote and adds all forms from Quote to Block.","takes":[[0,0],[1,0]],"leaves":[[0,0]],"erefs":[[5,482],[12,482]],"outbound":[]},{"name":"orphan","effect":"( -- O ):","markdown":"Leaves an Orphan (a parent-less block).\n","primer":"Leaves an Orphan (a parent-less block).","takes":[],"leaves":[[0,0]],"erefs":[[200,483]],"outbound":[]},{"name":"orphan?","effect":"( B -- true/false ):","markdown":"leaves whether Block is an orphan\n","primer":"leaves whether Block is an orphan","takes":[[0,0]],"leaves":[],"erefs":[[5,484]],"outbound":[]},{"name":"toOrphan","effect":"( B -- B ):","markdown":"makes Block an orphan (destroys the link with its parent).\n\n```\n0 $: x\n[ ] $: b\nb . x echo\n\"STDOUT: 0\u23ce\"\n\nb toOrphan leaves: [ [ ] ]\n. x\n\"Sorry: no value form found for 'x'\"\"\n```\n","primer":"makes Block an orphan (destroys the link with its parent).","takes":[[0,0]],"leaves":[[0,0]],"erefs":[[5,485]],"outbound":[]},{"name":"toTape","effect":"( B -- Tb ):","markdown":"leaves Tape block for Block, i.e., the tape part of Block. Useful for e.g. comparing two blocks only for tape content, when Block may have dictionary entries.\n\nLookup hierarchy is destroyed: Tape block is an orphan.\n\n```\n[ 1 2 3 ] $: a\na #x 0 pushes\na (a toTape) 2echo\n\"STDOUT: [ 1 2 3 \u00b7 ${x :: 0} ]\u23ce\"\n\"STDOUT: [ 1 2 3 ]\u23ce\"\n```\n","primer":"leaves Tape block for Block, i.e., the tape part of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[201,486],[5,486]],"outbound":[]},{"name":"toDict","effect":"( B -- Db ):","markdown":"leaves Dictionary block for Block, i.e., the dictionary part of Block. Useful for e.g. comparing two blocks only for dictionary content in case tape contents differ.\n\nLookup hierarchy is destroyed: Dictionary block is an orphan.\n\n```\n[ ${ x y } this ] @: createPoint\n\n10 20 createPoint $: a\n10 20 createPoint $: b\n\na b = leaves: false\n\n\"And not for the reason you might think of. Their TAPES are not\n equal; `a` and `b` are not only objects, they are also pieces\n of code that led to each one's creation (sort of).\"\na toQuote leaves: '[ ${ x y } this \u00b7 ${x :: 10} ${y :: 20} ]'\nb toQuote leaves: '[ ${ x y } this \u00b7 ${x :: 10} ${y :: 20} ]'\n\n\"Let's strip the code using toDict:\"\na toDict leaves: '[ \u00b7 ${x :: 10} ${y :: 20} ]'\nb toDict leaves: '[ \u00b7 ${x :: 10} ${y :: 20} ]'\n       = leaves: true \"< now they're equal\"\n```\n","primer":"leaves Dictionary block for Block, i.e., the dictionary part of Block.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[22,487],[5,487]],"outbound":[]},{"name":"desc","effect":"( F -- Dq ):","markdown":"leaves the Description quote of the given Form.\n\n```\n100 desc leaves: 'decimal number 100'\n'foobar' desc leaves: 'quote 'foobar''\n[ 1 2 3 ] desc leaves: 'a block'\n[ \"I am a block\" 1 2 3 ] desc leaves: 'I am a block'\ntrue desc leaves: 'boolean true'\n```\n","primer":"leaves the Description quote of the given Form.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[98,488],[1,488]],"outbound":[]},{"name":"typedesc","effect":"( F -- Dq ):","markdown":"leaves the type Description quote of the given Form.\n\n```\n100 typedesc leaves: 'decimal'\n'foobar' typedesc leaves: 'quote'\n[ 1 2 3 ] typedesc leaves: 'block'\n[ \"I am a block\" 1 2 3 ] typedesc leaves: 'block'\ntrue typedesc leaves: 'boolean'\n```\n","primer":"leaves the type Description quote of the given Form.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[98,489],[1,489]],"outbound":[]},{"name":"nki:toBlock","effect":"( Bf -- B ):","markdown":"leaves Block for the given Byteslice form, assumed to contain a well-formed Novika image created with `nki:captureAll`, `nki:captureNeighborhood`, or otherwise. Dies if Byteslice form is an invalid Novika image, or isn't a Novika image.\n\nFor code example, see `nki:captureNeighborhood`.\n","primer":"leaves Block for the given Byteslice form, assumed to contain a well-formed Novika image created with `nki:captureAll`, `nki:captureNeighborhood`, or otherwise.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[5,491],[163,490]],"outbound":[491,492]},{"name":"nki:captureAll","effect":"( B -- Bf ):","markdown":"thoroughly, recursively captures entire hierarchy of Block (its parents, prototype, friends, tape, and dictionary), and leaves the resulting Novika image as a Byteslice form.\n\nArchives image payload using Gzip, fast.\n\nIf you're a visual type of person, imagine this word and all related facilities as a kind of \"mold\", which carefully, in an ordered fashion \"fills up\" a maze, until all paths were explored and all exits found.\n\nFor code example, see `nki:captureNeighborhood`.\n","primer":"thoroughly, recursively captures entire hierarchy of Block (its parents, prototype, friends, tape, and dictionary), and leaves the resulting Novika image as a Byteslice form.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[5,491],[163,491]],"outbound":[492]},{"name":"nki:captureNeighborhood","effect":"( B -- Bf ):","markdown":"like `nki:captureAll`, but rather than capturing all reachable blocks, captures only Block's neighborhood. Leaves the resulting Byteslice form.\n\nArchives image payload using Gzip, fast.\n\nWe store each block in Block's tape and dictionary in a list, then ask that block to do the same. When recursion finishes, the resulting list is called *block neighborhood*.\n\nParent, friends, and prototype of the given block are reconstructed *if and only if they are in the block neighborhood*.\n\n```\n[ 1 2 3 ] nki:captureNeighborhood $: imgN\n\nimgN toQuote leaves: '[byteslice, consists of 111 byte(s)]' \"yours may differ!\"\nimgN nki:toBlock leaves: [ [ 1 2 3 ] ]\n\n\"As opposed to nki:captureAll, which will capture EVERYTHING\n it can reach:\"\n[ 1 2 3 ] nki:captureAll $: imgA\n\nimgA toQuote leaves: '[byteslice, consists of 38298 byte(s)]' \"yours may differ!\"\n\n\"Note: [ 1 2 3 ] lives in a parallel universe now, with\n its own friends, prototypes, toplevel block, and so on!\n It doesn't have any links whatsoever to the whoever-it-was\n that called nki:captureAll!\"\nimgA nki:toBlock leaves: [ [ 1 2 3 ] ]\n```\n","primer":"like `nki:captureAll`, but rather than capturing all reachable blocks, captures only Block's neighborhood.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[163,492],[5,492]],"outbound":[491]},{"name":"nki:captureAllRaw","effect":"( B -- Bf ):","markdown":"same as `nki:captureAll`, but doesn't archive image payload. May yield very large Byteslice forms.\n","primer":"same as `nki:captureAll`, but doesn't archive image payload.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[5,491],[202,493]],"outbound":[491]},{"name":"nki:captureNeighborhoodRaw","effect":"( B -- Bf ):","markdown":"same as `nki:captureNeighborhood`, but doesn't archive image payload. May yield large Byteslice forms.\n","primer":"same as `nki:captureNeighborhood`, but doesn't archive image payload.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[202,494],[5,492]],"outbound":[492]},{"name":"nki:captureAllGzipBest","effect":"( B -- Bf ):","markdown":"same as `nki:captureAll`, but archives image payload using Gzip, best.\n","primer":"same as `nki:captureAll`, but archives image payload using Gzip, best.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[5,491],[163,491]],"outbound":[491]},{"name":"nki:captureNeighborhoodGzipBest","effect":"( B -- Bf ):","markdown":"same as `nki:captureNeighborhood`, but archives image payload using Gzip, best.\n","primer":"same as `nki:captureNeighborhood`, but archives image payload using Gzip, best.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[163,492],[5,492]],"outbound":[492]},{"name":"nki:captureAllBrotliFast","effect":"( B -- Bf ):","markdown":"same as `nki:captureAll`, but archives image payload using Brotli, fast.\n","primer":"same as `nki:captureAll`, but archives image payload using Brotli, fast.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[203,497],[163,491]],"outbound":[491]},{"name":"nki:captureNeighborhoodBrotliFast","effect":"( B -- Bf ):","markdown":"same as `nki:captureNeighborhood`, but archives image payload using Brotli, fast.\n","primer":"same as `nki:captureNeighborhood`, but archives image payload using Brotli, fast.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[163,492],[5,492]],"outbound":[492]},{"name":"nki:captureAllBrotliBest","effect":"( B -- Bf ):","markdown":"same as `nki:captureAll`, but archives image payload using Brotli, best.\n","primer":"same as `nki:captureAll`, but archives image payload using Brotli, best.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[203,499],[163,491]],"outbound":[491]},{"name":"nki:captureNeighborhoodBrotliBest","effect":"( B -- Bf ):","markdown":"same as `nki:captureNeighborhood`, but archives image payload using Brotli, best.\n","primer":"same as `nki:captureNeighborhood`, but archives image payload using Brotli, best.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[163,492],[5,492]],"outbound":[492]},{"name":"console:on","effect":"( -- ):","markdown":"enables the console. Must be called before using any other console-related word.\n","primer":"enables the console.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"console:off","effect":"( -- ):","markdown":"disables the console. Must be called at the end of your program or when you don't need console anymore.\n","primer":"disables the console.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"console:compat","effect":"( -- ):","markdown":"enables the compatibility color output mode. In this mode, only 8 colors are available. All RGB colors are automatically reduced to one of those 8 colors.\n","primer":"enables the compatibility color output mode.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"console:256","effect":"( -- ):","markdown":"enables the 256-color output mode. In this mode, 256 colors are available. All RGB colors are automatically reduced to one of those 256 colors.\n","primer":"enables the 256-color output mode.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"console:truecolor","effect":"( -- ):","markdown":"enables the truecolor output mode. In this mode, all colors are available and are passed to the console as-is.\n","primer":"enables the truecolor output mode.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"console:size","effect":"( -- Cw Ch ):","markdown":"leaves the Console width (in columns) and Console height (in rows).\n","primer":"leaves the Console width (in columns) and Console height (in rows).","takes":[],"leaves":[[0,0],[1,0]],"erefs":[[60,506],[61,506]],"outbound":[]},{"name":"console:setTimeout","effect":"( D -- ):","markdown":"sets input timeout to Duration, given in *milliseconds*.\n\n* If Duration is negative, `console:readKey` will wait for input indefinitely (i.e., until there is input).\n\n* If Duration is zero, `console:readKey` won't wait for input at all, but make note if there is any at the moment.\n\n* If Duration is positive, `console:readKey` will peek during the timeout window.\n","primer":"sets input timeout to Duration, given in *milliseconds*.","takes":[[0,0]],"leaves":[],"erefs":[[123,507]],"outbound":[508]},{"name":"console:readKey","effect":"( -- ):","markdown":"peeks or waits for input. See `console:setTimeout`. Refreshes the input state. Use `console:hadKeyPressed` and friends to explore the input state afterwards.\n","primer":"peeks or waits for input.","takes":[],"leaves":[],"erefs":[],"outbound":[507]},{"name":"console:hadKeyPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether any key was pressed.\n","primer":"leaves Boolean for whether any key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,509]],"outbound":[]},{"name":"console:hadCtrlPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the CTRL key was pressed.\n","primer":"leaves Boolean for whether the CTRL key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,510]],"outbound":[]},{"name":"console:hadAltPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the ALT key was pressed.\n","primer":"leaves Boolean for whether the ALT key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,511]],"outbound":[]},{"name":"console:hadShiftPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the SHIFT key was pressed.\n","primer":"leaves Boolean for whether the SHIFT key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,512]],"outbound":[]},{"name":"console:hadBackspacePressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the Backspace key was pressed.\n","primer":"leaves Boolean for whether the Backspace key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,513]],"outbound":[]},{"name":"console:hadFnPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether one of the function keys F1-F12 was pressed.\n","primer":"leaves Boolean for whether one of the function keys F1-F12 was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,514]],"outbound":[]},{"name":"console:hadInsertPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the INSERT key was pressed.\n","primer":"leaves Boolean for whether the INSERT key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,515]],"outbound":[]},{"name":"console:hadDeletePressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the DELETE key was pressed.\n","primer":"leaves Boolean for whether the DELETE key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,516]],"outbound":[]},{"name":"console:hadHomePressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the HOME key was pressed.\n","primer":"leaves Boolean for whether the HOME key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,517]],"outbound":[]},{"name":"console:hadEndPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the END key was pressed.\n","primer":"leaves Boolean for whether the END key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,518]],"outbound":[]},{"name":"console:hadPageUpPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the PAGE UP key was pressed.\n","primer":"leaves Boolean for whether the PAGE UP key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,519]],"outbound":[]},{"name":"console:hadPageDownPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the PAGE DOWN key was pressed.\n","primer":"leaves Boolean for whether the PAGE DOWN key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,520]],"outbound":[]},{"name":"console:hadLeftPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the LEFT ARROW key was pressed.\n","primer":"leaves Boolean for whether the LEFT ARROW key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,521]],"outbound":[]},{"name":"console:hadRightPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the RIGHT ARROW key was pressed.\n","primer":"leaves Boolean for whether the RIGHT ARROW key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,522]],"outbound":[]},{"name":"console:hadUpPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the UP ARROW key was pressed.\n","primer":"leaves Boolean for whether the UP ARROW key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,523]],"outbound":[]},{"name":"console:hadDownPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether the DOWN ARROW key was pressed.\n","primer":"leaves Boolean for whether the DOWN ARROW key was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[96,524]],"outbound":[]},{"name":"console:hadCharPressed?","effect":"( -- B ):","markdown":"leaves Boolean for whether EXCLUSIVELY a printable character key was pressed (no CTRL, ALT, etc.) Whether the SHIFT key was pressed or not is ignored.\n","primer":"leaves Boolean for whether EXCLUSIVELY a printable character key was pressed (no CTRL, ALT, etc.)","takes":[],"leaves":[[0,0]],"erefs":[[96,525]],"outbound":[]},{"name":"console:getCharPressed","effect":"( -- Cq ):","markdown":"leaves Char quote for the key that was pressed. Usually a lowercase or uppercase letter; but also may look like `' '` or `'\t'`, etc.)\n\nIn case the key that was pressed cannot be represented by the means of a quote, or if the user did not press any key, an empty quote is left in place of Char quote.\n","primer":"leaves Char quote for the key that was pressed.","takes":[],"leaves":[[0,0]],"erefs":[[204,526]],"outbound":[]},{"name":"console:change","effect":"( X Y -- ):","markdown":"changes the color of the cell at X, Y coordinates to be the foreground, background colors set by ink's `withEchoFg` and `withEchoBg`.\n","primer":"changes the color of the cell at X, Y coordinates to be the foreground, background colors set by ink's `withEchoFg` and `withEchoBg`.","takes":[[0,0],[1,0]],"leaves":[],"erefs":[[9,527],[10,527]],"outbound":[335,336]},{"name":"console:appendEcho","effect":"( F X Y -- ):","markdown":"appends echo of Form at an X and Y position (in columns and rows correspondingly) using the foreground, background colors set by ink's `withEchoFg` and `withEchoBg`.\n","primer":"appends echo of Form at an X and Y position (in columns and rows correspondingly) using the foreground, background colors set by ink's `withEchoFg` and `withEchoBg`.","takes":[[0,0],[1,0],[2,0]],"leaves":[],"erefs":[[1,528],[9,528],[10,528]],"outbound":[335,336]},{"name":"console:withReverseAppendEcho","effect":"( F X Y -- ):","markdown":"appends Form with foreground and background colors swapped with each other (background color is set to foreground color, and vice versa).\n","primer":"appends Form with foreground and background colors swapped with each other (background color is set to foreground color, and vice versa).","takes":[[0,0]],"leaves":[],"erefs":[[1,529]],"outbound":[]},{"name":"console:present","effect":"( -- ):","markdown":"syncs internal buffer and console.\n","primer":"syncs internal buffer and console.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"console:clear","effect":"( -- ):","markdown":"clears console with primary colors.\n","primer":"clears console with primary colors.","takes":[],"leaves":[],"erefs":[],"outbound":[]},{"name":"disk:has?","effect":"( Pq -- true/false ):","markdown":"leaves whether Path quote exists on the disk.\n","primer":"leaves whether Path quote exists on the disk.","takes":[[0,0]],"leaves":[],"erefs":[[205,532]],"outbound":[]},{"name":"disk:canRead?","effect":"( Pq -- true/false ):","markdown":"leaves whether Path quote exists and is readable.\n","primer":"leaves whether Path quote exists and is readable.","takes":[[0,0]],"leaves":[],"erefs":[[205,533]],"outbound":[]},{"name":"disk:hasDir?","effect":"( Pq -- true/false ):","markdown":"leaves whether Path quote exists and points to a directory.\n","primer":"leaves whether Path quote exists and points to a directory.","takes":[[0,0]],"leaves":[],"erefs":[[205,534]],"outbound":[]},{"name":"disk:hasFile?","effect":"( Pq -- true/false ):","markdown":"leaves whether Path quote exists and points to a file.\n","primer":"leaves whether Path quote exists and points to a file.","takes":[[0,0]],"leaves":[],"erefs":[[205,535]],"outbound":[]},{"name":"disk:hasSymlink?","effect":"( Pq -- true/false ):","markdown":"leaves whether Path quote exists and points to a symlink.\n","primer":"leaves whether Path quote exists and points to a symlink.","takes":[[0,0]],"leaves":[],"erefs":[[205,536]],"outbound":[]},{"name":"disk:dirEmpty?","effect":"( Ptd -- B ):","markdown":"leaves Boolean for whether Path to directory is empty. Dies if Path to directory points to something other than a directory, or doesn't exist.\n","primer":"leaves Boolean for whether Path to directory is empty.","takes":[],"leaves":[[0,0]],"erefs":[[96,537]],"outbound":[]},{"name":"disk:join","effect":"( Bp Cp -- P ):","markdown":"leaves Path, which is the result of joining Base path and Child path using the platform-specific path separator.\n\n```\n'hello' 'world' disk:join leaves: 'hello/world' \"On Unix\"\n'hello' 'world' disk:join leaves: 'hello\\world' \"On Windows\"\n```\n","primer":"leaves Path, which is the result of joining Base path and Child path using the platform-specific path separator.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[156,538],[206,538],[207,538]],"outbound":[]},{"name":"disk:pwd","effect":"( -- Wd ):","markdown":"leaves current Working directory.\n","primer":"leaves current Working directory.","takes":[],"leaves":[[0,0]],"erefs":[[208,539]],"outbound":[]},{"name":"disk:home","effect":"( -- Hd ):","markdown":"leaves current user's Home directory.\n","primer":"leaves current user's Home directory.","takes":[],"leaves":[[0,0]],"erefs":[[209,540]],"outbound":[]},{"name":"disk:touch","effect":"( P -- ):","markdown":"creates an empty file at Path. Does nothing if Path already exists.\n","primer":"creates an empty file at Path.","takes":[[0,0]],"leaves":[],"erefs":[[156,541]],"outbound":[]},{"name":"disk:mkdir","effect":"( P -- ):","markdown":"creates an empty directory at Path, including any non-existing intermediate directories. Does nothing if Path already exists.\n","primer":"creates an empty directory at Path, including any non-existing intermediate directories.","takes":[[0,0]],"leaves":[],"erefs":[[156,542]],"outbound":[]},{"name":"disk:copy","effect":"( S D -- ):","markdown":"copies Source (quote path to a file, symlink, or directory) to Destination (also a quote).\n\nIf Source is a directory, copies it recursively. If copy process failed, dies.\n","primer":"copies Source (quote path to a file, symlink, or directory) to Destination (also a quote).","takes":[[1,0],[0,0]],"leaves":[],"erefs":[[34,543],[23,543]],"outbound":[]},{"name":"disk:read","effect":"( F -- C ):","markdown":"reads and leaves the Contents of File. Dies if there is no File.\n","primer":"reads and leaves the Contents of File.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[210,544],[211,544]],"outbound":[]},{"name":"disk:write","effect":"( Cq/B Fp -- ):","markdown":"(over)writes content of file at File path with Content quote/Byteslice. Dies if File path doesn't exist or doesn't point to a file.\n","primer":"(over)writes content of file at File path with Content quote/Byteslice.","takes":[[0,0],[1,0],[2,0]],"leaves":[],"erefs":[[212,545],[152,545],[213,545]],"outbound":[]},{"name":"ffi:library?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a foreign library form.\n\n```\n'foo' ffi:getLibrary ffi:library? leaves: true\n```\n","primer":"leaves whether Form is a foreign library form.","takes":[[0,0]],"leaves":[],"erefs":[[1,546]],"outbound":[]},{"name":"ffi:layout?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a foreign layout form.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:layout? leaves: true\n```\n","primer":"leaves whether Form is a foreign layout form.","takes":[[0,0]],"leaves":[],"erefs":[[1,547]],"outbound":[]},{"name":"ffi:struct&?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a struct reference view form.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct& $: point&\npoint& ffi:struct&? leaves: true\n```\n","primer":"leaves whether Form is a struct reference view form.","takes":[[0,0]],"leaves":[],"erefs":[[1,548]],"outbound":[]},{"name":"ffi:struct~?","effect":"( F -- true/false ):","markdown":"leaves whether Form is an inline struct view form.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct~ $: point~\npoint~ ffi:struct~? leaves: true\n```\n","primer":"leaves whether Form is an inline struct view form.","takes":[[0,0]],"leaves":[],"erefs":[[1,549]],"outbound":[]},{"name":"ffi:union?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a union view form.\n\n```\n[ chr char ord u8 ] ffi:createLayout $: quux\n\nquux ffi:allocateUnion $: quuxU\nquuxU ffi:union? leaves: true\n```\n","primer":"leaves whether Form is a union view form.","takes":[[0,0]],"leaves":[],"erefs":[[1,550]],"outbound":[]},{"name":"ffi:hole?","effect":"( F -- true/false ):","markdown":"leaves whether Form is a hole.\n\n```\n#i32 ffi:hole $: intHole\n\nintHole ffi:hole? leaves: true\n```\n","primer":"leaves whether Form is a hole.","takes":[[0,0]],"leaves":[],"erefs":[[1,551]],"outbound":[]},{"name":"ffi:getLibrary?","effect":"( I -- Lf true / false ):","markdown":"leaves Library form followed by true if dynamic library with the given Id exists and was loaded & retrieved successfully; otherwise, leaves false.\n\nOpening Library form allows one to expose functions from the underlying dynamic library (.so on Linux, .dll on Windows, .dylib on Mac). See FFI documentation on GitHub Wiki for more details and examples.\n\n```\n'SDL2' ffi:getLibrary? leaves: [ \"[foreign library]\" true ]\n'random-nonexisting-library' ffi:getLibrary? leaves: false\n```\n","primer":"leaves Library form followed by true if dynamic library with the given Id exists and was loaded & retrieved successfully; otherwise, leaves false.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[3,552],[214,552]],"outbound":[]},{"name":"ffi:getLibrary","effect":"( I -- Lf ):","markdown":"leaves Library form if dynamic library with the given Id exists and was loaded & retrieved successfully; otherwise, dies.\n\nOpening Library form allows one to expose functions from the underlying dynamic library (.so on Linux, .dll on Windows, .dylib on Mac). See FFI documentation on GitHub Wiki for more details and examples.\n\n```\n'SDL2' ffi:getLibrary ffi:library? leaves: true\n'random-nonexisting-library' ffi:getLibrary \"Dies: no such library\"\n```\n","primer":"leaves Library form if dynamic library with the given Id exists and was loaded & retrieved successfully; otherwise, dies.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[3,553],[214,553]],"outbound":[]},{"name":"ffi:createLayout","effect":"( Lb -- Slf ):","markdown":"parses Layout block and leaves the resulting Struct layout form.\n\nStruct layouts are a generalization over structs (heap- allocated and stack-allocated) and unions. They literally describe how structs (unions) are layed out in memory.\n\nLayout block consists of *name words followed by type words*. See the example below. A reference to another struct layout can be made in Layout block using the prefixes `&amp;` (heap- allocated struct, i.e., pointer to struct), `~` (inline or stack-allocated struct), and `?` (stack-allocated union).\n\nInline struct cycles are forbidden. Union cycles are forbidden. Either could be hidden behind a reference/pointer.\n\nLayout block is parsed lazily (on first use, e.g., by `toQuote`, `allocateStruct` variants, `=`, etc.) Therefore, you can define self-referential structs, mutually referential structs, and reference layouts that are defined later.\n\nSee FFI documentation on GitHub Wiki for a list of available types and the corresponding C types.\n\n```\n[ x f32\n  y f32\n] ffi:createLayout $: point\n\n[ datum ~point    \"<- inline struct\"\n  next &pointNode \"<- struct reference\"\n] ffi:createLayout $: pointNode\n\n[ asPoint &point\n  asPointNode ~pointNode\n] ffi:createLayout $: pointNodeUnion\n\n[ type u8\n  value ?pointNodeUnion \"<- stack-allocated union\"\n] ffi:createLayout $: pointNodeOrPoint\n```\n","primer":"parses Layout block and leaves the resulting Struct layout form.","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[215,554],[216,554]],"outbound":[233,472,386]},{"name":"ffi:allocateStruct~","effect":"( Slf -- Isv ):","markdown":"allocates Inline struct view for the given Struct layout form. If the struct is no longer in use, it is freed by the GC automatically.\n\nThis word is **unsafe**: the resulting Inline struct view is in an undefined state (may contain junk) before you (or the C code you pass it to) fills it with good values. Showing the struct view left by this word to clients may expose your program to a whole class of security vulnerabilities.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct~ $: point~\npoint~ #x 123 entry:submit\npoint~ #y 456 entry:submit\npoint~ toQuote leaves: '~\u27e8x=123_i32, y=456_i32\u27e9'\n```\n","primer":"allocates Inline struct view for the given Struct layout form.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[215,555],[217,555]],"outbound":[]},{"name":"ffi:buildStruct~","effect":"( Eb Slf -- Isv ):","markdown":"allocates and fills Inline struct view with entries by asking Entry block for them.\n\nIf Entry block is missing an entry matching a field that Struct layout form declares, and that field is of type `pointer` or struct reference (`&amp;`), `none` (C nullptr) is used as the value. Dies if Entry block is missing matching entry or entries for fields of other types.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\n100 $: x\n200 $: y\n\n\"Note: `this` has entries called `x` and `y`. `point` has\n fields called `x` and `y`. A match!\"\nthis point ffi:buildStruct~ $: point~\n\npoint~ toQuote leaves: '~\u27e8x=100_i32, y=200_i32\u27e9'\n```\n","primer":"allocates and fills Inline struct view with entries by asking Entry block for them.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[217,556],[215,556],[218,556]],"outbound":[]},{"name":"ffi:asStruct~","effect":"( A Slf -- Isv ):","markdown":"creates and leaves Inline struct view for the given Address, according to Struct layout form.\n\nThis word is **unsafe**: it does not check whether Address points at something that is layed out according to Struct layout form. Passing 0 (none aka null pointer) for Address will lead to segfault. Passing Address that is outside of your program's memory will lead to segfault. Passing Address that *is* in the bounds of your program's memory, but one not pointing at a struct in accordance with Struct layout form, will lead to undefined behavior (most likely junk values in Inline struct view).\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\n100 $: x\n200 $: y\nthis point ffi:buildStruct~ $: point~\n\npoint~ ffi:addressof $: addr\n\naddr point ffi:asStruct~ $: addrPoint~\naddrPoint~.x leaves: x\naddrPoint~.y leaves: y\naddrPoint~ toQuote leaves: '~\u27e8x=100_i32, y=200_i32\u27e9'\n```\n","primer":"creates and leaves Inline struct view for the given Address, according to Struct layout form.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[217,557],[215,557],[139,557]],"outbound":[]},{"name":"ffi:allocateStruct&","effect":"( Slf -- Srv ):","markdown":"allocates Struct reference view for the given Struct layout form. If the struct is no longer in use, it is freed by the GC automatically.\n\nThis word is **unsafe**: the resulting Struct reference view is in an undefined state (may contain junk) before you (or the C code you pass it to) fills it with good values. Showing the struct view left by this word to clients may expose your program to a whole class of security vulnerabilities.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct& $: point&\npoint& #x 123 entry:submit\npoint& #y 456 entry:submit\npoint& toQuote leaves: '&\u27e8x=123_i32, y=456_i32\u27e9'\n```\n","primer":"allocates Struct reference view for the given Struct layout form.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[215,558],[219,558]],"outbound":[]},{"name":"ffi:buildStruct&","effect":"( Eb Slf -- Srv ):","markdown":"allocates and fills Struct reference view with entries by asking Entry block for them.\n\nIf Entry block is missing an entry matching a field that Struct layout form declares, and that field is of type `pointer` or struct reference (`&amp;`), `none` (C nullptr) is used as the value. Dies if Entry block is missing matching entry or entries for fields of other types.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\n100 $: x\n200 $: y\n\n\"Note: `this` has entries called `x` and `y`. `point` has\n fields called `x` and `y`. A match!\"\nthis point ffi:buildStruct& $: point&\n\npoint& toQuote leaves: '&\u27e8x=100_i32, y=200_i32\u27e9'\n```\n","primer":"allocates and fills Struct reference view with entries by asking Entry block for them.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[219,559],[215,559],[218,559]],"outbound":[]},{"name":"ffi:asStruct&","effect":"( A Slf -- Srv ):","markdown":"creates and leaves Struct reference view for the given Address, according to Struct layout form.\n\nThis word is **unsafe**: it does not check whether Address points at something that is layed out according to Struct layout form. Passing 0 (none aka null pointer) for Address will lead to segfault. Passing Address that is outside of your program's memory will lead to segfault. Passing Address that *is* in the bounds of your program's memory, but one not pointing at a struct in accordance with Struct layout form, will lead to undefined behavior (most likely junk values in Struct reference view).\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\n100 $: x\n200 $: y\nthis point ffi:buildStruct& $: point&\n\npoint& ffi:addressof $: addr\n\naddr point ffi:asStruct& $: addrPoint&\naddrPoint&.x leaves: x\naddrPoint&.y leaves: y\naddrPoint& toQuote leaves: '&\u27e8x=100_i32, y=200_i32\u27e9'\n```\n","primer":"creates and leaves Struct reference view for the given Address, according to Struct layout form.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[219,560],[215,560],[139,560]],"outbound":[]},{"name":"ffi:allocateUnion","effect":"( Slf -- Uv ):","markdown":"allocates Union view for the given Struct layout form.\n\nThis word is **unsafe**: the resulting Union view is in an undefined (uninitialized) state (may be zeroed out, contain junk, or both) before you (or the C code you pass it to) fills it with good values. Showing the uninitialized union to clients may expose your program to a whole class of security vulnerabilities.\n\n```\n[ chr char\n  ord u8\n] ffi:createLayout $: quux\n\nquux ffi:allocateUnion $: quuxUnion\nquuxUnion #chr 'A' entry:submit\nquuxUnion.ord leaves: 65\n\n\"Union toQuote avoids printing values, because that could\n cause a segfault/overflow in some cases, and would mostly\n output junk anyway.\"\nquuxUnion toQuote leaves: '(\u22c3 \u27eachr=char, ord=u8\u27eb)'\n```\n","primer":"allocates Union view for the given Struct layout form.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[215,561],[220,561]],"outbound":[]},{"name":"ffi:buildUnion","effect":"( Eb Slf -- Uv ):","markdown":"allocates and fills Union view with an entry by asking Entry block for any *one* entry out of those specified in Struct layout form, in the order they are specified in Struct layout form. If the union is no longer in use, it is freed by the GC automatically.\n\nEntry block must have at least one of the Struct layout form's fields defined. Otherwise, this word dies.\n\n```\n[ chr char\n  ord u8\n] ffi:createLayout $: quux\n\n[ 'A' $: chr\n  this quux ffi:buildUnion\n] val $: unionByChr\n\n[ 66 $: ord\n  this quux ffi:buildUnion\n] val $: unionByOrd\n\n[ 'A' $: chr\n  123 $: ord\n  this quux ffi:buildUnion\n] val $: unionBoth\n\nunionByChr.ord leaves: 65\nunionByOrd.chr leaves: 'B'\n\n\"'chr' is defined first, therefore, it is used rather\n than 'ord'\"\nunionBoth.chr leaves: 'A'\nunionBoth.ord leaves: 65\n```\n","primer":"allocates and fills Union view with an entry by asking Entry block for any *one* entry out of those specified in Struct layout form, in the order they are specified in Struct layout form.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[220,562],[218,562],[215,562]],"outbound":[]},{"name":"ffi:asUnion","effect":"( A Slf -- Uv ):","markdown":"creates and leaves a Union view for the given Address, according to Struct layout form.\n\nThis word is **unsafe**: it does not check whether Address points at something that is layed out according to Struct layout form. Passing 0 (none aka null pointer) for Address will lead to segfault. Passing Address that points outside of your program's memory will lead to segfault. Passing Address that *is* in the bounds of your program's memory, but one not pointing at a union in accordance with Struct layout form, will lead to undefined behavior (most likely junk values in Union view). Showing ill-formed results of this word to clients may expose your program to a whole class of security vulnerabilities.\n\n```\n[ chr char\n  ord u8\n] ffi:createLayout $: quux\n\n'A' $: chr\n\nthis quux ffi:buildUnion $: quuxUnion\n\nquuxUnion ffi:addressof $: addr\n\naddr quux ffi:asUnion $: addrUnion\naddrUnion.chr leaves: 'A'\naddrUnion.ord leaves: 65\n```\n","primer":"creates and leaves a Union view for the given Address, according to Struct layout form.","takes":[[2,0],[1,0]],"leaves":[[0,0]],"erefs":[[220,563],[215,563],[139,563]],"outbound":[]},{"name":"ffi:hole","effect":"( T/Oh -- H ):","markdown":"allocates garbage-collected memory for Hole that will hold a value of the given Type. If Other hole is passed, wraps that Other hole instead (this could be useful in C situations like `int**`)\n\nHoles are (just a bit) safer way of letting C write to a memory location. You first create the hole, then pass it to C, then read from the hole by opening it.\n\nNote: this word is **unsafe**: since we cannot check whether the hole was written to, reading from hole (opening it) before writing to it will result in undefined behavior.\n\n```\n\"\"\"\nvoid outputCInt(int* x)\n{\n  *x = 123;\n}\n\"\"\"\n\n#i32 ffi:hole $: intBox\n\nintBox outputCInt\nintBox open leaves: 123\n```\n","primer":"allocates garbage-collected memory for Hole that will hold a value of the given Type.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[221,564],[222,564],[223,564]],"outbound":[]},{"name":"ffi:box","effect":"( F T -- A ):","markdown":"allocates garbage-collected memory for Type, and writes Form there. Form must be of (or convertible to) Type; otherwise, this word dies. Leaves Address of the beginning of the allocated memory.\n\n```\n123 #i32 ffi:box $: ptr\nptr #i32 ffi:unbox leaves: 123\n```\n","primer":"allocates garbage-collected memory for Type, and writes Form there.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[139,565],[1,565],[222,565]],"outbound":[]},{"name":"ffi:unbox","effect":"( A T -- F ):","markdown":"interprets whatever Address points at as a value of the given Type, and leaves the matching Form. Inverse of `ffi:box`.\n\nThis word is **unsafe**: it does not check whether Address points at something that is of the given Type. Passing 0 (none aka null pointer) for Address will lead to segfault. Passing Address that points outside of your program's memory will lead to segfault. Passing Address that *is* in the bounds of your program's memory, but one not pointing at a value of the given Type, will lead to undefined behavior (most likely junk value of Form). Showing ill-formed results of this word to clients, or letting clients control Address or Type, may expose your program to a whole class of security vulnerabilities.\n\n```\n123 #i32 ffi:box $: ptr\nptr #i32 ffi:unbox leaves: 123\n```\n","primer":"interprets whatever Address points at as a value of the given Type, and leaves the matching Form.","takes":[[2,0],[0,0]],"leaves":[[1,0]],"erefs":[[222,566],[1,566],[139,566]],"outbound":[565]},{"name":"ffi:unsafeWrite","effect":"( A F T -- ):","markdown":"interprets Form as that of the given Type, and writes it at Address.\n\nThis word is **unsafe**: it does not check whether Address can be written to, whether there is enough memory to fully write Form, etc. Passing 0 (none aka null pointer) for Address will lead to segfault. Passing Address that points outside of your program's memory will lead to segfault. Passing Address that *is* in the bounds of your program's memory and can be written to may lead to undefined behavior.\n\n```\n#i32 ffi:hole $: myHole\nmyHole ffi:addressof $: holeAddr\nholeAddr 123 #i32 ffi:unsafeWrite\nmyHole open leaves: 123\n```\n","primer":"interprets Form as that of the given Type, and writes it at Address.","takes":[[2,0],[1,0],[0,0]],"leaves":[],"erefs":[[222,567],[1,567],[139,567]],"outbound":[]},{"name":"ffi:viewLayout","effect":"( Svf -- Slf ):","markdown":"leaves Struct layout form for the given Struct view form (an inline struct view, struct reference view, or union view).\n\n```\n[ x f32 y f32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct& $: point&\npoint ffi:allocateStruct~ $: point~\npoint ffi:allocateUnion $: pointU\n\npoint& ffi:viewLayout leaves: point\npoint~ ffi:viewLayout leaves: point\npointU ffi:viewLayout leaves: point\n```\n","primer":"leaves Struct layout form for the given Struct view form (an inline struct view, struct reference view, or union view).","takes":[[1,0]],"leaves":[[0,0]],"erefs":[[215,568],[224,568]],"outbound":[]},{"name":"ffi:sizeof","effect":"( T -- B ):","markdown":"leaves the size of Type, in Bytes.\n\n```\n#u8  ffi:sizeof leaves: 1\n#u16 ffi:sizeof leaves: 2\n#u32 ffi:sizeof leaves: 4\n#u64 ffi:sizeof leaves: 8\n```\n","primer":"leaves the size of Type, in Bytes.","takes":[[0,0]],"leaves":[[1,0]],"erefs":[[222,569],[225,569]],"outbound":[]},{"name":"ffi:addressof","effect":"( Svf/H -- A ):","markdown":"leaves Address of the given Struct view form (an inline struct view, struct reference view, or union view), or Hole in memory.\n\n```\n#i32 ffi:hole $: myHole\nmyHole ffi:addressof $: holeAddr\nholeAddr 123 #i32 ffi:unsafeWrite\nmyHole open leaves: 123\n```\n","primer":"leaves Address of the given Struct view form (an inline struct view, struct reference view, or union view), or Hole in memory.","takes":[[1,0],[2,0]],"leaves":[[0,0]],"erefs":[[139,570],[224,570],[221,570]],"outbound":[]}],"effects":[{"short":"N","long":"Name","words":[1,2,3,34,35,36,412,413,414,415,416,417,418,419,420,421,423]},{"short":"F","long":"Form","words":[1,2,3,4,7,17,18,19,20,21,23,24,25,26,27,28,34,71,197,198,199,229,230,231,234,245,246,247,248,249,250,257,258,260,268,339,340,341,342,372,373,375,376,377,379,387,391,392,393,395,396,397,398,399,401,402,403,404,405,406,407,408,409,410,411,412,413,414,416,417,419,423,464,465,466,468,472,475,488,489,528,529,546,547,548,549,550,551,565,566,567]},{"short":"Qm","long":"Quote message","words":[4]},{"short":"I","long":"Id","words":[5,552,553]},{"short":"Tf","long":"Top form","words":[6]},{"short":"B","long":"Block","words":[6,7,8,9,10,11,12,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,32,33,36,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,89,90,91,92,93,94,97,104,117,118,119,121,122,124,125,126,127,128,129,130,131,132,165,166,168,173,181,183,189,190,191,192,193,194,195,196,228,244,253,254,262,271,272,360,361,362,365,368,370,371,378,380,381,387,388,392,412,413,419,421,422,423,424,425,426,427,428,429,430,431,432,433,434,450,456,457,460,461,462,463,464,465,467,468,470,479,480,481,482,484,485,486,487,490,491,492,493,494,495,496,498,500]},{"short":"N","long":"N","words":[11,12,14,15,89,90,91,92,123,124,207,208,433,434,450,456,457]},{"short":"S","long":"Stack","words":[13,117,165,365,369,375,376,378]},{"short":"Lb","long":"List block","words":[15,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,105,106,107,108,109,110,111,112,113,114,115,116,334]},{"short":"X","long":"X","words":[22,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,253,254,303,527,528]},{"short":"Y","long":"Y","words":[22,253,254,303,527,528]},{"short":"Sb","long":"Status boolean","words":[27,28]},{"short":"Q","long":"Quote","words":[27,28,29,98,99,100,101,232,233,234,235,328,329,330,331,332,388,389,390,403,431,432,433,434,449,450,452,453,454,455,473,474,482]},{"short":"Fq","long":"Fragment quote","words":[27,28]},{"short":"Bf","long":"Begin form","words":[29]},{"short":"Bq","long":"Begin quote","words":[29]},{"short":"Ef","long":"End form","words":[29]},{"short":"Eq","long":"End quote","words":[29]},{"short":"C","long":"Child","words":[30,31,478]},{"short":"P","long":"Parent","words":[30,31,361,478]},{"short":"F","long":"Friend","words":[32,479,480]},{"short":"Cb","long":"Child block","words":[33]},{"short":"Db","long":"Dictionary block","words":[34,35,36,487]},{"short":"S","long":"Source","words":[37,38,39,75,543]},{"short":"B","long":"Body","words":[37,38,39]},{"short":"Rb","long":"Result block","words":[53,54,57,58,61,62,63]},{"short":"Mlb","long":"Modified list block","words":[59]},{"short":"M","long":"Memo","words":[65]},{"short":"A","long":"Amount","words":[66,67]},{"short":"Z","long":"Zipped","words":[72,74]},{"short":"A","long":"A","words":[72,73,74,178,179,180,200,201,202,203,218,219,220,221,222,223,224,225,233,249,250,251,252,382,384,440]},{"short":"B","long":"B","words":[72,73,74,95,96,178,179,180,200,201,202,203,218,219,220,221,225,233,249,250,251,252,382,384,440]},{"short":"D","long":"Default","words":[73,74]},{"short":"I","long":"Instance","words":[75,76,173,380]},{"short":"D","long":"Destination","words":[75,543]},{"short":"Tb","long":"Transformation block","words":[82,83,84,85,86,87,88]},{"short":"P","long":"Product","words":[87,437]},{"short":"Gl","long":"Group list","words":[93,94]},{"short":"Gb","long":"Grouper block","words":[93,94]},{"short":"Rb","long":"Range block","words":[95,96]},{"short":"E","long":"E","words":[95,96]},{"short":"Bi","long":"Begin index","words":[97]},{"short":"Ei","long":"End index","words":[97]},{"short":"Bs","long":"Block slice","words":[97]},{"short":"Fl","long":"Form list","words":[98,99,100,101]},{"short":"Df","long":"Delimiter form","words":[99]},{"short":"Sfb","long":"Skipped forms block","words":[105,106,107,108,109,110,111,112,113,114,115,116]},{"short":"C","long":"Condition","words":[105,106,107,108,109,110,111,112,113,114,115,116,186,189,190,191,192]},{"short":"L","long":"List","words":[117,118,123]},{"short":"Cb","long":"Comparator block","words":[119,470]},{"short":"Dlb","long":"Decimal list block","words":[120]},{"short":"Mb","long":"Mapper block","words":[121,122]},{"short":"Fab","long":"Forms around block","words":[123]},{"short":"Rb","long":"Ring block","words":[124]},{"short":"Rf","long":"Random form","words":[125]},{"short":"C","long":"Count","words":[126,127,193,194]},{"short":"S","long":"Samples","words":[126,127]},{"short":"Dfb","long":"Deeply flattened block","words":[128,129]},{"short":"R","long":"Replacement","words":[130,131,132]},{"short":"P","long":"Pattern","words":[130,131,132]},{"short":"Cw","long":"Console width","words":[133,506]},{"short":"Ch","long":"Console height","words":[134,506]},{"short":"T","long":"Top","words":[166,245,246,247,248]},{"short":"Lb","long":"Literal block","words":[168]},{"short":"W","long":"Word","words":[170,394,395,396,400]},{"short":"D","long":"Determiner","words":[174,175,176,177,382,383]},{"short":"T","long":"True","words":[175,383]},{"short":"F","long":"False","words":[175,383]},{"short":"Tb","long":"True branch","words":[176,177]},{"short":"Ib","long":"Iteration body","words":[185,187,188]},{"short":"Sh","long":"Start handle","words":[185,186]},{"short":"Nh","long":"Next handle","words":[185]},{"short":"Bh","long":"Break handle","words":[185]},{"short":"Bb","long":"Body block","words":[186]},{"short":"Cb","long":"Control block","words":[186]},{"short":"N","long":"Note","words":[195,196]},{"short":"M","long":"Minimum","words":[202]},{"short":"M","long":"Maximum","words":[203]},{"short":"N","long":"Number","words":[204,205,206]},{"short":"L","long":"Low","words":[204,205,206]},{"short":"H","long":"High","words":[204,205,206]},{"short":"Av","long":"Absolute value","words":[208]},{"short":"R","long":"Reciprocal","words":[209]},{"short":"D","long":"Decimal","words":[209,210,211,212,213,214,215,235,401,441,442,443,444,445]},{"short":"Rb","long":"Range begin","words":[212,213,214,215]},{"short":"Re","long":"Range end","words":[212,213,214,215]},{"short":"P","long":"Percentage","words":[212,213]},{"short":"Hp","long":"Human percentage","words":[214,215]},{"short":"Air","long":"Angle in radians","words":[216,217,446,447]},{"short":"Aid","long":"Angle in degrees","words":[216,217]},{"short":"Af","long":"A form","words":[251,252]},{"short":"Bf","long":"B form","words":[251,252]},{"short":"Mt","long":"Monotonic time","words":[262]},{"short":"E","long":"Entries","words":[265,266,267]},{"short":"Cl","long":"Case list","words":[268]},{"short":"Cb","long":"Case body","words":[268]},{"short":"B","long":"Boolean","words":[270,405,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,537]},{"short":"G","long":"Group","words":[270]},{"short":"Dq","long":"Description quote","words":[271,488,489]},{"short":"Rh","long":"Result hole","words":[293,294,295,296]},{"short":"F","long":"Flags","words":[301,302,303,304]},{"short":"T","long":"Title","words":[303]},{"short":"P","long":"Pointer","words":[303,323]},{"short":"W","long":"Width","words":[303,332]},{"short":"H","long":"Height","words":[303,332]},{"short":"I","long":"Index","words":[304]},{"short":"Wp","long":"Window pointer","words":[304]},{"short":"S","long":"Status","words":[322]},{"short":"Fp","long":"Font pointer","words":[326,328,329,330,331,332]},{"short":"Fn","long":"File name","words":[326]},{"short":"Ps","long":"Point size","words":[326]},{"short":"Fp","long":"Foint pointer","words":[327]},{"short":"Wh","long":"Width hole","words":[328]},{"short":"Hh","long":"Height hole","words":[328]},{"short":"Sp","long":"Surface pointer","words":[329,330,331]},{"short":"Fc","long":"Foreground color","words":[330,331]},{"short":"Bc","long":"Background color","words":[330]},{"short":"C","long":"Color","words":[335,336,409]},{"short":"Pf","long":"Prompt form","words":[343]},{"short":"Aq","long":"Answer quote","words":[343,344]},{"short":"Cb","long":"Configuration block","words":[344]},{"short":"Eo","long":"Error object","words":[345,471,476]},{"short":"R","long":"Reading","words":[346]},{"short":"D","long":"Duration","words":[347,507]},{"short":"Ec","long":"Exit code","words":[348]},{"short":"Cf","long":"Color form","words":[349,350,351,352,353,354,355,356,357,358]},{"short":"R","long":"Red","words":[349,350]},{"short":"G","long":"Green","words":[349,350]},{"short":"B","long":"Blue","words":[349,350]},{"short":"S","long":"Saturation","words":[351,352,353,354]},{"short":"H","long":"Hue","words":[351,352,353,354,355,356]},{"short":"L","long":"Lightness","words":[351,352,355,356]},{"short":"V","long":"Value","words":[353,354]},{"short":"C","long":"Chroma","words":[355,356]},{"short":"A","long":"Alpha","words":[357,358]},{"short":"Cf","long":"Color from","words":[359]},{"short":"Cc","long":"Closest color","words":[359]},{"short":"Pb","long":"Palette block","words":[359]},{"short":"P","long":"Prototype","words":[360]},{"short":"A","long":"Address","words":[362,557,560,563,565,566,567,570]},{"short":"Cb","long":"Continuations block","words":[363]},{"short":"Cb","long":"Continuation block","words":[364]},{"short":"C","long":"Continuation","words":[365,366,367]},{"short":"Cb","long":"Code block","words":[366]},{"short":"Sb","long":"Stack block","words":[367]},{"short":"Si","long":"Shallow instance","words":[381]},{"short":"Bi","long":"Begin indices","words":[388]},{"short":"Pf","long":"Pattern form","words":[388]},{"short":"Pq","long":"Pattern quote","words":[388,474]},{"short":"Uq","long":"Uppercase quote","words":[390]},{"short":"Qw","long":"Quoted word","words":[398,400]},{"short":"B","long":"Builtin","words":[407]},{"short":"B","long":"Byteslice","words":[411,473,545]},{"short":"Ss","long":"Submittable store","words":[414]},{"short":"Rs","long":"Readable store","words":[415,416,417,418,420]},{"short":"C","long":"Caller","words":[418]},{"short":"P","long":"Path","words":[423,538,541,542]},{"short":"Nb","long":"Name block","words":[424,425,427]},{"short":"Vb","long":"Value block","words":[426]},{"short":"Ec","long":"Entry count","words":[428]},{"short":"C","long":"Copy","words":[429]},{"short":"O","long":"Other","words":[430]},{"short":"E","long":"Element","words":[431,432,461,462]},{"short":"Bf","long":"Byteslice form","words":[431,432,433,434,450,490,491,492,495,496,497,498,499,500]},{"short":"Eb","long":"Elements block","words":[433]},{"short":"Rq","long":"Result quote","words":[433,434]},{"short":"Rbf","long":"Result byteslice form","words":[433,434]},{"short":"S","long":"Sum","words":[435]},{"short":"D","long":"Difference","words":[436]},{"short":"Q","long":"Quotient","words":[438]},{"short":"M","long":"Modulo","words":[439]},{"short":"R","long":"Result","words":[440]},{"short":"Rd","long":"Rounded decimal","words":[441,442,443,444]},{"short":"R","long":"Root","words":[445]},{"short":"Dc","long":"Decimal cosine","words":[446]},{"short":"Ds","long":"Decimal sine","words":[447]},{"short":"Rd","long":"Random decimal","words":[448]},{"short":"Pb","long":"Part before","words":[449]},{"short":"Pa","long":"Part after","words":[449]},{"short":"Sp","long":"Slice point","words":[449]},{"short":"Uc","long":"Unicode codepoint","words":[451,452]},{"short":"Pq","long":"Padding quote","words":[453,454]},{"short":"Tl","long":"Total length","words":[453,454,455]},{"short":"Jq","long":"Justified quote","words":[453,454]},{"short":"Eq","long":"Ellipsis quote","words":[455]},{"short":"Fq","long":"Fit quote","words":[455]},{"short":"Lh","long":"Left half","words":[460]},{"short":"Rh","long":"Right half","words":[460]},{"short":"Eb","long":"Element block","words":[463]},{"short":"Bf","long":"Block form","words":[467]},{"short":"Vf","long":"Value form","words":[467]},{"short":"Db","long":"Donor block","words":[469]},{"short":"Rb","long":"Recipient block","words":[469]},{"short":"Dq","long":"Details quote","words":[471]},{"short":"Qr","long":"Quote representation","words":[472]},{"short":"Sq","long":"Source quote","words":[474]},{"short":"Rq","long":"Resulting quote","words":[474]},{"short":"Eq","long":"Effect quote","words":[475]},{"short":"D","long":"Details","words":[476]},{"short":"Fl","long":"Friend list","words":[481]},{"short":"O","long":"Orphan","words":[483]},{"short":"Tb","long":"Tape block","words":[486]},{"short":"Bf","long":"Byteslice forms","words":[493,494]},{"short":"B","long":"Brotli","words":[497,499]},{"short":"Cq","long":"Char quote","words":[526]},{"short":"Pq","long":"Path quote","words":[532,533,534,535,536]},{"short":"Bp","long":"Base path","words":[538]},{"short":"Cp","long":"Child path","words":[538]},{"short":"Wd","long":"Working directory","words":[539]},{"short":"Hd","long":"Home directory","words":[540]},{"short":"C","long":"Contents","words":[544]},{"short":"F","long":"File","words":[544]},{"short":"Cq","long":"Content quote","words":[545]},{"short":"Fp","long":"File path","words":[545]},{"short":"Lf","long":"Library form","words":[552,553]},{"short":"Slf","long":"Struct layout form","words":[554,555,556,557,558,559,560,561,562,563,568]},{"short":"Lb","long":"Layout block","words":[554]},{"short":"Isv","long":"Inline struct view","words":[555,556,557]},{"short":"Eb","long":"Entry block","words":[556,559,562]},{"short":"Srv","long":"Struct reference view","words":[558,559,560]},{"short":"Uv","long":"Union view","words":[561,562,563]},{"short":"H","long":"Hole","words":[564,570]},{"short":"T","long":"Type","words":[564,565,566,567,569]},{"short":"Oh","long":"Other hole","words":[564]},{"short":"Svf","long":"Struct view form","words":[568,570]},{"short":"B","long":"Bytes","words":[569]}]}
