{
  "words": {
    "@:": {
      "name": "@:",
      "desc": "( F @: N -- ): creates an opener entry with the given\n Name in caller. Submits Form to the entry. Opener entries,\n when resolved to and opened, in turn **open** their\n corresponding Form.\n\n```\n\"Blocks are evaluated (opened) when the opener entry\nthey're stored under is opened.\"\n[ 1 2 + ] @: getThree\ngetThree leaves: [ 3 ]\n\n\"Builtins also get opened when under an opener entry.\"\n#+ here @: myAddAlias\n1 2 myAddAlias leaves: [ 3 ]\n\n\"Any other form is left as-is, even if it is a word.\"\n3 @: litThree\n#+ @: litPlus\nlitThree leaves: [ 3 ]\nlitPlus leaves: [ + ]\n```\n\n"
    },
    "$:": {
      "name": "$:",
      "desc": "( F $: N -- ): creates a pusher entry with the given\n Name in caller. Submits Form to the entry. Pusher entries,\n when resolved to and opened, **push** their corresponding\n Form onto the active stack.\n\n```\n100 $: x\n200 $: y\n\nx leaves: 100\ny leaves: 200\n\n[ 1 2 + ] $: getThree\n\n\"Nope! In this case, use `@:` if you want the block to be\n opened (evaluated).\"\ngetThree leaves: [ 1 2 + ]\n```\n\n"
    },
    "=:": {
      "name": "=:",
      "desc": "( F =: N -- ): submits Form to an entry with the given\n Name.\n\nThe entry must exist already, being defined by `$:`, `@:`,\nor otherwise. Entry type is disregarded (i.e. it doesn't\nmatter whether it's an opener or a pusher entry). More\nimportantly, *entry type is preserved.*\n\n```\n\"Note, by the way, that order doesn't matter. What\n matters is for `x` to be there at the time of calling\n `addOneToX`. In other words, `addOneToX` must be able to\n find `x` when it's opened.\"\n\n100 $: x\n\n[ x 1 + =: x ] @: addOneToX\n\nx leaves: 100\naddOneToX\nx leaves: 101\n\"...\"\n```\n\n"
    },
    "2die": {
      "name": "2die",
      "desc": "( Qm F -- ): enquotes Form, stitches it to the end of\n Quote message, and dies with the resulting quote set as\n the death message.\n\n```\n'expected foobar, got: ' 100 2die \"Sorry: expected foobar, got: 100.\"\n```\n\n"
    },
    "needsCapability:": {
      "name": "needsCapability:",
      "desc": "( needsCapability: I -- ): ensures that the frontend has enabled\nthe capability with the specified Id. Dies if such a capability\nisn't enabled, or if Id isn't a capability id at all."
    },
    "withColorEcho": {
      "name": "withColorEcho",
      "desc": "( F -- ): echoes Form like `withColorAppendEcho`, then\n echoes a newline character.\n\n```\n0 100 0 rgb withEchoFg\n100 0 0 rgb withEchoBg\n  'Hi!' withColorEcho\ndropEchoBg\n  'Bye!' withColorEcho\ndropEchoFg\n```\n\n"
    },
    "withEmphasisEcho": {
      "name": "withEmphasisEcho",
      "desc": "( F -- ): echoes Form like `withEmphasisAppendEcho`,\nthen echoes a newline character."
    },
    "withReverseEcho": {
      "name": "withReverseEcho",
      "desc": "( F -- ): echoes Form like `withReverseAppendEcho`, then\nechoes a newline character."
    },
    "vals": {
      "name": "vals",
      "desc": "( B -- S ): activates an empty Stack for the duration\n of Block.\n\n```\n[ 1 2 3 ] vals leaves: [ 1 2 3 ]\n[ (1 2 + 2 *) 'hello' ] vals leaves: [ 6 'hello' ]\n```\n\n"
    },
    "val": {
      "name": "val",
      "desc": "( B -- T ): activates an empty stack for the duration of Block,\n and leaves Top form in the stack. Dies if none.\n\n```\n[ 1 2 3 ] val leaves: 3\n[ 'foo' 'bar' ~ ] val leaves: 'foobar'\n```\n\n"
    },
    "2val": {
      "name": "2val",
      "desc": "( B1 B2 -- T1 T2 ): activates individual empty stacks for each\n of the two Blocks, and leaves their corresponding Top forms.\n\n```\n[ 1 2 + ] [ 3 4 + ] 2val leaves: [ 3 7 ]\n```\n\n"
    },
    "thruLitBlock": {
      "name": "thruLitBlock",
      "desc": "( B -- Lb ): leaves Literal block after cursor in Block. If\nform after cursor isn't a block, encloses it and opens it with\nan empty stack, Block being the enclosing block's parent, and\nfinally asserts the resulting form is a block."
    },
    "thruWord": {
      "name": "thruWord",
      "desc": "( B -- W/dies ): same as `thru asWord`."
    },
    "thruWord:": {
      "name": "thruWord:",
      "desc": "( B W -- /dies ): same as `thruWord`, but also checks if\n the `thru`-ed word is the same as Word.\n\n```\n[ ahead thruVal $: begin\n  ahead thruWord: to:\n  ahead thruVal $: end\n\n  begin to: end\n] @: from:\n\nfrom: 1 to: 100 leaves: [ 1 2 3 \"…\" 98 99 100 ]\n```\n\n"
    },
    "thruVal": {
      "name": "thruVal",
      "desc": "( B -- F' ): same as `thruBlock val`."
    },
    "thruVals": {
      "name": "thruVals",
      "desc": "( B -- [ ... F' ... ] ): same as `thruBlock vals`."
    },
    "obj": {
      "name": "obj",
      "desc": "( B -- I ): like `do`, but leaves the resulting\n Instance of Block. Equivalent to `[ <Block> this ] do`.\n\n```\n[ 100 $: x 200 $: y ] obj \"[ 100 $: x 200 $: y · ${x :: 100} {y :: 200} ]\"\n\nbi: [ .x ] [ .y ] leaves: [ 100 200 ]\n```\n\n"
    },
    "br:": {
      "name": "br:",
      "desc": "( D br: T F -- ? ): infix version of `br`.\n\n```\n(0 randTo: 100) odd? br:\n  [ 'Yay!' echo ]\n  [ 'Nay!' echo ]\n\n\"Say no to repetition!\"\n(0 randTo: 100) odd? (br: 'Yay!' 'Nay!') echo\n```\n\n"
    },
    "=>": {
      "name": "=>",
      "desc": "( D => Tb -- ? ): opens True branch form if Determiner\n is truthy.\n\n```\n(0 randTo: 100) even? => [ 'Yay!' echo ]\n```\n\n"
    },
    "~>": {
      "name": "~>",
      "desc": "( D ~> Tb -- ? ): opens True branch form if Determiner\n is truthy.\n\nIf Determiner is a block, creates a copy of the stack and\nopens Determiner with that stack. If Determiner leaves a\ntruthy form, opens True branch form with the old stack.\nOtherwise, does nothing.\n\n```\n100 even? ~> 1 leaves: [ 1 ]\n101 even? ~> 1 leaves: [ ]\n\n100 ([ even? ] ~> [ 2 * ]) leaves: [ 200 ]\n101 ([ even? ] ~> [ 2 * ]) leaves: [ 101 ]\n\n2 4 ([ * even? ] ~> +) leaves: 6\n5 5 ([ * even? ] ~> +) leaves: [ 5 5 ]\n```\n\n"
    },
    "and": {
      "name": "and",
      "desc": "( A B -- A/false ): leaves whether both A and B are truthy.\n\nSupports short-circuiting. Remember that in Novika, only `false`\nitself is falsey. Everything else is truthy.\n\n```\n(false false and) leaves: false\n(true false and) leaves: false\n(false true and) leaves: false\n(true true and) leaves: true\n\n(100 200 and) leaves: true\n(100 false and) leaves: false\n\n[ 100 even? ] [ 200 odd? ] and leaves: false\n```\n\n"
    },
    "or": {
      "name": "or",
      "desc": "( A B -- true/A ): leaves whether A or B or both are truthy.\n\nSupports short-circuiting. Remember that in Novika, only `false`\nitself is falsey. Everything else is truthy.\n\n```\n(false false or) leaves: false\n(true false or) leaves: true\n(false true or) leaves: true\n(true true or) leaves: true\n\n(100 200 or) leaves: true\n(100 false or) leaves: true\n\n[ 100 even? ] [ 200 odd? ] or leaves: false\n```\n\n"
    },
    "neither?": {
      "name": "neither?",
      "desc": "( A B -- true/A ): same as `or not`, leaves whether neither\n A nor B is truthy.\n\nSupports short-circuiting. Remember that in Novika, only `false`\nitself is falsey. Everything else is truthy.\n\n```\n[ 100 odd? ] [ 201 even? ] neither? leaves: true\n```\n\n"
    },
    "continues": {
      "name": "continues",
      "desc": "( B -- ): makes shallow copy of continuations stack the\nstack for the duration of Block. Replaces substrate of the\ncontinuation stack with the modified shallow copy after\nBlock is opened."
    },
    "repeat": {
      "name": "repeat",
      "desc": "( -- ): executes caller again. Looping primitive. Too low-\n level for users, prefer not to use (use `loop` instead).\n Beware that it does not re-instantiate the block.\n\n```\n[\n  'Looping indefinitely, yay!' echo\n\n  repeat\n] do\n```\n\n"
    },
    "dropContinuationsUntil": {
      "name": "dropContinuationsUntil",
      "desc": "( B -- ): drops all continuations before (and including)\nthose for which Block leaves truthy value when opened with\nthe continuation on top of an empty stack, coming from the\nright-hand side."
    },
    "^": {
      "name": "^",
      "desc": "( -- ): closes blocks all the way up to, and including,\nits *opener's parent*."
    },
    "createLoop": {
      "name": "createLoop",
      "desc": "( Ib -- Sh Bh Nh ): takes an Iteration body block and\n leaves three handles: Start handle to start the loop,\n Next handle to continue the loop, and Break handle to\n break the loop.\n\n```\n[ '> ' readLine not => nextCycle\n  [ 'quit' quitLoop\n    'next' nextCycle\n  ] choose\n  'You have entered: ' swap ~ echo\n] createLoop\n  @: nextCycle\n  @: quitLoop\n  @: startLoop\n\n'Hello! Type `quit` to quit!' echo\n  startLoop\n'Bye!' echo\n```\n\n"
    },
    "createDetachedLoop": {
      "name": "createDetachedLoop",
      "desc": "( Bb C Cb -- Sh ): defines `break` and `next` for a Body\n block that is being evaluated indirectly by a Control block,\n and only if Condition leaves a truthy value on top of the\n stack it hydrated. `next` resumes the Control block.\n Leaves Start handle to start the loop.\n\n```\n\"Body block is the 'client' block of sorts:\"\n[ dup even? (br: ' is even!' ' is odd!') ~ echo\n] $: bodyBlock\n\n\n0 $: n\n\n\"Control block chooses whether, and how to run\nthe body block.\"\n[ n enclose bodyBlock hydrate\n  n 1 + =: n\n] $: controlBlock\n\n\"Condition block chooses whether to stop looping.\"\n[ n 5 <\n] $: conditionBlock\n\nbodyBlock conditionBlock controlBlock createDetachedLoop\n  @: startLoop\n\nstartLoop\n\n\"STDOUT: 0 is even!⏎\"\n\"STDOUT: 1 is odd!⏎\"\n\"STDOUT: 2 is even!⏎\"\n\"STDOUT: 3 is odd!⏎\"\n\"STDOUT: 4 is even!⏎\"\n\nn leaves: 5\n```\n\n"
    },
    "loop": {
      "name": "loop",
      "desc": "( Ib -- ): basic infinite loop over an Iteration body block.\n `break` and `next` are available in the block. A new\n stack created for each iteration.\n\n```\n'Hello! Type `quit` to quit!' echo\n\n[ '> ' readLine not => next\n  [ 'quit' break\n    'next' next\n  ] choose\n  'You have entered: ' swap ~ echo\n] loop\n\n'Bye!' echo\n```\n\n"
    },
    "loop:": {
      "name": "loop:",
      "desc": "( loop: Ib -- ): prefix version of `loop`."
    },
    "while": {
      "name": "while",
      "desc": "( C B -- ): hydrates an empty stack with Condition; if ToS\n is truthy afterwards, Block is opened over an empty stack.\n Repeats until ToS is false. Similar to `loop`, words `break`\n and `next` are available in Block.\n\n```\n1 to: 10 sample: 10 p $: numbers\n\n0 $: index\n\nwhile: [ numbers index fromLeft even? ]\n[\n  index 1 + =: index\n  index (numbers count) = => [\n    'No odd numbers :(' echo\n    1 bye\n  ]\n]\n\n'First odd number is: ' (numbers index fromLeft) ~ echo\n```\n\n"
    },
    "while:": {
      "name": "while:",
      "desc": "( while: C B -- ): prefix version of `while`."
    },
    "until": {
      "name": "until",
      "desc": "( C B -- ): inverse of `while` (opens Block while Condition\n is **false**), for more info see `while`.\n\n```\n1 to: 10 sample: 10 p $: numbers\n\n0 $: index\n\nuntil: [ numbers index fromLeft odd? ]\n[\n  index 1 + =: index\n  index (numbers count) = => [\n    'No odd numbers :(' echo\n    1 bye\n  ]\n]\n\n'First odd number is: ' (numbers index fromLeft) ~ echo\n```\n\n"
    },
    "until:": {
      "name": "until:",
      "desc": "( until: C B -- ): prefix version of `until`."
    },
    "times": {
      "name": "times",
      "desc": "( C B -- ): opens Block Count times. For each iteration\n of Block, a new stack block is activated with current Count\n on top. `break` and `next` available.\n\n```\n16 times: [\n  even? ~> next\n  9 >= ~> break\n  echo\n]\n\n\"STDOUT: 1⏎\"\n\"STDOUT: 3⏎\"\n\"STDOUT: 5⏎\"\n\"STDOUT: 7⏎\"\n```\n\n"
    },
    "times:": {
      "name": "times:",
      "desc": "( C times: B -- ): infix version of `times`."
    },
    "compiledTimes": {
      "name": "compiledTimes",
      "desc": "( N B -- ): **unsafe** `times` alternative for when you\n *really* need to iterate a lot.\n\nThis word basically strips off all steps in the `createDetachedLoop`\n(aka structured control flow) abstraction ladder.\n\nInternally, it's a bit like your Block being followed by a GOTO\nback to the beginning, plus a counter *on the stack*.\n\nNote that the loop is *compiled* from a template when you use\nthis word. **This means that opening this word multiple times\nin a row is inefficient**, as such compilation is expensive.\nHowever, if you need to *iterate* quickly, you can try using\nthis word.\n\nThe stack your Block is given is *not* owned by you. You must\nnot leave junk, and you must not drop the index. The effect\nof your block **must** be `( I -- I )`.\n\n`next` and `break` are **not** supported.\n\n```\n10_000 compiledTimes: [ $: index\n  index 2 * echo\n  index\n]\n```\n\n"
    },
    "compiledTimes:": {
      "name": "compiledTimes:",
      "desc": "( N compiledTimes: B -- ): infix version of `compiledTimes`.\n\n```\n0 $: acc\n100_000 compiledTimes: [ \"( I -- I )\"\n  dup acc + =: acc\n]\nacc echo \"STDOUT: 5000050000⏎\"\n```\n\n"
    },
    "2asc": {
      "name": "2asc",
      "desc": "( A B -- Min Max ): sorts two decimals, A and B, in\n ascending (min to max) order. In case A = B, order is\n unchanged.\n\n```\n1 2 2asc leaves: [ 1 2 ]\n2 1 2asc leaves: [ 1 2 ]\n```\n\n"
    },
    "2desc": {
      "name": "2desc",
      "desc": "( A B -- Max Min ): sorts two decimals, A and B, in\n descending (max to min) order. In case A = B, order is\n unchanged.\n\n```\n1 2 2desc leaves: [ 2 1 ]\n2 1 2desc leaves: [ 2 1 ]\n```\n\n"
    },
    "2min": {
      "name": "2min",
      "desc": "( A B -- M ): leaves Minimum of two decimals, A and B.\n\n```\n3 10 2min leaves: 3\n```\n\n"
    },
    "2max": {
      "name": "2max",
      "desc": "( A B -- M ): leaves Maximum of two decimals, A and B.\n\n```\n3 10 2max leaves: 10\n```\n\n"
    },
    "randFromTo": {
      "name": "randFromTo",
      "desc": "( L H -- N ): generates random Number between Low and\nHigh, *including* both Low and High."
    },
    "randTo:": {
      "name": "randTo:",
      "desc": "( L randTo: H -- N ): infix version of `randFromTo`."
    },
    "clamp:": {
      "name": "clamp:",
      "desc": "( N clamp: L H -- N/L/H ): clamps Number between Low and\n High: if Number is less than Low, leaves low; if Number\n is greater than High, leaves High.\n\n```\n1 clamp: 5 10 leaves: 5\n5 clamp: 5 10 leaves: 5\n7 clamp: 5 10 leaves: 7\n10 clamp: 5 10 leaves: 10\n100 clamp: 5 10 leaves: 10\n```\n\n"
    },
    "flipSign": {
      "name": "flipSign",
      "desc": "( N -- -N ): flips the sign of N.\n\n```\n-1 flipSign leaves: 1\n0 flipSign leaves: 0\n1 flipSign leaves: -1\n```\n\n"
    },
    "abs": {
      "name": "abs",
      "desc": "( N -- Av ): leaves the Absolute value of N.\n\n```\n0 abs leaves: 0\n100 abs leaves: 100\n-100 abs leaves: 100\n```\n\n"
    },
    "%": {
      "name": "%",
      "desc": "( D -- R ): leaves Reciprocal of Decimal (`1/D`). Leaves\n 0 if Decimal is 0. Note: as in `12 % 12 *`, this may not\n always leave `1` because of math imprecisions.\n\n```\n0 % leaves: 0\n20 % leaves: 0.05\n100 % 100 * leaves: 1\n```\n\n"
    },
    "rangesMap": {
      "name": "rangesMap",
      "desc": "( D R1b R1e R2b R2e -- D' ): leaves Decimal in range\n [R1b; R1e] mapped to the range [R2b; R2e].\n\nNote: Decimal is clamped into the range [R1b; R1e].\nNote: implementation taken from https://www.arduino.cc/reference/en/language/functions/math/map/\n\n```\n100  0 100  1.5 255  rangesMap leaves: 255\n  0  0 100  1.5 255  rangesMap leaves: 1.5\n\n\"Reverse range:\"\n\n10  0 100  100 0  rangesMap leaves: 90\n```\n\n"
    },
    "mapFromRange:": {
      "name": "mapFromRange:",
      "desc": "( D mapFromRange: R1b R1e toRange: R2b R2e -- D' ): infix\n version of `rangesMap`.\n\n```\n100 mapFromRange: 0 100 toRange: 1.5 255 leaves: [ 255 ]\n  0 mapFromRange: 0 100 toRange: 1.5 255 leaves: [ 1.5 ]\n```\n\n"
    },
    "mapToRange": {
      "name": "mapToRange",
      "desc": "( P Rb Re -- D ): leaves Decimal in range [Range begin; Range end]\n corresponding to the given Percentage (in [0; 1]).\n\nSee `rangesMap` for more details.\n\n```\n\"...etc..\"\n-100  0 100  mapToRange leaves: 0\n   0  0 100  mapToRange leaves: 0\n 0.1  0 100  mapToRange leaves: 10\n   1  0 100  mapToRange leaves: 100\n   2  0 100  mapToRange leaves: 100\n\"...etc..\"\n```\n\n"
    },
    "mapToRange:": {
      "name": "mapToRange:",
      "desc": "( P mapToRange: Rb Re -- D ): infix version of `mapToRange`."
    },
    "%->:": {
      "name": "%->:",
      "desc": "( Hp %->: Rb Re -- D ): leaves Decimal, which is Human\n percentage (0-100) mapped to [Range begin; Range end]\n range. Human percentage is clamped to 0-100.\n\n```\n\"What is 30% of John's salary, $10 000? \"\n30 %->: 0   10_000  leaves: 3000\n60 %->: 64  255     leaves: 178.6\n```\n\n"
    },
    "->%:": {
      "name": "->%:",
      "desc": "( D ->%: Rb Re -- Hp ): leaves Human percentage for\n Decimal in the given range [Range begin; Range end].\n Inverse of `%->:`.\n\n```\n100 ->%: 0 256 leaves: 39.0625\n\n\"Can be checked like so:\"\n39.0625 %->: 0 256 leaves: 100\n```\n\n"
    },
    "deg->rad": {
      "name": "deg->rad",
      "desc": "( Aid -- Air ): leaves Angle in radians for the given\nAngle in degrees."
    },
    "rad->deg": {
      "name": "rad->deg",
      "desc": "( Air -- Aid ): leaves Angle in degrees for the given\nAngle in radians."
    },
    "approx=": {
      "name": "approx=",
      "desc": "( A B -- B ): leaves Boolean for whether A and B are\napproximately equal (their difference is less than or\nequal to `EPSILON`)."
    },
    "echo": {
      "name": "echo",
      "desc": "( F -- ): enquotes Form, and appends the resulting quote,\nfollowed by newline, to the standard output stream."
    },
    "help": {
      "name": "help",
      "desc": "( help F -- ): echoes help for Form. If form is a word,\nfetches it in caller first."
    },
    "2echo": {
      "name": "2echo",
      "desc": "( F1 F2 -- ): echoes a pair of Forms."
    },
    "p": {
      "name": "p",
      "desc": "( F -- F ): echoes a Form but leaves it on the stack."
    },
    "2p": {
      "name": "2p",
      "desc": "( F1 F2 -- F1 F2 ): echoes a pair of Forms but leaves\nthem on the stack."
    },
    "measure": {
      "name": "measure",
      "desc": "( B -- Mt ): leaves Monotonic time difference in\nmilliseconds for Block (leaves the time Block took to\nexecute, in ms)."
    },
    "2drop": {
      "name": "2drop",
      "desc": "( A B -- ): drops a pair of forms.\n\n```\n1 2 2drop leaves: [ ]\n```\n\n"
    },
    "nip": {
      "name": "nip",
      "desc": "( A B -- B ): drops a form under the top.\n\n```\n1 2 nip leaves: [ 2 ]\n```\n\n"
    },
    "nup": {
      "name": "nup",
      "desc": "( A B -- A A B ): duplicates a form under the top.\n\n```\n1 2 nup leaves: [ 1 1 2 ]\n```\n\n"
    },
    "over": {
      "name": "over",
      "desc": "( A B -- A B A ): duplicates a form over the top.\n\n```\n1 2 over leaves: [ 1 2 1 ]\n```\n\n"
    },
    "tuck": {
      "name": "tuck",
      "desc": "( A B - B A B ): puts a duplicate of the top form\n before the second-from-top form.\n\n```\n1 2 tuck leaves: [ 2 1 2 ]\n```\n\n"
    },
    "2dup": {
      "name": "2dup",
      "desc": "( A B -- A B A B ): duplicates a pair of forms.\n\n```\n1 2 2dup leaves: [ 1 2 1 2 ]\n```\n\n"
    },
    "rot": {
      "name": "rot",
      "desc": "( A B C -- B C A ): moves thirdmost form to the top.\n\n```\n1 2 3 rot leaves: [ 2 3 1 ]\n      rot leaves: [ 3 1 2 ]\n      rot leaves: [ 1 2 3 ]\n```\n\n"
    },
    "-rot": {
      "name": "-rot",
      "desc": "( A B C -- C A B ): moves top form so it's thirdmost.\n\n```\n1 2 3 -rot leaves: [ 3 1 2 ]\n      -rot leaves: [ 2 3 1 ]\n      -rot leaves: [ 1 2 3 ]\n```\n\n"
    },
    "asStack": {
      "name": "asStack",
      "desc": "( B -- ): replaces current stack with Block in-place. Cursor\nposition is saved (clamped to Block end if Block is smaller)"
    },
    "dip": {
      "name": "dip",
      "desc": "( ... T dip: F -- ... F' T ): opens Form behind Top.\n\n```\n1 2 4 [ + ] dip leaves: [ 3 4 ]\n1 2 4 100 dip leaves: [ 1 2 100 4 ]\n```\n\n"
    },
    "dip:": {
      "name": "dip:",
      "desc": "( ... T dip: F -- ... F' T ): infix version of `dip`."
    },
    "keep": {
      "name": "keep",
      "desc": "( ... T F -- ... F' T ): opens Form with Top on top\n of the stack, restoring Top after it is opened.\n\n```\n1 2 4 [ + ] keep leaves: [ 1 6 4 ]\n1 2 4 'hello' keep leaves: [ 1 2 4 'hello' 4 ]\n```\n\n"
    },
    "keep:": {
      "name": "keep:",
      "desc": "( ... T keep: F -- ... F' T ): infix version of `keep`."
    },
    "bi": {
      "name": "bi",
      "desc": "( F A B -- A' B' ): opens two blocks, A and\n B, with Form placed on top of the stack for each one, and\n leaves their results in order.\n\n```\n[ 1 2 3 ] [ sum ] [ count ] bi / leaves: 2\n```\n\n"
    },
    "bi:": {
      "name": "bi:",
      "desc": "( F bi: A B -- A' B' ): infix version of `bi`.\n\n```\n[ 1 2 3 ] bi: sum count / leaves: 2\n```\n\n"
    },
    "bi*": {
      "name": "bi*",
      "desc": "( Af Bf A B -- A' B' ): opens block A with A form,\n block B with B form, and leaves the results.\n\nNote: the result of opening A is available to B.\n\n```\n[ 1 2 ] [ 3 4 ] [ first ] [ last ] bi* leaves: [ 1 4 ]\n\n\"Note how we use the result of the first block in the\n second block:\"\n[ 1 2 ] [ 3 4 ] [ first ] [ last + ] bi* leaves: [ 5 ]\n```\n\n"
    },
    "bi*:": {
      "name": "bi*:",
      "desc": "( Af Bf bi*: A B -- A' B' ): infix version of `bi*`."
    },
    "bi@": {
      "name": "bi@",
      "desc": "( X Y B -- Bx By ): leaves the results of applying\n Block first to X form, and then to Y form.\n\n```\n1 2 [ 'X =' swap ~ ] bi@ leaves: [ 'X = 1' 'X = 2' ]\n```\n\n"
    },
    "bi@:": {
      "name": "bi@:",
      "desc": "( X Y bi@: B -- Bx By ): infix version of `bi@`."
    },
    "<<|": {
      "name": "<<|",
      "desc": "( -- ): moves cursor left twice in the active stack,\n opposite of `|>>`. Same as `<| <|` but looks nicer.\n\n```\n[ a b c | ] |: [ <<| 123 |>> 456 ] leaves: [ [ a 123 b c 456 ] ]\n```\n\n"
    },
    "|>>": {
      "name": "|>>",
      "desc": "( -- ): moves cursor right twice in the active stack,\n opposite of `<<|`. Same as `|> |>` but looks nicer.\n\nSee `<<|` for an example of how you can use this word.\n\n"
    },
    "easeInSine": {
      "name": "easeInSine",
      "desc": "( X -- Xe ): eases X using easeInSine function."
    },
    "easeOutSine": {
      "name": "easeOutSine",
      "desc": "( X -- Xe ): eases X using easeOutSine function."
    },
    "easeInOutSine": {
      "name": "easeInOutSine",
      "desc": "( X -- Xe ): eases X using easeInOutSine function."
    },
    "easeInCubic": {
      "name": "easeInCubic",
      "desc": "( X -- Xe ): eases X using easeInCubic function."
    },
    "easeOutCubic": {
      "name": "easeOutCubic",
      "desc": "( X -- Xe ): eases X using easeOutCubic function."
    },
    "easeInOutCubic": {
      "name": "easeInOutCubic",
      "desc": "( X -- Xe ): eases X using easeInOutCubic function."
    },
    "easeInQuint": {
      "name": "easeInQuint",
      "desc": "( X -- Xe ): eases X using easeInQuint function."
    },
    "easeOutQuint": {
      "name": "easeOutQuint",
      "desc": "( X -- Xe ): eases X using easeOutQuint function."
    },
    "easeInOutQuint": {
      "name": "easeInOutQuint",
      "desc": "( X -- Xe ): eases X using easeInOutQuint function."
    },
    "easeInCirc": {
      "name": "easeInCirc",
      "desc": "( X -- Xe ): eases X using easeInCirc function."
    },
    "easeOutCirc": {
      "name": "easeOutCirc",
      "desc": "( X -- Xe ): eases X using easeOutCirc function."
    },
    "easeInOutCirc": {
      "name": "easeInOutCirc",
      "desc": "( X -- Xe ): eases X using easeInOutCirc function."
    },
    "easeInElastic": {
      "name": "easeInElastic",
      "desc": "( X -- Xe ): eases X using easeInElastic function."
    },
    "easeOutElastic": {
      "name": "easeOutElastic",
      "desc": "( X -- Xe ): eases X using easeOutElastic function."
    },
    "easeInOutElastic": {
      "name": "easeInOutElastic",
      "desc": "( X -- Xe ): eases X using easeInOutElastic function."
    },
    "easeInQuad": {
      "name": "easeInQuad",
      "desc": "( X -- Xe ): eases X using easeInQuad function."
    },
    "easeOutQuad": {
      "name": "easeOutQuad",
      "desc": "( X -- Xe ): eases X using easeOutQuad function."
    },
    "easeInOutQuad": {
      "name": "easeInOutQuad",
      "desc": "( X -- Xe ): eases X using easeInOutQuad function."
    },
    "easeInQuart": {
      "name": "easeInQuart",
      "desc": "( X -- Xe ): eases X using easeInQuart function."
    },
    "easeOutQuart": {
      "name": "easeOutQuart",
      "desc": "( X -- Xe ): eases X using easeOutQuart function."
    },
    "easeInOutQuart": {
      "name": "easeInOutQuart",
      "desc": "( X -- Xe ): eases X using easeInOutQuart function."
    },
    "easeInExpo": {
      "name": "easeInExpo",
      "desc": "( X -- Xe ): eases X using easeInExpo function."
    },
    "easeOutExpo": {
      "name": "easeOutExpo",
      "desc": "( X -- Xe ): eases X using easeOutExpo function."
    },
    "easeInOutExpo": {
      "name": "easeInOutExpo",
      "desc": "( X -- Xe ): eases X using easeInOutExpo function."
    },
    "easeInBack": {
      "name": "easeInBack",
      "desc": "( X -- Xe ): eases X using easeInBack function."
    },
    "easeOutBack": {
      "name": "easeOutBack",
      "desc": "( X -- Xe ): eases X using easeOutBack function."
    },
    "easeInOutBack": {
      "name": "easeInOutBack",
      "desc": "( X -- Xe ): eases X using easeInOutBack function."
    },
    "easeInBounce": {
      "name": "easeInBounce",
      "desc": "( X -- Xe ): eases X using easeInBounce function."
    },
    "easeOutBounce": {
      "name": "easeOutBounce",
      "desc": "( X -- Xe ): eases X using easeOutBounce function."
    },
    "easeInOutBounce": {
      "name": "easeInOutBounce",
      "desc": "( X -- Xe ): eases X using easeInOutBounce function."
    },
    "toCapitalized": {
      "name": "toCapitalized",
      "desc": "( Q -- Q' ): capitalizes Quote: transforms the first\nletter of Quote to uppercase."
    },
    "~": {
      "name": "~",
      "desc": "( A B -- Q ): obtains Quote by stitching (and\n enquoting, if necessary) two forms, A and B.\n\n```\n100 200 ~ leaves: '100200'\n'hello' 'world' ~ leaves: 'helloworld'\n```\n\n"
    },
    "~*": {
      "name": "~*",
      "desc": "( F -- Q ): like `here join`, but faster and not\n recursive in case Form is a block. Else, same as\n `toQuote`. Leaves the resulting Quote.\n\n```\n123 ~* leaves: '123'\n[ 1 2 3 ] ~* leaves: '123'\n\n'John' $: name\n[ 'My name is ' name '!' ] ~* leaves: 'My name is John!'\n```\n\nBeware that the referenced entries are only resolved. They\nare not opened. Consider using `vals join` if you want to\nstitch results instead.\n\n```\n[ 1 2 + ] @: foo\n\n[ 'foo = ' foo ] ~* leaves: 'foo = [ 1 2 + ]'\n\n\"You can use this if you want to evaluate first:\"\n[ 'foo = ' foo ] vals join leaves: 'foo = 3'\n```\n\n"
    },
    "parseDecimal": {
      "name": "parseDecimal",
      "desc": "( Q -- D ): converts Quote to Decimal. Dies if Quote does\n not contain a decimal, or if couldn't parse it out.\n\nQuote is parsed by Novika. This word only ensures the result\nof that is a decimal. Aside from error messages that leak\nthis fact, you generally shouldn't care about this.\n\n```\n'1234' parseDecimal leaves: 1234\n'-1234.5678' parseDecimal leaves: -1234.5678\n```\n\n"
    },
    "top?": {
      "name": "top?",
      "desc": "( B -- Tf true / false ): leaves Top form in Block followed\n by `true` if there is one, otherwise leaves `false` only.\n\nTop form is the form before the cursor in Block.\n\n```\n[ ] top? leaves: false\n[ 1 2 3 | ] top? leaves: [ 3 true ]\n[ 1 2 | 3 ] top? leaves: [ 2 true ]\n[ 1 | 2 3 ] top? leaves: [ 1 true ]\n[ | 1 2 3 ] top? leaves: false\n```\n\n"
    },
    "peek?": {
      "name": "peek?",
      "desc": "( [ ... | F ... ]B -- F true / false ): leaves Form and/\n or a boolean for whether Form exists in Block.\n\n```\n[ 1 | 2 3 ] peek? leaves: [ 2 true ]\n[ 1 2 3 | ] peek? leaves: false\n```\n\n"
    },
    "|atLeftBound?": {
      "name": "|atLeftBound?",
      "desc": "( B -- true/false ): leaves whether cursor is at the\n left end in Block.\n\n```\n[ | ] |atLeftBound? leaves: true\n[ 1 | ] |atLeftBound? leaves: false\n[ | 1 2 3 ] |atLeftBound? leaves: true\n[ 1 | 2 3 ] |atLeftBound? leaves: false\n[ 1 2 3 | ] |atLeftBound? leaves: false\n```\n\n"
    },
    "|atRightBound?": {
      "name": "|atRightBound?",
      "desc": "( B -- true/false ): leaves whether cursor is at the\n right end in Block.\n\n```\n[ | ] |atRightBound? leaves: true\n[ 1 | ] |atRightBound? leaves: true\n[ | 1 2 3 ] |atRightBound? leaves: false\n[ 1 | 2 3 ] |atRightBound? leaves: false\n[ 1 2 3 | ] |atRightBound? leaves: true\n```\n\n"
    },
    "|afterFirst?": {
      "name": "|afterFirst?",
      "desc": "( B -- true/false ): leaves whether cursor is after the\n first form in Block.\n\n```\n[ | ] |afterFirst? leaves: false\n[ 1 | ] |afterFirst? leaves: true\n[ 1 | 2 3 ] |afterFirst? leaves: true\n[ 1 2 3 | ] |afterFirst? leaves: false\n```\n\n"
    },
    "|-": {
      "name": "|-",
      "desc": "( B N -- ): decrements block cursor position: moves\n cursor back N times in Block.\n\n```\n[ 1 2 3 | ] dup 2 |- leaves: [ [ 1 | 2 3 ] ]\n```\n\n"
    },
    "|+": {
      "name": "|+",
      "desc": "( B N -- ): increments block cursor position: moves\n cursor forward N times in Block.\n\n```\n[ 1 2 3 ] $: block\nblock 1 |to\nblock leaves: [ [ 1 | 2 3 ] ]\nblock 1 |+\nblock leaves: [ [ 1 2 | 3 ] ]\nblock 1 |+\nblock leaves: [ [ 1 2 3 | ] ]\n```\n\n"
    },
    "|:": {
      "name": "|:",
      "desc": "( S |: F -- S ): infix version of `there`.\n\nLike `there`, preserves `ahead`. Leaves the opener\nblock dirty due to this.\n\n```\n([ 1 2 3 ] |: 100) leaves: [ 1 2 3 100 ]\n([ 1 2 3 ] |: +) leaves: [ [ 1 5 ] ]\n([ 1 2 3 ] |: swap) leaves: [ [ 1 3 2 ] ]\n\n[ 100 ] |: [ ahead thru + ] 200 123 leaves: [ 300 123 ]\n```\n\n"
    },
    "|clamp": {
      "name": "|clamp",
      "desc": "( B N -- ): moves the cursor in Block to N. If N\n is negative, the cursor is moved to 0. If N is greater\n than the amount of forms in Block, the cursor is moved\n to the end of Block.\n\n```\n[ 1 2 3 ] $: x\nx 1 |clamp\nx leaves: [ [ 1 | 2 3 ] ]\nx 1000 |clamp\nx leaves: [ [ 1 2 3 | ] ]\nx -1000 |clamp\nx leaves: [ [ | 1 2 3 ] ]\n```\n\n"
    },
    "|hydrate": {
      "name": "|hydrate",
      "desc": "( Lb N B -- ): moves the cursor in List block to N,\n then hydrates List block with Block. After Block had\n executed *successfully*, moves the cursor in List\n block back to where it was before `|hydrate` (clamped\n to either end, if necessary).\n\n```\n[ 1 | 2 3 ] $: x\n\nx 2 [ + ] |hydrate\nx leaves: [ [ 3 | 3 ] ]\n\nx 2 [ 2drop ] |hydrate\nx leaves: [ [ ] ]\n```\n\n"
    },
    "|swap": {
      "name": "|swap",
      "desc": "( -- ): swaps the item before and after cursor in the\n active stack.\n\n```\n[ 1 2 | 3 ] $: block\nblock [ |swap ] there\nblock leaves: [ [ 1 3 | 2  ] ]\n```\n\n"
    },
    "gulp": {
      "name": "gulp",
      "desc": "( F B -- ): `shove`s Form into Block, drops both.\n\n```\n3 [ 1 2 ] keep: gulp leaves: [ [ 1 2 3 ] ]\n```\n\n"
    },
    "spit": {
      "name": "spit",
      "desc": "( [ ... F | ... ]B -- F [ ... | ... ]B ] ): `cherry`s\n Form from Block onto the active stack, placing it before\n the Block. Inverse of `gulp`.\n\n```\n[ 1 2 3 ] spit leaves: [ 3 [ 1 2 ] ]\n```\n\n"
    },
    "<<": {
      "name": "<<",
      "desc": "( [ ... | ... ]B F -- [ ... F | ... ]B ): `shove`s Form\n into Block, leaves only Block.\n\n```\n[ 1 2 ] 3 << leaves: [ [ 1 2 3 ] ]\n```\n\n"
    },
    ">>": {
      "name": ">>",
      "desc": "( [ ... F | ... ]B -- [ ... | ... ]B F ): `cherry`s\n Form from Block, leaves both. Inverse of `<<`.\n\n```\n[ 1 2 3 ] >> leaves: [ [ 1 2 ] 3 ]\n```\n\n"
    },
    "enclose": {
      "name": "enclose",
      "desc": "( F -- [ F ]B ): encloses Form in a new, orphan Block.\n\n```\n'Hi!' enclose leaves: [ [ 'Hi!' ] ]\n```\n\n"
    },
    "2enclose": {
      "name": "2enclose",
      "desc": "( X Y -- [ X Y ]B ): encloses X and Y, a pair of forms,\n in a new, orphan Block.\n\n```\n'Hello' 'World' 2enclose leaves: [ [ 'Hello' 'World' ] ]\n```\n\n"
    },
    "first": {
      "name": "first",
      "desc": "( B -- F ): leaves first Form in Block. Dies if Block\n is empty.\n\n```\n[ 0 ] first leaves: 0\n[ 1 2 3 ] first leaves: 1\n```\n\n"
    },
    "first?": {
      "name": "first?",
      "desc": "( B -- F true / false ): leaves first Form in Block\n followed by true if Block is non-empty. Leaves false\n if Block is empty.\n\n```\n[ ] first? leaves: [ false ]\n[ 1 2 3 ] first? leaves: [ 1 true ]\n```\n\n"
    },
    "last": {
      "name": "last",
      "desc": "( B -- F ): leaves last Form in Block. Dies if Block\n is empty.\n\n```\n[ 0 ] last leaves: 0\n[ 1 2 3 ] last leaves: 3\n```\n\n"
    },
    "last?": {
      "name": "last?",
      "desc": "( B -- F true / false ): leaves last Form in Block\n followed by true if Block is non-empty. Leaves false\n if Block is empty.\n\n```\n[ ] last? leaves: [ false ]\n[ 1 2 3 ] last? leaves: [ 3 true ]\n```\n\n"
    },
    "startsWith?": {
      "name": "startsWith?",
      "desc": "( B/Q F/Fq -- Sb ): leaves Status boolean for whether\n Block ends with Form (as per `=`), or Quote ends with\n Fragment quote.\n\nAlways leaves true if Form or Fragment quote is empty.\n\n```\n'hello world' 'h' startsWith? leaves: true\n'hello world' 'hello' startsWith? leaves: true\n'hello world' 'world' startsWith? leaves: false\n\n[ 1 2 3 ] 1 startsWith? leaves: true\n[ 1 2 3 ] 3 startsWith? leaves: false\n```\n\n"
    },
    "endsWith?": {
      "name": "endsWith?",
      "desc": "( B/Q F/Fq -- Sb ): leaves Status boolean for\n whether Block ends with Form (as per `=`), or if Quote\n ends with Fragment quote.\n\nAlways leaves true if Form or Fragment quote is empty.\n\n```\n'hello world' 'd' endsWith? leaves: true\n'hello world' 'world' endsWith? leaves: true\n'hello world' 'hello' endsWith? leaves: false\n\n[ 1 2 3 ] 3 endsWith? leaves: true\n[ 1 2 3 ] 1 endsWith? leaves: false\n```\n\n"
    },
    "surroundedBy?": {
      "name": "surroundedBy?",
      "desc": "( B/Q Bf/Bq Ef/Eq -- true/false ): leaves whether Block/Quote\n starts with Begin form/Begin quote, and ends with End form/\n End quote.\n\n```\n[ 1 2 3 ] 1 3 surroundedBy? leaves: true\n'[[hello world]]' '[[' ']]' surroundedBy? leaves: true\n```\n\n"
    },
    "adopt": {
      "name": "adopt",
      "desc": "( P C -- C ): same as `reparent`, but in different order."
    },
    "--": {
      "name": "--",
      "desc": "( P `--` C -- C ): infix version of `adopt`.\n\n```\n[ 100 $: x ] obj $: a\n[ 200 $: y ] obj $: b\n\n(a -- b -- a) drop\na -> [x y] leaves: [ [ 100 200 ] ]\nb -> [x y] leaves: [ [ 100 200 ] ]\n```\n\n"
    },
    "·>": {
      "name": "·>",
      "desc": "( B ·> F -- F ): infix version of `befriend` that leaves\n the *friend* for further chaining.\n\n```\n[ 100 $: x ] obj $: a\n[ 200 $: y ] obj $: b\na ·> b ·> a drop\n\na.x leaves: 100\na.y leaves: 200\n\nb.x leaves: 100\nb.y leaves: 200\n\na [ 'Hello World' =: x ] extend\n\na.x leaves: 'Hello World'\na.y leaves: 200\n\nb.x leaves: 'Hello World'\nb.y leaves: 200\n```\n\n"
    },
    "child": {
      "name": "child",
      "desc": "( B -- Cb ): leaves an empty Child block for Block. Very\nmuch like `new`, but doesn't copy the tape and therefore may\nbe faster in certain circumstances."
    },
    "->": {
      "name": "->",
      "desc": "( Db -> N -- F ): Resolves Name, a word, using the\n given Dictionary block (block with a dictionary and/or\n relatives, therefore, simply any block). Does not\n distinguish between entry types (i.e., it doesn't matter\n whether Name resolves to an opener or a pusher entry):\n its value Form is always *pushed* onto the active stack.\n\n```\n[ 100 $: x 200 $: y [ x y + ] @: sum ] obj $: point\n\npoint -> x leaves: 100\npoint -> y leaves: 200\npoint -> sum leaves: [ [ x y + ] ] \"Beware!\"\n\n\"Note that we still can open it and get the result:\"\nopen leaves: 300\n```\n\nIt is possible to access multiple entries when Name is a\nblock, *preserving block structure*:\n\n```\n[ 100 $: x 200 $: y ] obj -> [ x y ] leaves: [ [ 100 200 ] ]\n[ 100 $: x 200 $: y ] obj -> [ [ [ x ] ] y ] leaves: [ [ [ [ 100 ] ] 200 ] ]\n```\n\n"
    },
    ".": {
      "name": ".",
      "desc": "( Db . N -- ... ): resolves Name in Dictionary block and\n *opens* it. Infix version of `entry:open`.\n\n`.` is the only word that gets special treatment in\nNovika, in that it does not need to be surrounded with\nwhitespace when other words must be.\n\n```\n[ 100 $: x 200 $: y [ x y + ] @: sum ] obj $: point\n\npoint.x leaves: 100\npoint.y leaves: 200\npoint.sum leaves: 300\n```\n\nPreserves (carries through) `ahead`, but makes the caller\nblock's instance dirty (which should not cause any trouble\nfrom the user's perspective).\n\n```\n[ $: double?\n\n  [ ahead thru double? => [ 2 * ] ] @: bar:\n\n  this\n] @: foo\n\ntrue foo.bar: 100 leaves: [ 200 ]\nfalse foo.bar: 100 leaves: [ 100 ]\n```\n\n"
    },
    "fetch:": {
      "name": "fetch:",
      "desc": "( Db N fetch: B -- ): resolves Name using Dictionary\n block, and opens Block with the resolved entry's value\n form *on top of the caller stack.* If Name could not be\n resolved using the dictionary block, or if the dictionary\n block  is something other than block, does nothing.\n Itself, leaves nothing (unless Block is empty: in that\n case, leaves the value form if resolved successfully).\n\n```\n'This is not a block!' #x fetch: [ 1 + ] leaves: [ ]\n[ 100 $: x ] obj #x fetch: [ 1 + ] leaves: [ 101 ]\n[ 100 $: x ] obj #undefinedThing fetch: [ 1 + ] leaves: [ ]\n```\n\n"
    },
    "extendWith": {
      "name": "extendWith",
      "desc": "( S B -- S ): extends Source block with entries from the dictionary\n of Body block, then instantiates Body block, befriends the instance\n with Source block, and opens Body block with an empty stack. When the\n Body block instance finishes running, extends Source block with entries\n from the instance. Leaves Source block.\n\nAll complexities and edge cases aside, this word is basically one of\nthe ways to redefine/create/modify an entry through computation and\nfrom another, possibly unrelated block (unrelated as in via the block\ngraph, that is).\n\n**Important**: Source block is not extended with *private entries*\nof Body block or Body block instance (that is, entries whose name\nstarts with _underscore). However, Body block does get access and\nis able to reassign private entries of Source block.\n\nSee `extendWith:` for an example.\n\n"
    },
    "extendWith:": {
      "name": "extendWith:",
      "desc": "( S extendWith: B -- S ): infix version of `extendWith`.\n\n```\n[ 100 $: x ] obj $: a\n[ 200 $: y ] obj $: b\n\na ·> b ·> a drop\n\na.x a.y leaves: [ 100 200 ]\nb.x b.y leaves: [ 100 200 ]\n\na extendWith: [ [ y y * ] @: x ] drop\nb extendWith: [ 4 =: y ] drop\n\na.x a.y leaves: [ 16 4 ]\nb.x b.y leaves: [ 16 4 ]\n\nb extendWith: [ 100 $: y ] drop\n\na.x a.y leaves: [ 10000 100 ]\nb.x b.y leaves: [ 10000 100 ]\n```\n\n"
    },
    "extend:": {
      "name": "extend:",
      "desc": "( S extend: B -- ): an alternative infix version of `extendWith`\n which doesn't leave anything.\n\n```\n[ 100 $: x ] obj $: a\n[ 200 $: y ] obj $: b\n\na ·> b ·> a drop\n\na.x a.y leaves: [ 100 200 ]\nb.x b.y leaves: [ 100 200 ]\n\na extend: [ [ y y * ] @: x ]\nb extend: [ 4 =: y ]\n\na.x a.y leaves: [ 16 4 ]\nb.x b.y leaves: [ 16 4 ]\n\nb extend: [ 100 $: y ]\n\na.x a.y leaves: [ 10000 100 ]\nb.x b.y leaves: [ 10000 100 ]\n```\n\n"
    },
    "|slideRight": {
      "name": "|slideRight",
      "desc": "( Lb B -- Lb ): slides cursor in List block from left\n to right, in steps of one. Opens Block with List block as\n the stack *after* each step. Leaves List block. `break`\n and `next` are available.\n\n```\n[ 1 | 2 3 ] [ + ] |slideRight leaves: [ [ 6 ] ]\n```\n\nIn the table below, sliding step is marked with '*', and\nblock iteration is postfixed by a '+'.\n\n```text\n +------+-------+-------------+\n | #    | form  |    list     |\n +======+=======+=============+\n | 0    |       | [ 1 2 3 ]   |\n | 1    | 1 |to | [ 1 | 2 3 ] |\n | *    |       | [ 1 2 | 3 ] |\n | 3+   |    +  | [ 3 | 3 ]   |\n | *    |       | [ 3 3 ]     |\n | 5+   |    +  | [ 6 ]       |\n +------+-------+-------------+\n```\n\n"
    },
    "|->": {
      "name": "|->",
      "desc": "( Lb |-> B -- Lb ): infix version of `|slideRight`."
    },
    "|~>": {
      "name": "|~>",
      "desc": "( Lb |~> B -- Lb ): similar to `|->`, but remembers the\n cursor position in List block and restores it after all\n items were visited by Block (clamping to either end,\n if necessary).\n\n```\n[ 1 | 2 3 ] $: x\nx |~> [ 1 + ]\nx leaves: [ [ 1 | 3 4 ] ]\n```\n\n"
    },
    "||->": {
      "name": "||->",
      "desc": "( Lb ||-> B -- Lb ): same as `|->`, but moves the cursor\n to the start of List block first, then executes Block and\n so on. See `|->` and especially `|slideRight` for more\n information on what all of this means.\n\n```\n[ 1 2 3 ] ||-> [ 2 * ] leaves: [ [ 2 4 6 ] ]\n```\n\n"
    },
    "||~>": {
      "name": "||~>",
      "desc": "( Lb |~> B -- Lb ): similar to `||->`, but remembers\n the cursor position in List block and restores it after\n all items were visited by Block (clamping to either end,\n if necessary).\n\n```\n[ 1 | 2 3 ] $: x\nx leaves: [ [ 1 | 2 3 ] ]\nx ||~> [ 1 + ]\nx leaves: [ [ 2 | 3 4 ] ]\n```\n\n"
    },
    "|slideLeft": {
      "name": "|slideLeft",
      "desc": "( Lb B -- Lb ): similar to `|->`, but slides the cursor\nfrom right to left. Consult `|slideRight`. `break` and\n`next` are available."
    },
    "<-|": {
      "name": "<-|",
      "desc": "( Lb <-| B -- Lb ): infix version of `|slideLeft`."
    },
    "eachWithIndex": {
      "name": "eachWithIndex",
      "desc": "( Lb B -- ): opens Block with each item of List block on\n top of a new stack, and its index below (that is, `Index\n Item`). List block is unchanged. `break` and `next` are\n available.\n\n```\n[ 1 2 3 ] [ 2echo ] eachWithIndex\n\"STDOUT: 0 1⏎\"\n\"STDOUT: 1 2⏎\"\n\"STDOUT: 2 3⏎\"\n```\n\n"
    },
    "each": {
      "name": "each",
      "desc": "( Lb B -- ): opens Block with each item of List block on\n top of a new stack. List block is unchanged. `break` and\n `next` are available.\n\n```\n[ 1 2 3 ] [ echo ] each\n\"STDOUT: 1⏎\"\n\"STDOUT: 2⏎\"\n\"STDOUT: 3⏎\"\n```\n\n"
    },
    "each:": {
      "name": "each:",
      "desc": "( Lb each: B -- ): infix version of `each`.\n\n```\n[ 1 2 3 ] each: [ echo ]\n\"STDOUT: 1⏎\"\n\"STDOUT: 2⏎\"\n\"STDOUT: 3⏎\"\n```\n\n"
    },
    "eachWithIndex:": {
      "name": "eachWithIndex:",
      "desc": "( Lb eachWithIndex: B -- ): infix version of `eachWithIndex`.\n\n```\n[ 1 2 3 ] eachWithIndex: [ 2echo ]\n\"STDOUT: 0 1⏎\"\n\"STDOUT: 1 2⏎\"\n\"STDOUT: 2 3⏎\"\n```\n\n"
    },
    "pairs": {
      "name": "pairs",
      "desc": "( Lb B -- ): opens Block with pairs of items from\n List block on top of an empty stack. `break` and `next`\n are available. Does nothing if List block is empty. Dies\n if List block has an odd number of forms.\n\n```\n[ 1 2 3 4 ] [ + echo ] pairs\n\"STDOUT: 3⏎ (i.e., 1 + 2)\"\n\"STDOUT: 7⏎ (i.e., 3 + 4)\"\n```\n\n"
    },
    "pairs:": {
      "name": "pairs:",
      "desc": "( Lb pairs: B -- ): infix version of `pairs`.\n\n```\n[ 1 2 3 4 ] pairs: [ + echo ]\n\"STDOUT: 3⏎\"\n\"STDOUT: 7⏎\"\n```\n\n"
    },
    "mapPairs": {
      "name": "mapPairs",
      "desc": "( Lb B -- Rb ): leaves Result block obtained by collecting\n results of Block opened with previous Result block as the stack,\n plus a pair of items from List block, for each pair of items\n in List block. Dies if List block has an odd number of forms.\n `break` and `next` are available.\n\n```\n\"Sum pairs of numbers 1, 2; 3, 4; 5, 6 etc.:\"\n1 to: 10 mapPairs: + leaves: [ [ 3 7 11 15 19 ] ]\n```\n\n"
    },
    "mapPairs:": {
      "name": "mapPairs:",
      "desc": "( Lb mapPairs: B -- Rb ): infix version of `mapPairs`.\n\n```\n\"Sum pairs of numbers 1, 2; 3, 4; 5, 6 etc.:\"\n1 to: 10 mapPairs: + leaves: [ [ 3 7 11 15 19 ] ]\n```\n\n"
    },
    "consPairs": {
      "name": "consPairs",
      "desc": "( Lb B -- ): opens Block with consequtive pairs of items\n from List block on top of an empty stack. `break` and `next`\n are available.\n\n```\n[ ] [ + echo ] consPairs\n[ 1 ] [ + echo ] consPairs\n\"Both do nothing!\"\n\n[ 1 2 ] [ + echo ] consPairs\n\"STDOUT: 3⏎ (i.e, 1 + 2)\"\n\n[ 1 2 3 ] [ + echo ] consPairs\n\"STDOUT: 3⏎ (i.e., 1 + 2)\"\n\"STDOUT: 5⏎ (i.e., 2 + 3)\"\n```\n\n"
    },
    "consPairs:": {
      "name": "consPairs:",
      "desc": "( Lb B -- ): infix version of `consPairs`.\n\n```\n[ 1 2 3 ] consPairs: [ + echo ]\n\"STDOUT: 3⏎\"\n\"STDOUT: 5⏎\"\n```\n\n"
    },
    "mapConsPairs": {
      "name": "mapConsPairs",
      "desc": "( Lb B -- Rb ): leaves Result block obtained by collecting\n results of Block opened with previous Result block as the stack,\n plus a **consecutive** pair of items from List block, for each\n consecutive pair of items in List block. `break` and `next`\n are available.\n\n```\n\"Sum pairs of numbers 1, 2; 2, 3; 3, 4 etc.:\"\n1 to: 10 mapConsPairs: + leaves: [ [ 3 5 7 9 11 13 15 17 19 ] ]\n```\n\n"
    },
    "mapConsPairs:": {
      "name": "mapConsPairs:",
      "desc": "( Lb mapConsPairs: B -- Rb ): infix version of `mapConsPairs`.\n\n```\n\"Sum pairs of numbers 1, 2; 2, 3; 3, 4 etc.:\"\n1 to: 10 mapConsPairs: + leaves: [ [ 3 5 7 9 11 13 15 17 19 ] ]\n```\n\n"
    },
    "map": {
      "name": "map",
      "desc": "( Lb B -- Mlb ): opens Block with each item of List block\n on top of an empty stack. Replaces item in List block with\n Block's stack top after opening it. Leaves the resulting\n Modified list block. `break` and `next` are available.\n\n```\n[ 1 2 3 ] [ 1 + ] map leaves: [ [ 2 3 4 ] ] \"(a different block!)\"\n\n[ 1 2 3 ] $: a\na [ 1 + ] map leaves: [ [ 2 3 4 ] ] \"(a different block!)\"\na leaves: [ [ 1 2 3 ] ]\n```\n\n"
    },
    "map:": {
      "name": "map:",
      "desc": "( Lb map: B -- MLb ): infix version of `map`.\n\n```\n[ 1 2 3 ] map: [ 1 + ] leaves: [ 2 3 4 ]\n```\n\n"
    },
    "only": {
      "name": "only",
      "desc": "( Lb B -- Rb ): opens Block with each item of List block\n on top of an empty stack. Removes that item in Result block\n if Block's stack top is false after it was opened. `break`\n and `next` are available.\n\n```\n[ ] [ 100 > ] only\n  leaves: [ [ ] ] \"(a different block!)\"\n\n[ 1 2 3 ] [ ] only\n  leaves: [ [ 1 2 3 ] ] \"(a different block!)\"\n\n[ 1 100 2 300 4 600 10 ] [ 100 > ] only\n  leaves: [ [ 300 600 ] ]\n```\n\n"
    },
    "without": {
      "name": "without",
      "desc": "( Lb B -- Rb ): inverse of `only`."
    },
    "only:": {
      "name": "only:",
      "desc": "( Lb only: B -- Rb ): infix version of `only`.\n\n```\n[ 1 100 2 300 4 600 10 ] only: [ 100 > ]\n  leaves: [ [ 300 600 ] ]\n```\n\n"
    },
    "without:": {
      "name": "without:",
      "desc": "( Lb without: B -- MLb ): infix version of `without`.\n\n```\n[ 1 100 2 300 4 600 10 ] without: [ 100 > ]\n  leaves: [ [ 1 100 2 4 10 ] ]\n```\n\n"
    },
    "reduce": {
      "name": "reduce",
      "desc": "( Lb B M -- M ): reduces List block using Block. Block\n is opened with Memo, current item on top of an empty stack.\n Memo is updated to Block's value after Block is opened.\n `break` and `next` are available.\n\n```\n[ ] [ + ] 0 reduce\n  leaves:  0\n\n[ 1 ] [ + ] 0 reduce\n  leaves: 1 \"(i.e., 0 + 1)\"\n\n[ 1 2 3 ] [ + ] 0 reduce\n  leaves: 6\n\n[ 'Hellope, ' 'Europe!' ' ' 'Huh?' ] [ stitch ] '' reduce\n  leaves: 'Hellope, Europe! Huh?'\n```\n\nSupports stack reduction:\n\n```\n'1' '2' '3' stack [ stitch ] '' reduce\n  leaves: '123'\n```\n\n"
    },
    "amount": {
      "name": "amount",
      "desc": "( Lb B -- A ): leaves the Amount of items for which Block,\n when opened with an item from List block on top of an\n empty stack, leaves a truthy form. `break` and `next` are\n available.\n\n```\n[ 1 2 3 ] [ 2 > ] amount leaves: 1\n[ 1 2 3 ] [ 100 > ] amount leaves: 0\n[ 1 5000 2 4400 1 100 102 ] [ 100 <= ] amount\n  leaves: 4 \"(i.e., 1, 2, 1, 100)\"\n\n"
    },
    "#": {
      "name": "#",
      "desc": "( Lb B -- A ): infix version of `amount`.\n\n```\n[ 1 2 3 ] # [ 2 > ] leaves: 1\n```\n\n"
    },
    "all?": {
      "name": "all?",
      "desc": "( Lb B -- true/false ): whether Block leaves true for all\n items in List block, when opened with each item on top of\n an empty stack.\n\n```\n[ ] [ 100 < ] all? leaves: true \"BEWARE!\"\n[ 1 2 3 ] [ 100 < ] all? leaves: true\n[ 101 2 3 4 ] [ 100 < ] all?\n  leaves: false \"(i.e., because of 101)\"\n```\n\n"
    },
    "all:": {
      "name": "all:",
      "desc": "( Lb all: B -- true/false ):  infix version of `all?`\n\n```\n[ ] all: even? leaves: true \"BEWARE!\"\n[ 1 2 3 ] all: even? leaves: false\n```\n\n"
    },
    "any?": {
      "name": "any?",
      "desc": "( Lb B -- true/false ): whether Block leaves true for any\n item in List block, when opened with each item on top of an\n empty stack.\n\n```\n[ ] [ 100 < ] any? leaves: false \"BEWARE!\"\n[ 1 2 3 ] [ 3 = ] any? leaves: true\n[ 101 3 2000 ] [ 100 < ] any? leaves: true\n[ 1002 350 2000 ] [ 100 < ] any? leaves: false\n```\n\n"
    },
    "anyof:": {
      "name": "anyof:",
      "desc": "( F anyof: B -- true/false ): infix version of `anyof?`.\n\n```\n100 anyof: [ 1 2 3 ] leaves: false\n#foo anyof: [ foo bar ] leaves: true\n\n[ 1 2 3 ] $: x\n1 anyof: x leaves: true\n#foo anyof: x leaves: false\n```\n\n"
    },
    "zip": {
      "name": "zip",
      "desc": "( A B -- Z ): leaves Zipped A, B. Dies if there is a\n different amount of items in A and B.\n\n```\n[ ] [ ] zip leaves: [ [ ] ]\n[ 1 2 ] [ 3 4 ] zip leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]\n```\n\n"
    },
    "zipWithDefault": {
      "name": "zipWithDefault",
      "desc": "( A B D -- Zb ): leaves Zipped A, B with holes\n filled by the given Default form.\n\n```\n[ ] [ ] #hole zipWithDefault leaves: [ [ ] ]\n\n[ 1 2 ] [ 3 4 ] #hole zipWithDefault\n  leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]\n\n[ 1 2 ] [ 3 ] #hole zipWithDefault\n  leaves: [ [ [ 1 3 ] [ 2 hole ] ] ]\n\n[ 1 ] [ 3 4 ] #hole zipWithDefault\n  leaves: [ [ [ 1 3 ] [ hole 4 ] ] ]\n\n"
    },
    "zip:": {
      "name": "zip:",
      "desc": "( A zip: B -- Z | A zip: B withDefault: D -- Z ): combined\n infix for `zip` and `zipWithDefault`.\n\n```\n[ 1 2 ] zip: [ 3 4 ] leaves: [ [ [ 1 3 ] [ 2 4 ] ] ]\n[ 1 2 ] zip: [ x y ] leaves: [ [ [ 1 x ] [ 2 y ] ] ]\n[ a b ] zip: [ 'Hi!' ] withDefault: 0 leaves: [ [ [ a 'Hi!' ] [ b 0 ] ] ]\n```\n\n"
    },
    "conjure": {
      "name": "conjure",
      "desc": "( S D -- I ): given a Source block and a Destination\n block, leaves an Instance of the Destination block with all\n words (see `word?`) replaced with entry values from the\n dictionary of Source (they are **not** opened), and all\n quoted words unquoted (see `quotedWord?`). Recurses on\n sub-blocks.\n\n```\n1 $: x\n2 $: y\n#+ $: plus\n\nthis [ x y plus #dup plus [ ##foo #echo ] #open ] conjure\n  leaves: [ [ 1 2 + dup + [ #foo echo ] #open ] ]\n\nopen leaves: 6\n\"STDOUT: foo⏎\"\n```\n\n"
    },
    "here": {
      "name": "here",
      "desc": "( B -- I ): `conjure` with Source block set to caller.\n\n```\n1 $: x\n2 $: y\n#+ $: plus\n\n[ x y plus #dup plus [ ##foo #echo ] #open ] here\n  leaves: [ [ 1 2 + dup + [ #foo echo ] #open ] ]\n\nopen leaves: 6 \"STDOUT: foo⏎\"\n```\n\n"
    },
    "minmax": {
      "name": "minmax",
      "desc": "( Lb -- Min Max ): leaves decimal minimum, maximum in\n List block. Use `minmaxBy` if List block doesn't (or doesn't\n always) contain solely decimals. If an empty block is given,\n dies, so make sure to handle that yourself.\n\n```\n[ 1 2 3 ] minmax leaves: [ 1 3 ]\n```\n\n"
    },
    "min": {
      "name": "min",
      "desc": "( Lb -- Min ): leaves decimal minimum in List block.\n See `minmax`.\n\n```\n[ 1 2 3 ] min leaves: 1\n```\n\n"
    },
    "max": {
      "name": "max",
      "desc": "( Lb -- Max ): leaves decimal maximum in List block.\n See `minmax`.\n\n```\n[ 1 2 3 ] max leaves: 3\n```\n\n"
    },
    "sum": {
      "name": "sum",
      "desc": "( Lb -- Sum ): leaves decimal sum of List block elements.\n For more control (or if not always decimal), use `sumBy`.\n\n```\n[ ] sum leaves: 0\n[ 1 ] sum leaves: 1\n[ 1 2 3 ] sum leaves: 6\n```\n\n"
    },
    "product": {
      "name": "product",
      "desc": "( Lb -- Product ): leaves decimal product of List block\n elements. For more control (or if not always decimal), take\n a look at `productBy`.\n\n```\n[ ] product leaves: 1\n[ 3 ] product leaves: 3\n[ 5 4 3 2 ] product leaves: 120\n```\n\n"
    },
    "minmaxBy": {
      "name": "minmaxBy",
      "desc": "( Lb Tb -- Min Max ): leaves the minimum and maximum\n values in List block. Decimal values are obtained via the\n Transformation block, which is opened with each element\n of List block on top of an empty stack. If List block is\n empty, dies, so make sure to handle that yourself.\n\n```\n[ 1 2 3 ] [ ] minmaxBy leaves: [ 1 3 ]\n[ 'A short quote' 'A loooonger quote' 'Veeeeeeeeeeery long quote' ] [ count ] minmaxBy\n  leaves: [ 'A short quote' 'Veeeeeeeeeeery long quote' ]\n\n"
    },
    "minBy": {
      "name": "minBy",
      "desc": "( Lb Tb -- Min ): leaves the minimum value in List\n block. Each element of List block is transformed using\n Transformation block. See `minmaxBy`.\n\n```\n[ 1 2 3 ] [ ] minBy leaves: 1\n```\n\n"
    },
    "maxBy": {
      "name": "maxBy",
      "desc": "( Lb Tb -- Max ): leaves the maximum value in List\n block. Each element of List block is transformed using\n Transformation block. See `minmaxBy`.\n\n```\n[ 1 2 3 ] [ ] maxBy leaves: 3\n```\n\n"
    },
    "sumBy": {
      "name": "sumBy",
      "desc": "( Lb Tb -- Sum ): leaves Sum of List block elements\n transformed into decimals by Transformation block.\n Similar to `minmaxBy`.\n\n```\n[ 'a' 'aaa' 'aa' ] [ count ] sumBy leaves: 6\n```\n\n"
    },
    "sumBy:": {
      "name": "sumBy:",
      "desc": "( Lb sumBy: Tb -- Sum ): infix version of `sumBy`.\n\n```\n[ 'a' 'aaa' 'aa' ] sumBy: count leaves: 6\n```\n\n"
    },
    "productBy": {
      "name": "productBy",
      "desc": "( Lb Tb -- P ): leaves Product of List block elements\n transformed into decimals by Transformation block. Similar\n to `sumBy`.\n\n```\n[ 'dave' 'john' ] [ count ] productBy leaves: 16 \"4 * 4\"\n```\n\n"
    },
    "productBy:": {
      "name": "productBy:",
      "desc": "( Lb productBy: Tb -- Sum ): infix version of `productBy`.\n\n```\n[ 'dave' 'john' ] productBy: count leaves: 16 \"4 * 4\"\n```\n\n"
    },
    "collect": {
      "name": "collect",
      "desc": "( N B -- Lb ): leaves a List block with N results of\n opening Block with the current N. Basically a combo of\n `times` and `map`. `break` and `next` are available. The\n current result is skipped if stack is empty after opening\n Block.\n\n```\n10 collect: [ [ odd? ] ~> drop ]\n       map: [ 2 * ]\n      only: [ 10 < ]\n    leaves: [ [ 0 4 8 ] ]\n```\n\n"
    },
    "collect:": {
      "name": "collect:",
      "desc": "( N collect: B -- Lb ): infix version of `collect`."
    },
    "compiledCollect": {
      "name": "compiledCollect",
      "desc": "( N B -- Lb ): same as `collect`, but powered by `compiledTimes`\n under the hood. Faster than `collect` for large N, but slower if\n opened a lot of times in a row.\n\nPlease read `compiledTimes` to understand why have the whole\ndeal with *unsafe* and *fast*.\n\nDoes **not** support `break` and `next`.\n\n"
    },
    "compiledCollect:": {
      "name": "compiledCollect:",
      "desc": "( N compiledCollect: B -- Lb ): infix version of `compiledCollect`."
    },
    "groupBy": {
      "name": "groupBy",
      "desc": "( B Gb -- Gl ): groups forms in Block according to\n Grouper block. Leaves a Group list. Grouper block is\n opened with consequent items on top of an empty stack.\n Grouper block can leave any form except block. Order of\n groups in Group list is the same as in Block, i.e., if\n the first item in Block is is in group G1, then the first\n group in Group list will be G1.\n\nIf necessary, the form Grouper block leaves for a particular\ngroup can be accessed with `.id` on each group block in\nGroup list.\n\nNote though, that Group members do not have access to\ntheir Grouper block's `id`.\n\n```\n[ 1 2 3 ] [ 1 > ] groupBy leaves: [ [ [ 1 ] [ 2 3 ] ] ]\n[ 1 2 3 ] [ 1 <= ] groupBy leaves: [ [ [ 1 ] [ 2 3 ] ] ]\n\n[ 1 2 3 ] [ 1 <= ] groupBy [ .id ] map\n  leaves: [ [ true false ] ] \"The two groups, true and false.\"\n\n[ 1 2 3 ] [ 1 <= 'foo' 'bar' sel ] groupBy [ dup .id 2enclose ] map\n  leaves: [ [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ] ]\n```\n\n"
    },
    "groupBy:": {
      "name": "groupBy:",
      "desc": "( B Gb -- Gl ): infix version of `groupBy`. See\n `groupBy` for information.\n\n```\n[ 1 2 3 ] groupBy: [ 1 > ] leaves: [ [ [ 1 ] [ 2 3 ] ] ]\n[ 1 2 3 ] groupBy: [ 1 <= ] leaves: [ [ [ 1 ] [ 2 3 ] ] ]\n\n[ 1 2 3 ] groupBy: [ 1 <= ] map: [ .id ]\n  leaves: [ [ true false ] ]\n\n[ 1 2 3 ] groupBy: [ 1 <= 'foo' 'bar' sel ] map: [ dup .id 2enclose ]\n  leaves: [ [ [ [ 1 ] 'foo' ] [ [ 2 3 ] 'bar' ] ] ]\n```\n\n"
    },
    "range": {
      "name": "range",
      "desc": "( B E -- Rb ): leaves Range block containing decimals\n between the given Begin, End decimal boundaries: [B; E],\n [E; B] if  E < B.\n\n```\n\"Note: `...` means there's more. These 'leaves:'\n expressions won't run right away.\"\n\n1 100 range leaves: [ 1 2 3 \"...\" 98 99 100 ]\n-10 10 range leaves: [ -10 -9 -8 \"...\" 8 9 10 ]\n10 0 range leaves: [ 10 9 8 \"...\" 0 ]\n```\n\n"
    },
    "to:": {
      "name": "to:",
      "desc": "( B to: E -- Rb ): infix version of `range`.\n\n```\n\"Note: `...` means there's more. These 'leaves:'\n expressions won't run right away.\"\n\n1 to: 100 leaves: [ 1 2 3 \"...\" 98 99 100 ]\n10 to: 0 leaves: [ 10 9 8 \"...\" 0 ]\n```\n\n"
    },
    "from:": {
      "name": "from:",
      "desc": "( B from: Bi to: Ei -- Bs ): takes a slice of Block, starting\n at Begin index, and ending at End index. Both ends are inclusive.\n Leaves the resulting Block slice.\n\nBlock slice is an orphan. Both ends are clamped to Block bounds.\n\n```\n[ ] from: 0 to: 0 leaves: [ [ ] ]\n[ 1 2 3 4 ] from: 1 to: 2 leaves: [ [ 2 3 ] ]\n[ 1 2 3 4 ] from: 0 to: 200 leaves: [ [ 1 2 3 4 ] ]\n[ 1 2 3 4 ] from: 100 to: 200 leaves: [ [ ] ]\n```\n\n"
    },
    "join": {
      "name": "join",
      "desc": "( Fl -- Q ): stitches enquoted forms from Form list and\n leaves the resulting Quote.\n\n```\n[ 'A' 'B' 'C' ] join leaves: 'ABC'\n\n1 $: x\n2 $: y\n[ x '; ' y ] here join leaves: '1; 2'\n```\n\n"
    },
    "sepBy": {
      "name": "sepBy",
      "desc": "( Fl Df -- Q ): stitches enquoted forms from Form\n list and leaves the resulting Quote. Enquotes and\n inserts Delimiter form between the pairs.\n\n```\n[ 'a' 'b' '=' 1 ] ' ' sepBy leaves: 'a b = 1'\n```\n\n"
    },
    "sepBy:": {
      "name": "sepBy:",
      "desc": "( Fl sepBy:/join: D -- Q ): infix version of `sepBy`."
    },
    "join:": {
      "name": "join:",
      "desc": "( Fl sepBy:/join: D -- Q ): infix version of `sepBy`."
    },
    "concat!": {
      "name": "concat!",
      "desc": "( B1 B2 -- B1 ): adds elements before cursor in B2\n after cursor in B1. Advances the cursor in B1 by the\n number of added elements.\n\n```\n[ 1 2 3 ] [ 4 5 6 ] concat!\n  leaves: [ [ 1 2 3 4 5 6 ] ]\n```\n\n"
    },
    "concat": {
      "name": "concat",
      "desc": "( B1 B2 -- Br ): concatenates two Blocks.\n\n```\n[ 1 2 3 ] [ 4 5 6 ] concat\n  leaves: [ [ 1 2 3 4 5 6 ] \"(a new block!)\" ]\n```\n\n"
    },
    "hasDesc?": {
      "name": "hasDesc?",
      "desc": "( B -- true/false ): leaves whether Block has a description."
    },
    "|afterOrToEnd?": {
      "name": "|afterOrToEnd?",
      "desc": "( Lb C -- Sfb true/false ): slides right (see `|slideRight`)\n through List block, executes Condition block for each form under\n the cursor. Stops *after* form if Condition block left true for it.\n Leaves Skipped forms block. Leaves true when Condition matched,\n false when reached the end of List block without a match.\n\nNote: if Condition is not a block, it is wrapped like so:\n`[ C = ]`.\n\nUseful for writing parsers for Novika DSLs.\n\n```\n[ 1 | 2 3 4 5 6 ] $: a\na [ 4 = ] |afterOrToEnd? leaves: [ [ 2 3 ] true ]\na leaves: [ [ 1 2 3 4 | 5 6 ] ]\n```\n\n"
    },
    "|afterOrToEnd?:": {
      "name": "|afterOrToEnd?:",
      "desc": "( Lb |afterOrToEnd?: C -- Sfb ): infix version of `|afterOrToEnd?`."
    },
    "|afterOrToEnd": {
      "name": "|afterOrToEnd",
      "desc": "( Lb C -- Sfb ): same as `|afterOrToEnd?`, but disregards\nwhether the end was reached instead of Condition matching."
    },
    "|afterOrToEnd:": {
      "name": "|afterOrToEnd:",
      "desc": "( Lb |afterOrToEnd: C -- Sfb ): infix version of `|afterOrToEnd`."
    },
    "|afterOrDie": {
      "name": "|afterOrDie",
      "desc": "( Lb C -- Sfb ): same as `|afterOrToEnd?`, but dies when reached\n end of List block without matching.\n\nWhen Condition is a block, its desc, if available, is\ndisplayed as the thing that was expected. Otherwise,\nCondition itself is displayed.\n\n```\n[ 1 | 2 3 4 5 6 ] $: a\na 4 |afterOrDie leaves: [ [ 2 3 ] ]\na leaves: [ [ 1 2 3 4 | 5 6 ] ]\n```\n\n"
    },
    "|afterOrDie:": {
      "name": "|afterOrDie:",
      "desc": "( Lb |afterOrDie: C -- Sfb ): infix version of `|afterOrDie`."
    },
    "|beforeOrToEnd?": {
      "name": "|beforeOrToEnd?",
      "desc": "( Lb C -- Sfb true/false ): similar to `|afterOrToEnd?`, but\n leaves the cursor in List block *before* the matching\n item.\n\n```\n[ 1 | 2 3 4 5 6 ] $: a\na 4 |beforeOrToEnd leaves: [ [ 2 3 ] ]\na leaves: [ [ 1 2 3 | 4 5 6 ] ]\n```\n\n"
    },
    "|beforeOrToEnd?:": {
      "name": "|beforeOrToEnd?:",
      "desc": "( Lb |beforeOrToEnd?: C -- Sfb true/false ): infix version of `|beforeOrToEnd?`."
    },
    "|beforeOrToEnd": {
      "name": "|beforeOrToEnd",
      "desc": "( Lb C -- Sfb ): same as `|beforeOrToEnd?`, but disregards\nwhether the end was reached instead of Condition\nmatching."
    },
    "|beforeOrToEnd:": {
      "name": "|beforeOrToEnd:",
      "desc": "( Lb |beforeOrToEnd: C -- Sfb ): infix version of `|beforeOrToEnd`."
    },
    "|beforeOrDie": {
      "name": "|beforeOrDie",
      "desc": "( Lb C -- Sfb ): similar to `|afterOrDie`, but leaves the\n cursor in List block *before* the matching item.\n\n```\n[ 1 | 2 3 4 5 6 ] $: a\na 4 |beforeOrDie leaves: [ [ 2 3 ] ]\na leaves: [ [ 1 2 3 | 4 5 6 ] ]\n```\n\n"
    },
    "|beforeOrDie:": {
      "name": "|beforeOrDie:",
      "desc": "( Lb |beforeOrDie: C -- Sfb ): infix version of `|beforeOrDie`."
    },
    "tally": {
      "name": "tally",
      "desc": "( L B -- S ): opens Block with each `form count` pair,\n preceded by previous results of Block (if any), as the\n active Stack. Forms are taken from List block. Resulting\n Stack is left.\n\n```\n[ 1 2 2 3 3 2 1 ] [ swap 2echo ] tally\n\"STDOUT: 2⏎ 1⏎ (two ones)\"\n\"STDOUT: 3⏎ 2⏎ (three twos\"\n\"STDOUT: 2⏎ 3⏎ (two threes)\"\n\nleaves: [ ] \"all were consumed by 2echo\"\n```\n\n"
    },
    "tally:": {
      "name": "tally:",
      "desc": "( L tally: B -- ): infix version of `tally`."
    },
    "sortUsing!:": {
      "name": "sortUsing!:",
      "desc": "( B sortUsing!: Cb -- B ): infix version of `sortUsing!`.\n\n```\n[ 3 1 2 4 0 -3 ] sortUsing!: - leaves: [ [ -3 0 1 2 3 4 ] ]\n```\n\n"
    },
    "sort!": {
      "name": "sort!",
      "desc": "( Dlb -- Dlb ): inplace sort of Decimal list block.\n Chokes on non-decimal forms.\n\n```\n[ 3 1 2 4 0 -3 ] sort! leaves: [ [ -3 0 1 2 3 4 ] ]\n```\n\n"
    },
    "sortBy!": {
      "name": "sortBy!",
      "desc": "( B Mb -- B ): inplace sort for Block using the\n Mapper block, which must be able to map *all* forms\n in Block to a decimal.\n\n```\n[ 'hi' 'worldish' 'hi' 'foobar' ] [ count ] sortBy! leaves: [ [ 'hi' 'hi' 'foobar' 'worldish' ] ]\n```\n\n"
    },
    "sortBy!:": {
      "name": "sortBy!:",
      "desc": "( B sortBy!: Mb -- B ): infix version of `sortBy!`.\n\n```\n[ 'hi' 'worldish' 'hi' 'foobar' ] sortBy!: count leaves: [ [ 'hi' 'hi' 'foobar' 'worldish' ] ]\n```\n\n"
    },
    "|around": {
      "name": "|around",
      "desc": "( L N -- Fab ): leaves a Forms around block with N/2 forms\n before the cursor, and N/2 forms after the cursor in List.\n\nForms around block may consist of less than N forms, but only\nwhen there are less than N forms in List (in this case, Forms\naround block is essentially a shallow copy of List).\n\nForms around block is an orphan with two dictionary entries:\n`start`, which stores the index of the first item in List,\nand `end`, which stores the index of the last item in List.\n\nDies when N is zero or when List is empty, because in these\ncases it is impossible to find the pivot form.\n\n```\n[ 1 2 3 4 ] $: block\nblock 2 |to\nblock echo \"STDOUT: [ 1 2 | 3 4 ]⏎ \"\nblock 2 |around echo \"STDOUT: [ 2 3 · ${start :: 1} ${end :: 3} ]⏎ \"\n```\n\n"
    },
    "|ring": {
      "name": "|ring",
      "desc": "( B N -- Rb ): leaves a Ring block of N (if possible)\n forms left and right of the cursor in Block. If either\n side contains less forms than N, leaves all forms found\n in it. Puts cursor in Ring block after last form in the\n left-hand side of the ring.\n\nDies if N <= 0 (there are only >zero rings). Dies if Block\nis empty (because it cannot contain >zero rings).\n\nRing block also holds Block index of where the first\nform of the ring is (entry `firstAt`), and where the\nlast form of the ring is (entry `lastAt`).\n\nHere is a diagram which may help you understand what a\nring is:\n\n```text\n┌───────────────────────┐\n│ 3 |ring               │\n│                       │\n│   ┌───────────────┐   │\n│   │ 2 |ring       │   │\n│   │               │   │\n│   │   ┌───────┐   │   │\n│   │   │1 |ring│   │   │\n│   │   │       │   │   │\n│ 1 │ 2 │ 3 | 4 │ 5 │ 6 │\n│   │   │       │   │   │\n│   │   └───────┘   │   │\n│   │               │   │\n│   └───────────────┘   │\n│                       │\n└───────────────────────┘\n```\n\nAnd in code:\n\n```\n[ 1 2 3 | 4 5 6 ] $: block\n\nblock 1 |ring toQuote leaves: '[ 3 | 4 · ${firstAt :: 2} ${lastAt :: 3} ]'\nblock 2 |ring toQuote leaves: '[ 2 3 | 4 5 · ${firstAt :: 1} ${lastAt :: 4} ]'\nblock 3 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]'\nblock 4 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]'\nblock 100 |ring toQuote leaves: '[ 1 2 3 | 4 5 6 · ${firstAt :: 0} ${lastAt :: 5} ]'\n```\n\n"
    },
    "sample": {
      "name": "sample",
      "desc": "( B -- Rf ): leaves a Random form from the given Block.\n\n```\n[ 1 2 3 4 ] sample leaves: \"... a random form from the block, let's say 2\"\n```\n\n"
    },
    "samples": {
      "name": "samples",
      "desc": "( B C samples -- S ): samples the given Block Count times,\n and leaves the resulting block of Samples.\n\n```\n[ 1 2 3 4 ] 2 samples leaves: \"... [ (a random form) (a random form) ]\"\n'hello world' 2 samples leaves: \"... [ (a random quote) (a random quote) ]\"\n```\n\n"
    },
    "sample:": {
      "name": "sample:",
      "desc": "( B sample: C -- S ): infix version of `samples`.\n\n```\n[ 1 2 3 4 ] sample: 2 leaves: \"... [ (a random form) (a random form) ]\"\n```\n\n"
    },
    "flat:deep": {
      "name": "flat:deep",
      "desc": "( B -- Dfb ): leaves Deeply flattened block for the\n given Block.\n\nSelf-references are ignored. **Most importantly**, deeply\nflattened block is a child of Block.\n\n```\n[ ] flat leaves: [ [ ] ]\n[ 1 2 3 ] flat leaves: [ [ 1 2 3 ] ]\n[ [ 1 ] [ 2 ] [ 3 ] ] flat leaves: [ [ 1 2 3 ] ]\n\"... etc.\"\n\n[ [ 100 ] $: x ] obj $: foo\n\nfoo flat $: flattened\nflattened leaves: [ [ 100 $: x ] ]\nflattened.x leaves: 100\n\"... etc.\"\n\n[ ] $: bar\nbar bar shove\nbar flat leaves: [ [ ] ]\n```\n\n"
    },
    "flat": {
      "name": "flat",
      "desc": "( B -- Dfb ): leaves Deeply flattened block for the\n given Block.\n\nSelf-references are ignored. **Most importantly**, deeply\nflattened block is a child of Block.\n\n```\n[ ] flat leaves: [ [ ] ]\n[ 1 2 3 ] flat leaves: [ [ 1 2 3 ] ]\n[ [ 1 ] [ 2 ] [ 3 ] ] flat leaves: [ [ 1 2 3 ] ]\n\"... etc.\"\n\n[ [ 100 ] $: x ] obj $: foo\n\nfoo flat $: flattened\nflattened leaves: [ [ 100 $: x ] ]\nflattened.x leaves: 100\n\"... etc.\"\n\n[ ] $: bar\nbar bar shove\nbar flat leaves: [ [ ] ]\n```\n\n"
    },
    "gsub": {
      "name": "gsub",
      "desc": "( B P R -- ): global (of all occurences), deep (nesting\n doesn't matter) substitution of Pattern with Replacement\n in Block.\n\nSome important points:\n\n* Self-references are skipped.\n\n* This word goes through the whole block, no matter where the\n  cursor was beforehand, sliding the latter *back to front*\n  (from the end to the beginning), and afterwards restoring its\n  position to that before substitution (taking growth or shrinkage\n  due to substitution into account).\n\n* If Pattern is a block, it is opened with Block as the stack\n  and cursor just after the form-to-check. This word then expects\n  Pattern to leave a truthy/falsey value *for whether the visited\n  form should be replaced* with Replacement.\n\n* The stack effect for Pattern, in case it is a block, must be\n  the following: `( ... F -- ... F true/false )`, where F is the\n  form to check. Otherwise, *stable behavior is yours to ensure*!\n\n* If Pattern is not a block, the following template block is\n  used instead: `[ dup Pattern = ]`.\n\n* Replacement, when this word decides it's time to use it, is\n  opened with Block as the stack and cursor as if it was after\n  the form- to-replace, *but without the latter on the stack*.\n  Insertion is expected. Therefore, the stack effect of Replacement\n  is recommended to be `( -- ... )` where `...` stands for one\n  or more forms. Anything is possible, though, even cursor movement.\n  But in this case remember that *stable behavior is yours to ensure*.\n\n```\n[ `a `b + ] $: temp\n\ntemp #`a 100 gsub\ntemp #`b 200 gsub\ntemp leaves: [ [ 100 200 + ] ]\ntemp open leaves: 300\n```\n\n"
    },
    "gsub:": {
      "name": "gsub:",
      "desc": "( B P gsub: R -- ): infix version of `gsub`.\n\n```\n[ 100 `cmd\n  200 `cmd ] $: block\n\nblock #`cmd gsub: #echo\nblock leaves: [ [ 100 echo 200 echo ] ]\nblock open \"STDOUT: 100⏎200⏎\"\n```\n\n"
    },
    "gsubOn:": {
      "name": "gsubOn:",
      "desc": "( B R gsubOn: P -- ): another infix version of `gsub`.\n\n```\n[ 100 `cmdA\n  200 `cmdB ] $: block\n\nblock [ 2 * #echo ] gsubOn: #`cmdA\nblock [ 4 * #echo ] gsubOn: #`cmdB\n\nblock leaves: [ [ 200 echo 800 echo ] ]\nblock open \"STDOUT: 200⏎800⏎\"\n```\n\n"
    },
    "console:width": {
      "name": "console:width",
      "desc": "( -- Cw ): leaves Console width (in columns)."
    },
    "console:height": {
      "name": "console:height",
      "desc": "( -- Ch ): leaves Console height (in rows)."
    },
    "<=": {
      "name": "<=",
      "desc": "( A B -- true/false ): leaves whether A <= B."
    },
    ">": {
      "name": ">",
      "desc": "( A B -- true/false ): leaves whether A > B."
    },
    ">=": {
      "name": ">=",
      "desc": "( A B -- true/false ): leaves whether A >= B."
    },
    "zero?": {
      "name": "zero?",
      "desc": "( A -- true/false ): leaves whether A = 0"
    },
    "positive?": {
      "name": "positive?",
      "desc": "( A -- true/false ): leaves whether A >= 0"
    },
    "negative?": {
      "name": "negative?",
      "desc": "( A -- true/false ): leaves whether A < 9"
    },
    "/?": {
      "name": "/?",
      "desc": "( A B -- true/false ): leaves whether A is divisible by B."
    },
    "even?": {
      "name": "even?",
      "desc": "( N -- true/false ): leaves whether A is even (divisible by two)."
    },
    "odd?": {
      "name": "odd?",
      "desc": "( N -- true/false ): leaves whether A is odd."
    },
    "empty?": {
      "name": "empty?",
      "desc": "( B -- true/false ): leaves whether Block is empty."
    },
    "false?": {
      "name": "false?",
      "desc": "( F -- true/false ): Leaves whether Form is `false`."
    },
    "true?": {
      "name": "true?",
      "desc": "( F --  true/false ): converts Form into boolean."
    },
    "not": {
      "name": "not",
      "desc": "( F -- true/false ): leaves inverse boolean for Form."
    },
    "runTestsInGroup:": {
      "name": "runTestsInGroup:",
      "desc": "( runTestsInGroup: G -- B ): runs all test cases under Group.\nReports the results on-the-fly. Dies if Group doesn't exist.\nLeaves Boolean for whether all tests in Group succeeded."
    },
    "describe": {
      "name": "describe",
      "desc": "( describe Dq B -- ): groups multiple test cases (listed\n in Block) under a single Description quote.\n\nDescribes can be grouped under so-called *test groups*. Unless\nyou provide a group (or several) yourself, the describe will\nbelong to the test group called 'rogue'.\n\nYou can specify one or more groups the describe will belong\nto using `in`. The following describes are grouped under 'rogue':\n\n```\ndescribe 'Foo' [\n  it should 'work' [ \"...\" ]\n]\n\ndescribe 'Bar' [\n  it should 'a' [ \"...\" ]\n  it should 'b' [ \"...\" ]\n]\n```\n\nThe following describes are grouped under 'foo':\n\n```\ndescribe 'Foo' [\n  in foo\n\n  it should 'work' [ \"...\" ]\n]\n\ndescribe 'Bar' [\n  in foo\n\n  it should 'a' [ \"...\" ]\n  it should 'b' [ \"...\" ]\n]\n```\n\nYou can run a test group using the word `runTestsInGroup:`.\nIt will run all tests and echo the test report to the standard\noutput on the fly. With describes as above, that is, belonging\nto the group 'foo', you can run them like so:\n\n```\nrunTestsInGroup: foo\n```\n\nDescribes can belong to multiple groups:\n\n```\ndescribe 'Foo' [\n  in a\n  in b\n\n  it should 'happy path' [ true true assert= ]\n]\n\ndescribe 'Bar' [\n  in a\n\n  it should 'sad path' [ true false assert= ]\n]\n\nrunTestsInGroup: a  \"runs Foo and Bar\"\nrunTestsInGroup: b  \"runs Foo\"\n```\n\n"
    },
    "leaves:": {
      "name": "leaves:",
      "desc": "( ... leaves: B -- ... ): compares active stack with\n Block: noop if equal via `=`, otherwise, dies. Note that\n only N last items in active stack are compared with Block,\n where N is the amount of items in Block.\n\n```\n100 leaves: [ 100 ] \"Stack has 100 now.\"\n200 leaves: [ 100 200 ] \"Stack has 100 and 200.\"\n300 leaves: [ 300 ] \"Stack has 100 and 200 and 300\"\n```\n\n"
    },
    "choose": {
      "name": "choose",
      "desc": "( F Cl -- Cb' ): high-level conditional. Acts similar to `case`\n or `switch` in other languages. Takes a Form to match over, and\n a Case list in the form `[ Condition Case-Body Condition Case-Body ... ]`.\n Leaves the result of Case body corresponding to the condition that\n matched Form, otherwise (if no cases matched), Form itself.\n\n```novika\n1 to: 100 each: [\n  [ [ 15 /? ] 'FizzBuzz'\n    [  5 /? ] 'Buzz'\n    [  3 /? ] 'Fizz'\n  ] choose echo\n]\n```\n\n"
    },
    "_": {
      "name": "_",
      "desc": "( A B -- B A ): same as `swap`, but is more readable and\n compact in certain scenarios.\n\n```\n[ 'Judy' 'Mark' 'Fabian' 'Huggee' ] $: pets\n\norphan $: ages\n\npets each: [\n  ages _ (0 randTo: 15) pushes\n]\n\n\"Your numbers will probably be different because we're\n generating them randomly:\"\nages -> 'Judy' leaves: 1\nages -> 'Mark' leaves: 8\nages -> 'Fabian' leaves: 11\nages -> 'Huggee' leaves: 14\n```\n\n"
    },
    "${": {
      "name": "${",
      "desc": "( E... -- ): same as `$:` but allows to define multiple pusher\n Entries simultaneously, and in the 'human-readable' order.\n\n```\n[ ${ x y } this ] @: point\n\n100 200 point -> [ x y ]\n  leaves: [ [ 100 200 ] ]\n```\n\n"
    },
    "@{": {
      "name": "@{",
      "desc": "( E... -- ): same as `@:`, but allows to define multiple opener\n Entries simultaneously, and in the 'human-readable' order.\n\n```\n[ @{ x y }\n\n  [ bi*: [x +] [y +] ={ x y } ] @: move\n\n  this\n] @: point\n\n\"Point A has decimals under X and Y\"\n100 200 point $: A\n\n\"Point B is inset some...\"\n[ A.x 10 + ] [ A.y 5 + ] point $: B\n\nA.x A.y leaves: [ 100 200 ]\nB.x B.y leaves: [ 110 205 ]\n\n\"Move A some...\"\n10 10 A.move\n\nA.x A.y leaves: [ 110 210 ]\nB.x B.y leaves: [ 120 215 ]\n```\n\n"
    },
    "={": {
      "name": "={",
      "desc": "( E... -- ): same as `=:`, but allows to submit multiple Entries\n simultaneously, and in the 'human-readable' order.\n\n```\n[ @{ x y }\n\n  [ ={ x y } ] @: update\n\n  this\n] @: point\n\n0 0 point $: A\n\nA.x A.y leaves: [ 0 0 ]\n\n100 200 A.update\n\nA.x A.y leaves: [ 100 200 ]\n```\n\n"
    },
    "newBlockSet": {
      "name": "newBlockSet",
      "desc": "( -- ::set:: ): a set-like data structure for storing blocks\n (and only blocks) by their address, or some other property based\n on the key (mapper) block, see `::set::/keyBy` .\n\nEntry order (and iteration order) is exactly the insertion order.\n\nExposes the following words: `add[:]`, `remove[:]`, `has?`\nand `has:`, `each[:]`, `keyBy[:]`.\n\n```\nnewBlockSet $: set\n\n[ 1 2 ] $: foo\n[ 3 4 ] $: bar\n[ 1 2 ] $: baz\n\nset.add: foo\nset.add: bar\n\nset.has: foo leaves: true\nset.has: bar leaves: true\nset.has: baz leaves: false\n\nset.remove: bar\nset.has: bar leaves: false\n\nset.add: baz\nset.has: baz leaves: true\n\nset.each: [ echo ]\n\"STDOUT: [ 1 2 ]⏎[ 1 2 ]⏎\"\n\n\"The first printed block is `foo` and the second is `baz`.\n Despite looking the same, they are different blocks stored\n at different addresses!\"\n```\n\n"
    },
    "sdl:keysym": {
      "name": "sdl:keysym",
      "desc": "The SDL keysym structure, used in key events.\n\nIf you are looking for translated character input, see\nthe `sdl:textInputEvent`.\n\n* `scancode`: SDL physical key code (see `sdl:scancode:*`)\n* `keycode`: SDL virtual key code.\n* `mod`: current key modifiers.\n\n"
    },
    "sdl:commonEvent": {
      "name": "sdl:commonEvent",
      "desc": "Fields shared by every event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n\n"
    },
    "sdl:displayEvent": {
      "name": "sdl:displayEvent",
      "desc": "Display state change event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `display`: the associated display index.\n* `event`: one of `sdl:displayEvent:*`.\n* `data1`: event dependent data.\n\n"
    },
    "sdl:windowEvent": {
      "name": "sdl:windowEvent",
      "desc": "Window state change event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: the associated window.\n* `event`: one of `sdl:windowEvent:*`.\n* `data1`: event dependent data.\n* `data2`: event dependent data.\n\n"
    },
    "sdl:keyboardEvent": {
      "name": "sdl:keyboardEvent",
      "desc": "Keyboard button event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with keyboard focus, if any.\n* `state`: `sdl:pressedState` or `sdl:releasedState`\n* `repeat`: non-zero if this is a key repeat\n* `event`: one of `sdl:windowEvent:*`.\n* `keysym`: the key that was pressed or released, see `sdl:keysym`.\n\n"
    },
    "sdl:textEditingEvent": {
      "name": "sdl:textEditingEvent",
      "desc": "Keyboard text editing event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with keyboard focus, if any.\n* `text`: points to 32 `u8`s of the the editing text.\n* `start`: the start cursor of selected editing text.\n* `length`: the length of selected editing text.\n\n"
    },
    "sdl:textEditingEvent*": {
      "name": "sdl:textEditingEvent*",
      "desc": "Extended keyboard text editing event when text would be\n truncated if stored in the text buffer `sdl:textEditingEvent`.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with keyboard focus, if any.\n* `text`: the editing text, which should be freed with `sdl:free`,\n  and will not be NULL.\n* `start`: the start cursor of selected editing text.\n* `length`: the length of selected editing text.\n\n"
    },
    "sdl:textInputEvent": {
      "name": "sdl:textInputEvent",
      "desc": "Keyboard text input event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with keyboard focus, if any.\n* `text`: points to 32 `u8`s of the the editing text.\n\n"
    },
    "sdl:mouseMotionEvent": {
      "name": "sdl:mouseMotionEvent",
      "desc": "Mouse motion event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with mouse focus, if any.\n* `which`: the mouse instance id, or `sdl:touchMouseId`\n* `state`: the current button state (`sdl:pressedState` or `sdl:releasedState`).\n* `x`: X coordinate, relative to window.\n* `y`: Y coordinate, relative to window.\n* `xrel`: The relative motion in the X direction.\n* `yrel`: The relative motion in the Y direction.\n\n"
    },
    "sdl:mouseButtonEvent": {
      "name": "sdl:mouseButtonEvent",
      "desc": "Mouse button event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with mouse focus, if any.\n* `which`: the mouse instance id, or `sdl:touchMouseId`.\n* `button`: the mouse button index.\n* `state`: the current button state (`sdl:pressedState` or `sdl:releasedState`).\n* `clicks`: 1 for single-click, 2 for double-click, etc.\n* `x`: X coordinate, relative to window.\n* `y`: Y coordinate, relative to window.\n\n"
    },
    "sdl:mouseWheelEvent": {
      "name": "sdl:mouseWheelEvent",
      "desc": "Mouse wheel event structure.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `windowID`: The window with mouse focus, if any.\n* `which`: the mouse instance id, or `sdl:touchMouseId`.\n* `x`: the amount scrolled horizontally, positive to the right\n  and negative to the left.\n* `y`: the amount scrolled vertically, positive away from the\n  user and negative toward the user.\n* `direction`: set to one of `sdl:mouseWheel:*`. When\n  `sdl:mouseWheel:flipped`, the values in X and Y will be\n  opposite. Multiply by -1 to change them back.\n* `preciseX`: the amount scrolled horizontally, positive to the\n  right and negative to the left, with float precision.\n* `preciseY`: The amount scrolled vertically, positive away from\n  the user and negative toward the user, with float precision.\n* `mouseX`: X coordinate, relative to window.\n* `mouseY`: Y coordinate, relative to window.\n\n"
    },
    "sdl:dropEvent": {
      "name": "sdl:dropEvent",
      "desc": "An event used to request a file open by the system.\n This event is enabled by default, you can disable it\n with `sdl:eventState`.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n* `file`: points to the file name, which should be freed with\n  `sdl:free`. Is NULL on begin/complete.\n* `windowID`: the window that was dropped on, if any.\n\n"
    },
    "sdl:quitEvent": {
      "name": "sdl:quitEvent",
      "desc": "The \"quit requested\" event.\n\n* `timestamp`: in milliseconds, populated using `sdl:ticks`.\n\n"
    },
    "sdl:event": {
      "name": "sdl:event",
      "desc": "General event structure.\n\n* `type`: event type, shared with all events.\n\nThe following is a list of event types/fields that are implemented.\nThose that are simply `pointer`s are unimplemented.\n\n* `common`: common event data (see `sdl:commonEvent`).\n* `display`: display event data (see `sdl:displayEvent`).\n* `window`: window event data (see `sdl:windowEvent`).\n* `key`: keyboard event data (see `sdl:keyboardEvent`).\n* `edit`: text editing event data (see `sdl:textEditingEvent`).\n* `edit*`: extended text editing event data (see `sdl:textEditingEvent*`).\n* `text`: text input event data (see `sdl:textInputEvent`).\n* `motion`: mouse motion event data (see `sdl:mouseMotionEvent`).\n* `button`: mouse button event data (see `sdl:mouseButtonEvent`).\n* `wheel`: mouse wheel event data (see `sdl:mouseWheelEvent`).\n* `quit`: quit request event data (see `sdl:quitEvent`).\n* `drop`: drag and drop event data (see `sdl:dropEvent`).\n\n"
    },
    "sdl:intPoint": {
      "name": "sdl:intPoint",
      "desc": "The structure that defines a point (integer).\n\n* `x`: the X coordinate of the point.\n* `y`: the Y coordinate of the point.\n\n"
    },
    "sdl:floatPoint": {
      "name": "sdl:floatPoint",
      "desc": "The structure that defines a point (floating point).\n\n* `x`: the X coordinate of the point.\n* `y`: the Y coordinate of the point.\n\n"
    },
    "sdl:intRect": {
      "name": "sdl:intRect",
      "desc": "A rectangle, with the origin at the upper left (integer).\n\n* `x`: the X coordinate of the rectangle.\n* `y`: the Y coordinate of the rectangle.\n* `w`: width of the rectangle.\n* `h`: height of the rectangle.\n\n"
    },
    "sdl:floatRect": {
      "name": "sdl:floatRect",
      "desc": "A rectangle, with the origin at the upper left (floating point).\n\n* `x`: the X coordinate of the rectangle.\n* `y`: the Y coordinate of the rectangle.\n* `w`: width of the rectangle.\n* `h`: height of the rectangle.\n\n"
    },
    "sdl:intRectsIntersect?": {
      "name": "sdl:intRectsIntersect?",
      "desc": "( R1 R2 -- 0/1 ): leaves whether the two integer Rectangles\nintersect. If either is null will leave 0.\n\n"
    },
    "sdl:floatRectsIntersect?": {
      "name": "sdl:floatRectsIntersect?",
      "desc": "( R1 R2 -- 0/1 ): leaves whether the two floating point\nRectangles intersect. If either is null will leave 0.\n\n"
    },
    "sdl:writeIntRectIntersection?": {
      "name": "sdl:writeIntRectIntersection?",
      "desc": "( R1 R2 Rh -- 0/1 ): calculate the intersection of two integer\nRectangles and writes it into Result hole.\n\n"
    },
    "sdl:writeFloatRectIntersection?": {
      "name": "sdl:writeFloatRectIntersection?",
      "desc": "( R1 R2 Rh -- 0/1 ): calculate the intersection of two floating\npoint Rectangles and writes it into Result hole.\n\n"
    },
    "sdl:writeIntRectUnion?": {
      "name": "sdl:writeIntRectUnion?",
      "desc": "( R1 R2 Rh -- 0/1 ): calculate the union of two integer Rectangles\nand writes it into Result hole.\n\n"
    },
    "sdl:writeFloatRectUnion?": {
      "name": "sdl:writeFloatRectUnion?",
      "desc": "( R1 R2 Rh -- 0/1 ): calculate the union of two floating point\nRectangles and write it into Result hole.\n\n"
    },
    "sdl:color": {
      "name": "sdl:color",
      "desc": "Represents a color.\n\n* `r`: the red component in the range 0-255.\n* `g`: the green component in the range 0-255.\n* `b`: the blue component in the range 0-255.\n* `a`: the alpha component in the range 0-255.\n\n"
    },
    "sdl:palette": {
      "name": "sdl:palette",
      "desc": "Palette information.\n\n* `ncolors`: the number of colors in the palette.\n* `colors`: an array of `sdl:color`s representing the palette.\n\n"
    },
    "sdl:pixelFormat": {
      "name": "sdl:pixelFormat",
      "desc": "Pixel format information. Everything is read-only.\n\n* `format`: one of `sdl:pixelFormat:*`\n* `palette`: an `sdl:palette` structure associated with this pixel\n  format, or null if the format doesn't have a palette.\n* `bitsPerPixel`: the number of significant bits in a pixel value,\n  e.g.: 8, 15, 16, 24, 32.\n* `bytesPerPixel`: the number of bytes required to hold a pixel\n  value, e.g.: 1, 2, 3, 4.\n* `rmask`: a mask representing the location of the red component\n   of the pixel.\n* `gmask`: a mask representing the location of the green component\n   of the pixel.\n* `bmask`: a mask representing the location of the blue component\n   of the pixel.\n* `amask`: a mask representing the location of the alpha component\n   of the pixel or 0 if the pixel format doesn't have any alpha\n   information.\n\n"
    },
    "sdl:surface": {
      "name": "sdl:surface",
      "desc": "A collection of pixels used in software blitting.\n\n* Read-only `format`: the format of the pixels stored in the\n  surface.  See `sdl:pixelFormat`.\n* Read-only `w`, `h`: the width and height in pixels.\n* Read-only `pitch`: the length of a row of pixels in bytes.\n* Read-write `pixels`: the pointer to the actual pixel data.\n* Read-write `userdata`: an arbitrary pointer you can set.\n* Read-only `clipRect`: an `sdl:intRect` structure used to clip\n  blits to the surface. Can be set by `sdl:setClipRect`.\n\n"
    },
    "sdl:init": {
      "name": "sdl:init",
      "desc": "( F -- S ): initializes the SDL library given subsystem initialization\nFlags (any of `sdl:init:*` OR'd together). Leaves 0 on success or a negative\nerror code on failure; use `sdl:error` for more information."
    },
    "sdl:deinit": {
      "name": "sdl:deinit",
      "desc": "( F -- ): shuts down specific SDL subsystems given any of the flags\n used by `sdl:init`.\n\nYou still need to call `sdl:quit` even if you close all open subsystems\nwith `sdl:deinit`.\n\n"
    },
    "sdl:createWindow": {
      "name": "sdl:createWindow",
      "desc": "( T X Y W H F -- P ): creates a window and leaves a Pointer to it\n (or null if there was an error).\n\nThe window is created with the given Title, at the specified X and Y\ncoordinates (these can also be set to `sdl:window:centered` or\n`sdl:window:positionUndefined`), with the specified Width and Height\n(in screen coordinates), and according to Flags.\n\nSee `sdl:window:*` for Flags.\n\n"
    },
    "sdl:createRenderer": {
      "name": "sdl:createRenderer",
      "desc": "( Wp I F -- P ): creates a 2D rendering context for a Window pointer\n and leaves a pointer to it (or null if there was an error).\n\nWindow pointer is a pointer to the window where rendering is displayed.\n\nIndex is the index of the rendering driver to initialize, or -1 to\ninitialize the first one supporting the requested flags.\n\nFlags is one or more `sdl:renderer:*` flags OR'd together.\n\n"
    },
    "sdl:error": {
      "name": "sdl:error",
      "desc": "[foreign function: SDL_GetError]"
    },
    "sdl:ticks": {
      "name": "sdl:ticks",
      "desc": "[foreign function: SDL_GetTicks]"
    },
    "sdl:renderClear": {
      "name": "sdl:renderClear",
      "desc": "[foreign function: SDL_RenderClear]"
    },
    "sdl:setRenderDrawColor": {
      "name": "sdl:setRenderDrawColor",
      "desc": "[foreign function: SDL_SetRenderDrawColor]"
    },
    "sdl:fillRect": {
      "name": "sdl:fillRect",
      "desc": "[foreign function: SDL_RenderFillRect]"
    },
    "sdl:textureFromSurface": {
      "name": "sdl:textureFromSurface",
      "desc": "[foreign function: SDL_CreateTextureFromSurface]"
    },
    "sdl:destroyTexture": {
      "name": "sdl:destroyTexture",
      "desc": "[foreign function: SDL_DestroyTexture]"
    },
    "sdl:destroyWindow": {
      "name": "sdl:destroyWindow",
      "desc": "[foreign function: SDL_DestroyWindow]"
    },
    "sdl:window:setTitle": {
      "name": "sdl:window:setTitle",
      "desc": "[foreign function: SDL_SetWindowTitle]"
    },
    "sdl:window:setSize": {
      "name": "sdl:window:setSize",
      "desc": "[foreign function: SDL_SetWindowSize]"
    },
    "sdl:destroyRenderer": {
      "name": "sdl:destroyRenderer",
      "desc": "[foreign function: SDL_DestroyRenderer]"
    },
    "sdl:renderCopy": {
      "name": "sdl:renderCopy",
      "desc": "[foreign function: SDL_RenderCopy]"
    },
    "sdl:renderPresent": {
      "name": "sdl:renderPresent",
      "desc": "[foreign function: SDL_RenderPresent]"
    },
    "sdl:pollEvent": {
      "name": "sdl:pollEvent",
      "desc": "[foreign function: SDL_PollEvent]"
    },
    "sdl:waitEvent": {
      "name": "sdl:waitEvent",
      "desc": "[foreign function: SDL_WaitEvent]"
    },
    "sdl:freeSurface": {
      "name": "sdl:freeSurface",
      "desc": "[foreign function: SDL_FreeSurface]"
    },
    "sdl:quit": {
      "name": "sdl:quit",
      "desc": "[foreign function: SDL_Quit]"
    },
    "sdl:ensure": {
      "name": "sdl:ensure",
      "desc": "( S -- ): dies with `sdl:error` if Status is negative.\n\nSome SDL and SDL TTF functions return negative integers\nto signal an error. In this case, this word will die\npreventing the following code to be executed, so you\ndon't have to worry about handling SDl errors.\n\nNote that by dying you may cause some resources to *not*\nbe freed. Keeping track of that is a task for a higher-\nlevel wrapper around these bingings. This word nor any\nword that is part of these bindings won't do anything\nabout it.\n\n"
    },
    "sdl:notNull": {
      "name": "sdl:notNull",
      "desc": "( P -- ): dies if Pointer is NULL, that is, if Pointer\n is equal to `0`.\n\nNovika uses decimals to represent pointers, which is unsafe\nbut OK for such low-level code. This word allows you to catch\nand die on NULLs rather than handling them explicitly, which\nis a bit more tedious.\n\nNote that by dying you may cause some resources to *not*\nbe freed. Keeping track of that is a task for a higher-\nlevel wrapper around these bingings. This word nor any\nword that is part of these bindings won't do anything\nabout it.\n\n"
    },
    "sdl:ttf:init": {
      "name": "sdl:ttf:init",
      "desc": "( -- 0/-1 ): initializes the truetype font API.\n\nMust be called before using other functions in this\nlibrary, except `sdl:ttf:init?`. SDL does not have to\nbe initialized before this call.\n\nLeaves 0 if initialization was successful or -1 if an\nerror occured. Use `sdl:error` to get a human-readable\nerror message for this word and for words in this library\nwhich leave 0/-1 to signal an error.\n\n"
    },
    "sdl:ttf:quit": {
      "name": "sdl:ttf:quit",
      "desc": "( -- ): shuts down and cleans up the truetype font API.\n\nAfter calling this the `sdl:ttf` library functions should\nnot be used, except for `sdl:ttf:init?`. You may, of course,\nuse `sdl:ttf:init` to use the functionality again.\n\n"
    },
    "sdl:ttf:open": {
      "name": "sdl:ttf:open",
      "desc": "( Fn Ps -- Fp/0 ): loads and leaves Font pointer from the\n provided File name, uses the given Point size. The latter\n basically translates to pixel height.\n\nLeaves NULL (0) on error.\n\n"
    },
    "sdl:ttf:close": {
      "name": "sdl:ttf:close",
      "desc": "( Fp -- ): free the memory used by font at Foint pointer,\nand free font itself as well. Do not use font after this\nwithout loading a new font to it.\n\n"
    },
    "sdl:ttf:putSize": {
      "name": "sdl:ttf:putSize",
      "desc": "( Fp Q Wh Hh -- 0/-1 ): calculates the resulting surface\n size of Quote rendered using the font behind Font pointer.\n Width is put into Width hole, and height is put into\n Height hole.\n\nConsider using `sdl:ttf:size` which create and read from the\nholes for you.\n\n"
    },
    "sdl:ttf:getSolidSurface": {
      "name": "sdl:ttf:getSolidSurface",
      "desc": "( Fp Q Fc -- Sp ): renders Quote painted with Foreground\n`sdl:color` using font behind Font pointer. Leaves Surface\npointer to a new surface containing the rendered quote,\n*which you must free when it becomes unused*.\n\n"
    },
    "sdl:ttf:getShadedSurface": {
      "name": "sdl:ttf:getShadedSurface",
      "desc": "( Fp Q Fc Bc -- Sp ): renders Quote painted with Foreground\n color (an `sdl:color~`) with background of Background color\n (also an `sdl:color~`), using font behind Font pointer. Leaves\n Surface pointer to a new surface containing the rendered quote,\n *which you must free when it becomes unused*.\n\nSlower but sharper than `sdl:ttf:getSolidSurface`.\n\n"
    },
    "sdl:ttf:getBlendedSurface": {
      "name": "sdl:ttf:getBlendedSurface",
      "desc": "( Fp Q Fc -- Sp ): renders Quote painted with Foreground\n color (an `sdl:color~`), using font behind Font pointer. Leaves\n Surface pointer to a new surface containing the rendered quote,\n *which you must free when it becomes unused*.\n\nThe sharpest but slowest way to render text. Text is blended\nwith whatever is behind.\n\n"
    },
    "sdl:ttf:size": {
      "name": "sdl:ttf:size",
      "desc": "( Fp Q -- W H ): calculates and leaves Width and Height of Quote\nrendered using the font behind Font pointer."
    },
    "novika:version": {
      "name": "novika:version",
      "desc": "( -- Vq ): leaves Version of the frontend as a quote."
    },
    "novika:capabilities": {
      "name": "novika:capabilities",
      "desc": "( -- Lb ): lists the ids of capabilities provided by the\n frontend in List block.\n\n```\n\"Yours may differ!\"\nnovika:capabilities leaves: [ [ 'essential' 'colors' 'console' ] ]\n```"
    },
    "withEchoFg": {
      "name": "withEchoFg",
      "desc": "( C -- ): pushes Color form onto the echo foreground\n color stack."
    },
    "withEchoBg": {
      "name": "withEchoBg",
      "desc": "( C -- ): pushes Color form onto the echo background\n color stack."
    },
    "dropEchoFg": {
      "name": "dropEchoFg",
      "desc": "( -- ): drops a color from the echo foreground color stack."
    },
    "dropEchoBg": {
      "name": "dropEchoBg",
      "desc": "( -- ): drops a color from the echo background color stack."
    },
    "withReverseAppendEcho": {
      "name": "withReverseAppendEcho",
      "desc": "( F -- ): appends Form with foreground and background\n colors swapped with each other (background color is set\n to foreground color, and vice versa).\n\nNote: if unsupported by the output stream, will print\nForm as-is."
    },
    "withEmphasisAppendEcho": {
      "name": "withEmphasisAppendEcho",
      "desc": "( F -- ): same as `withColorAppendEcho`, but also emphasizes\n echo of Form. Bold style is used by default, but implementors\n may choose e.g. italic."
    },
    "withColorAppendEcho": {
      "name": "withColorAppendEcho",
      "desc": "( F -- ): appends Form with last color from the echo\n foreground color stack set as foreground color, and\n last color from the echo background stack set as background\n color, to the standard output stream.\n\nNote: some implementations (particularly Novika's default\nimplementation) choose to restrict foreground and background\ncolors to system's basic 16 colors for compatibility &\nportability. If you want more cross-platform control over\ncolors (and pretty much everything else), take a look at\nconsole capability."
    },
    "appendEcho": {
      "name": "appendEcho",
      "desc": "( F -- ): enquotes and appends Form to the standard\n output stream."
    },
    "readLine": {
      "name": "readLine",
      "desc": "( Pf -- Aq true / false ): enquotes and prints Prompt\n form to the standard output stream. Waits for the user\n to answer, enquotes the answer and leaves it.\n\nIf user answered the prompt, leaves Answer quote followed\nby boolean true. Otherwise, leaves boolean false.\n\n```\n'What is your name? ' readLine => echo\n\n\"INPUT: What is your name? John Doe⏎\"\n\"STDOUT: John Doe⏎\"\n\n\"INPUT: What is your name? <Ctrl-D>\"\n\"[Program exits]\"\n```"
    },
    "reportError": {
      "name": "reportError",
      "desc": "( Eo -- ): reports about an error to the standard error\n stream, given an Error object.\n\nYou can obtain an error object by, e.g., catching it\nin `__died__`."
    },
    "monotonic": {
      "name": "monotonic",
      "desc": "( -- R ): leaves a Reading from the monotonic clock to\n measure elapsed time, in milliseconds.\n\nValues from the monotonic clock and wall clock are not\ncomparable. Monotonic clock should be independent from\ndiscontinuous jumps in the system time, such as leap\nseconds, time zone adjustments or manual changes to the\ncomputer's clock.\n\n```\nmonotonic $: start\n20 nap\nmonotonic $: end\nend start - echo\n\"STDOUT: 20⏎ (approximately)\"\n```"
    },
    "nap": {
      "name": "nap",
      "desc": "( D -- ): sleeps a Duration of time, given in *milliseconds*."
    },
    "bye": {
      "name": "bye",
      "desc": "( Ec -- ): ends the program with the given decimal Exit code."
    },
    "rgb": {
      "name": "rgb",
      "desc": "( R G B -- Cf ): creates a Color form from three decimals\n Red (0-255), Green (0-255), and Blue (0-255).\n\n```\n36 255 255 rgb toQuote leaves: 'rgb(36, 255 ,255)'\n```'"
    },
    "getRGB": {
      "name": "getRGB",
      "desc": "( Cf -- R G B ): leaves Red, Green, Blue values for a\n Color form.\n\n```\n0 25 3 rgb \"rgb(0, 25, 3)\" getRGB leaves: [ 0 25 3 ]\n```"
    },
    "hsl": {
      "name": "hsl",
      "desc": "( H S L -- Cf ): creates a Color form from three decimals\n Hue (0-360, degrees), Saturation (0-100, percents),\n Lightness (0-100, percents).\n\nSince color forms are stored in RGB, the HSL color is\nfirst converted into RGB.\n\n```\n206 35 46 hsl toQuote leaves: 'rgb(76, 123, 158)'\n```"
    },
    "getHSL": {
      "name": "getHSL",
      "desc": "( Cf -- H S L ): leaves Hue, Saturation, Lightness for\n a Color form.\n\n```\n206 35 46 hsl \"rgb(76, 123, 158)\" getHSL leaves: [ 206 35 46 ]\n```"
    },
    "hsv": {
      "name": "hsv",
      "desc": "( H S V -- Cf ): creates a Color form from three decimals\n Hue (0-360, degrees), Saturation (0-100, percents),\n Value (0-100, percents).\n\nSince color forms are stored in RGB, the HSV color is\nfirst converted into RGB.\n\n```\n120 100 100 hsv toQuote leaves: 'rgb(0, 255, 0)'\n```"
    },
    "getHSV": {
      "name": "getHSV",
      "desc": "( Cf -- H S V ): leaves Hue, Saturation, Value for a\n Color form.\n\n```\n180 100 50 hsv \"rgb(0,128,128)\" getHSV leaves: [ 180 100 50 ]\n```"
    },
    "lch": {
      "name": "lch",
      "desc": "( L C H -- Cf ): creates a Color form from three decimals\n Lightness (0-100), Chroma (0-132), Hue (0-360).\n\nSince color forms are stored as RGB, the LCH color is\nfirst converted into RGB.\n\nLCH colors are tricky to implement but very fun to use.\nThat's why they're in Novika's standard library.\n\nCIELAB encloses more colors than sRGB, so some conversion\nimprecisions *are* to be expected because some colors just\nfall out of sRGB gamut (lossiness is especially noticeable\nin LCH -> RGB -> LCH conversions, but it stabilizes on the\nlast step because the last step's LCH is guraranteed to be\ninside the sRGB gamut).\n\nAny color out of the sRGB gamut is brought into the sRGB\ngamut by lowering chroma until it's in the sRGB bounds.\n\nHere is a 'good' conversion, meaning it nicely closes\non itself:\n\n```\n78 74 133 lch $: color\n\ncolor toQuote leaves: 'rgb(122, 215, 85)'\ncolor getLCH leaves: [ 78 74 133 ]\ncolor getLCH lch toQuote leaves: 'rgb(122, 215, 85)''\n\"And so on...\"\n```\n\nAnd here is a bad conversion. At first, though, for it\ndoes stabilize after a few rounds as it falls firmly\ninto the sRGB color space.\n\n```\n74 107 26 lch $: color\ncolor toQuote leaves: 'rgb(255, 154, 151)'\n\n\"Note how many chroma units we lose! Plus, Lab and\n LCH have hue shift on chroma changes, hence 26 -> 25.\"\ncolor getLCH leaves: [ 74 41 25 ]\n\ncolor getLCH lch toQuote leaves: 'rgb(255, 154, 152)'\n\ncolor getLCH lch getLCH leaves: [ 74 41 25 ]\n\"... and so on, conversion had stabilized ...\"\n```\n\nYou don't necessarily have to think about this, because\nthe resulting colors do look very similar, differing in\npoints rather than magnitudes. Just be aware that the\nconversion method used by this word and `getLCH` is lossy\nin some cases."
    },
    "getLCH": {
      "name": "getLCH",
      "desc": "( Cf -- L C H ): leaves Lightness, Chroma, Hue for a Color\n form. Please read documentation for `lch` to understand\n why `a b c lch getLCH` might not leave `a b c`.\n\n```\n78 74 133 lch toQuote leaves: 'rgb(122, 215, 85)'\n78 74 133 lch getLCH leaves: [ 78 74 133 ]\n\n74 107 26 lch toQuote leaves: 'rgb(255, 154, 152)'\n\n\"Chroma lowered to fit into sRGB. Lab and LCH have hue\n shift on chroma changes, 26 -> 25\"\n74 107 26 lch getLCH leaves: [ 74 41 25 ]\n```"
    },
    "withAlpha": {
      "name": "withAlpha",
      "desc": "( Cf A -- Cf' ): leaves Color form with alpha channel\n set to Alpha (0-255).\n\n```\n0 25 3 rgb toQuote leaves: 'rgb(0, 25, 3)'\n0 25 3 rgb 100 withAlpha toQuote leaves: 'rgba(0, 25, 3, 100)'\n```"
    },
    "getAlpha": {
      "name": "getAlpha",
      "desc": "( Cf -- A ): leaves Alpha for the given Color form.\n\n```\n0 25 3 rgb getAlpha leaves: 255 \"Opaque = 255\"\n0 25 3 rgb 100 withAlpha getAlpha leaves: 100\n```"
    },
    "fromPalette": {
      "name": "fromPalette",
      "desc": "( Cf Pb -- Cc ): leaves the Closest color form to Color from\n a Palette block. How close the color is is determined by\n distance: the Closest color is that color in Palette block\n to which Color has least (minimum) distance.\n\n```\n[ 0 0 0 rgb\n  255 0 0 rgb\n  0 255 0 rgb\n  0 0 255 rgb\n  255 255 255 rgb\n] vals $: pal\n\n0 0 0 rgb pal fromPalette toQuote leaves: 'rgb(0, 0, 0)'\n76 175 80 rgb pal fromPalette \"greenish\" toQuote leaves: 'rgb(0, 255, 0)'\n220 237 200 rgb pal fromPalette \"very light green\" toQuote leaves: 'rgb(255, 255, 255)'\n74 20 140 rgb pal fromPalette \"very dark purple\" toQuote leaves: 'rgb(255, 0, 0)'\n```"
    },
    "prototype": {
      "name": "prototype",
      "desc": "( B -- P ): leaves the Prototype of Block."
    },
    "parent": {
      "name": "parent",
      "desc": "( B -- P ): leaves the Parent of Block."
    },
    "address": {
      "name": "address",
      "desc": "( B -- A ): leaves pointer Address of Block."
    },
    "conts": {
      "name": "conts",
      "desc": "( -- Cb ): pushes the Continuations block."
    },
    "cont": {
      "name": "cont",
      "desc": "( -- Cb ): pushes the Continuation block."
    },
    "newContinuation": {
      "name": "newContinuation",
      "desc": "( S B -- C ): creates a Continuation from a Stack and\n a Block."
    },
    "getContBlock": {
      "name": "getContBlock",
      "desc": "( C -- Cb ): leaves the Code block of a Continuation."
    },
    "getContStack": {
      "name": "getContStack",
      "desc": "( C -- Sb ): leaves the Stack block of a Continuation."
    },
    "this": {
      "name": "this",
      "desc": "( -- B ): pushes the Block it's opened in.\n\n```\n[ this ] open echo\n\"STDOUT: [ this ]⏎ (instance of `[ this ]`)\"\n```"
    },
    "stack": {
      "name": "stack",
      "desc": "( -- S ): pushes the Stack it's opened in.\n\n```\nstack dup echo\n\"STDOUT: [ ⭮ ]⏎\"\n\n'foo' <<\nstack echo\n\"STDOUT: [ ⭮ 'foo' ]⏎\"\n```"
    },
    "ahead": {
      "name": "ahead",
      "desc": "( -- B ): leaves the block that will be executed after\n `this` finishes.\n\n```\n100 [ ahead 1 inject ] open + leaves: 101 \"(i.e. 100 1 +)\"\n```"
    },
    "resume": {
      "name": "resume",
      "desc": "( B -- ): closes blocks all the way up to, but not\n including, Block."
    },
    "dup": {
      "name": "dup",
      "desc": "( F -- F F ): duplicates the Form before cursor.\n\n```\n'hello' dup leaves: [ 'hello' 'hello' ]\n\n[ 1 2 | 3 ] $: block\nblock [ dup ] hydrate\nblock leaves: [ [ 1 2 2 | 3 ] ]\n```"
    },
    "drop": {
      "name": "drop",
      "desc": "( F -- ): drops the Form before cursor.\n\n```\n'hello' drop leaves: [ ]\n\n[ 1 2 | 3 ] $: block\nblock [ drop ] hydrate\nblock leaves: [ [ 1 | 3 ] ]\n```"
    },
    "swap": {
      "name": "swap",
      "desc": "( A B -- B A ): swaps two Forms before cursor.\n\n```\n1 2 swap leaves: [ 2 1 ]\n\n[ 1 2 | 3 ] $: block\nblock [ swap ] hydrate\nblock leaves: [ [ 2 1 | 3 ] ]\n```"
    },
    "hydrate": {
      "name": "hydrate",
      "desc": "( S F -- ): opens (evaluates) Form with Stack set as the\n active stack. If Form is not a block, it is added to\n Stack (equivalent to `<<`), If Form is a block, its\n instance is opened. To open a block without creating\n an instance of it (unsafe), use `hydrate!`."
    },
    "hydrate!": {
      "name": "hydrate!",
      "desc": "( S F -- ): opens (evaluates) Form with Stack set as the\n active stack. If Form is not a block, the behavior is\n the same as in `hydrate`. If Form is a block, performs\n unsafe hydration (hydrates without making an instance\n of the block). For a safer alternative, see `hydrate`.\n Use if you know what you're doing, or if you're ready\n to make an instance yourself.\n\nDetails: `hydrate!` is considered unsafe because hydration\nartifacts are exposed to the user and/or its blocks. The\ncontents of a block after hydration may differ from its\ncontents before unsafe hydration. Indeed, `hydrate!` is\nalmost as unsafe as pushing into `conts`; the only benefit\nit provides is that it is able to catch infinite/very\ndeep recursion."
    },
    "open": {
      "name": "open",
      "desc": "( F -- F' ): opens Form in the active stack. Equivalent\n to `stack F hydrate`.\n\n```\n100 open leaves: 100\n\n1 [ 2 + ] open leaves: 3\n```"
    },
    "there": {
      "name": "there",
      "desc": "( S B -- S ): opens Block with Stack set as the active\n stack. Leaves Stack. Ahead is transferred to block.\n\n```\n[ 1 2 ] [ + ] there leaves: [ [ 3 ] ]\n[ 1 2 ] [ ahead thruBlock open ] there + leaves: [ [ 3 ] ]\n```"
    },
    "do": {
      "name": "do",
      "desc": "( F -- ): opens Form with an empty stack activated, and\n disposed when Form has been evaluated.\n\n```\n[ 'Hi!' echo ] do\n\"STDOUT: Hi!⏎\"\n```"
    },
    "new": {
      "name": "new",
      "desc": "( B -- I ): leaves an Instance of a Block."
    },
    "shallowNew": {
      "name": "shallowNew",
      "desc": "( B -- Si ): leaves a Shallow instance of Block.\n\n`shallowNew` is different from `new` in that it does not force-\nreparent sub-blocks to the parent instance, and so on recursively --\nsometimes such behavior is not desired.\n\nThe difference is very subtle, and you mostly don't need to care.\nAs a word implementor you should, however, choose carefully between\n`new`, `shallowNew`, and `shallowCopy` (and perhaps `toTape` too).\nNovika is all about blocks, and there are different ways to copy,\ninstantiate, and work with them.\n\n```\n[ $: x [ x ] ] @: newBox\n\n1 newBox $: fooBox1\n2 newBox $: fooBox2\n3 newBox $: fooBox3\n\nfooBox1 open leaves: 1\nfooBox2 open leaves: 2\nfooBox3 open leaves: 3\n\n[ fooBox1 fooBox2 fooBox3 ] vals $: boxes\n\nboxes 0 fromLeft open leaves: 1\nboxes 1 fromLeft open leaves: 2\n\"... and so on, as you'd expect. However, let's try to instantiate boxes:\"\n\nboxes new $: boxesInstance\nboxesInstance 0 fromLeft open \"DIES: x is undefined\"\nboxesInstance 1 fromLeft open \"DIES: x is undefined\"\nboxesInstance 2 fromLeft open \"DIES: x is undefined\"\n\n\"Maybe defining 'x' on boxesInstance can shed some light?\"\nboxesInstance extend: [ 'Hello from boxesInstance' $: x ]\nboxesInstance 0 fromLeft open leaves: 'Hello from boxesInstance'\nboxesInstance 1 fromLeft open leaves: 'Hello from boxesInstance'\nboxesInstance 2 fromLeft open leaves: 'Hello from boxesInstance'\n\n\"You've witnessed the so-called *force-reparenting* done by 'new'.\n Let's try using 'shallowNew' for our boxesInstance.\"\n\nboxes shallowNew $: shallowBoxesInstance\nshallowBoxesInstance 0 fromLeft open leaves: 1\nshallowBoxesInstance 1 fromLeft open leaves: 2\nshallowBoxesInstance 2 fromLeft open leaves: 3\n\n\"Works as expected! Note that sub-blocks are exactly the same as\n those in the original 'boxes' block. However, 'shallowBoxesInstance'\n and 'boxes' are different blocks now:\"\n\n(shallowBoxesInstance 0 fromLeft) (boxes 0 fromLeft) same? leaves: true\n(shallowBoxesInstance 1 fromLeft) (boxes 1 fromLeft) same? leaves: true\n(shallowBoxesInstance 2 fromLeft) (boxes 2 fromLeft) same? leaves: true\n\nboxes shallowBoxesInstance same? leaves: false\n\n\"... and 'shallowBoxesInstance' does indeed have 'boxes' as its parent:\"\n\n(shallowBoxesInstance parent) boxes same? leaves: true\n```"
    },
    "sel": {
      "name": "sel",
      "desc": "( D A B -- A/B ): selects A (Determiner is truthy) or B\n (Determiner is falsey)"
    },
    "br": {
      "name": "br",
      "desc": "( D T F -- ? ): opens True/False forms depending on\n Determiner being true/false."
    },
    "<": {
      "name": "<",
      "desc": "( A B -- S ): leaves whether A is smaller than (less than) B."
    },
    "same?": {
      "name": "same?",
      "desc": "( F1 F2 -- true/false ): leaves whether two Forms are the\n same (by reference for block, by value for any other form).\n\n```\n1 2 same? leaves: false\n1 1 same? leaves: true\n\n'hello' 'hello world' same? leaves: false\n'hello' 'hello' same? leaves: true\n\n\"etc...\"\n\n[ 1 2 + ] $: b1\n[ 1 2 + ] $: b2\n\nb1 b2 same? leaves: false \"They're different blocks, content doesn't matter!\"\n\nb1 b1 same? leaves: true\nb2 b2 same? leaves: true\n```"
    },
    "=": {
      "name": "=",
      "desc": "( F1 F2 -- true/false ): leaves whether two Forms are equal by\n content (they may or may not be the same forms reference-wise,\n i.e., those for which `same?` would leave true).\n\n```\n1 2 = leaves: false\n1 1 = leaves: true\n\n'hello' 'hello world' = leaves: false\n'hello' 'hello' = leaves: true\n\n\"etc...\"\n\n[ 1 2 + ] $: b1\n[ 1 2 + ] $: b2\n\nb1 b2 = leaves: true \"They're equal by content!\"\n\nb1 b1 = leaves: true\nb2 b2 = leaves: true\n\n\"Supports self-reference:\"\n[ ] $: b3\nb3 b3 shove\nb3 b3 = leaves: true\n(b3 first) b3 = leaves: true\n\"etc...\"\n```"
    },
    "anyof?": {
      "name": "anyof?",
      "desc": "( F B -- true/false ): leaves whether any form in Block is\n equal (via `=`) to Form.\n\n```\n1 [ 1 2 3 ] anyof? leaves: true\n'hello' [ 'hello' 'world' 1 ] anyof? leaves: true\n'hello' [ 1 2 3 ] anyof? leaves: false\n```"
    },
    "occurrences": {
      "name": "occurrences",
      "desc": "( B/Q Pf/Pq -- Bi ): leaves Begin indices of all occurrences\n of Pattern form/Pattern quote in Block/Quote. Begin indices\n is an orphan with no entries.\n\nWorks in a similar way to `anyof?` in that it compares each\nelement of the Block/Quote with Pattern form/Pattern quote\nlike `=` (but not using `=`, at least in the quote case\nwhere KMP is used).\n\n```\n[ ] 123 occurrences leaves: [ [ ] ]\n\n[ 1 1 2 0 0 1 2 1 3 4 8 ] $: haystack\nhaystack 0 occurrences leaves: [ [ 3 4 ] ]\nhaystack 1 occurrences leaves: [ [ 0 1 5 7 ] ]\nhaystack 'foo' occurrences leaves: [ [ ] ]\n\n'' 'foobar' occurrences leaves: [ [ ] ]\n'foobar' '' occurrences leaves: [ [ ] ]\n\n'foobra' $: haystack\nhaystack 'o' occurrences leaves: [ [ 1 2 ] ]\nhaystack 'foo' occurrences leaves: [ [ 0 ] ]\nhaystack 'ra' occurrences leaves: [ [ 4 ] ]\n\n'GATCCATATG' $: haystack\nhaystack 'ATAAT' occurrences leaves: [ [ ] ]\nhaystack 'ATAT' occurrences leaves: [ [ 5 ] ]\n```"
    },
    "uppercase?": {
      "name": "uppercase?",
      "desc": "( Q -- true/false ): leaves whether Quote is all-uppercase.\n If Quote is empty, leaves false.\n\n```\n'' uppercase? leaves: false\n'A' uppercase? leaves: true\n'hello' uppercase? leaves: false\n'Hello' uppercase? leaves: false\n'HELLO' uppercase? leaves: true\n'HELLO WORLD' uppercase? leaves: false\n```"
    },
    "toUppercase": {
      "name": "toUppercase",
      "desc": "( Q -- Uq ): leaves all- Uppercase quote for Quote: converts\n lowercase character(s) in Quote to uppercase. If Quote is empty,\n leaves empty quote.\n\n```\n'' toUppercase leaves: ''\n'hello' toUppercase leaves: 'HELLO'\n'hello world' toUppercase? leaves: 'HELLO WORLD'\n```"
    },
    "block?": {
      "name": "block?",
      "desc": "( F -- true/false ): leaves whether Form is a block."
    },
    "asBlock": {
      "name": "asBlock",
      "desc": "( F -- B ): asserts that Form is a Block, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asBlock\n```\n\nEt cetera for all other forms, except:\n\n```\n[] asBlock leaves: [ [] \"(the same block)\" ]\n```"
    },
    "word?": {
      "name": "word?",
      "desc": "( F -- true/false ): leaves whether Form is a word form,\n or a block that implements '__word__'.\n\n```\n#foo word? leaves: true\n\n[ #foo $: __word__ this ] open word? leaves: true\n```"
    },
    "private?": {
      "name": "private?",
      "desc": "( W -- ): leaves whether Word is prefixed by one or more\n '_', meaning it is conventionally considered private.\n\n```\n#hello private? leaves: false\n#_hello private? leaves: true\n#_ private? leaves: false \"Beware!\"\n```"
    },
    "toWord": {
      "name": "toWord",
      "desc": "( F -- W ): converts Form into Word.\n  1. If Form is a word, behaves as noop\n  2. If Form is a quote, dies only if quote contains\n     Unicode whitespace characters or is itself empty.\n  3. If Form is a quoted word, peels off **all** quoting"
    },
    "asWord": {
      "name": "asWord",
      "desc": "( F -- W ): asserts that Form is a Word form, dies if\n it's not.\n\nFor example, the following expression dies:\n\n```\n100 asWord\n```\n\nEt cetera for all other forms, except:\n\n```\n#foo asWord leaves: [ foo ]\n```\n\n`__word__` hook can make a block usable in place of a word,\nprovided its definition leaves a word or a block which\nimplements '__word__':\n\n```\n[ $: x x $: __word__ this ] @: a\n#foo a asWord \"beware: leaves instance of a\"\n#boo a a asWord \"beware: leaves instance of a\"\n```"
    },
    "quotedWord?": {
      "name": "quotedWord?",
      "desc": "( F -- true/false ): leaves whether Form is a quoted word\n form, or a block that implements '__quotedWord__'.\n\n```\n##foo quotedWord? leaves: true\n[ ##foo $: __quotedWord__ this ] open quotedWord? leaves: true\n```"
    },
    "asQuotedWord": {
      "name": "asQuotedWord",
      "desc": "( F -- Qw ): asserts that Form is a Quoted word form,\n dies if it's not.\n\nFor example, the following expression dies:\n\n```\n100 asQuotedWord\n```\n\nEt cetera for all other forms, except:\n\n```\n##foo asQuotedWord leaves: #foo\n```\n\n`__quotedWord__` hook can make a block usable in place of\na quoted word, provided its definition leaves a quoted\nword or a block that implements `__quotedWord__`:\n\n```\n[ $: x x $: __quotedWord__ this ] @: a\n##foo a asQuotedWord \"beware: leaves instance of a\"\n##boo a a asQuotedWord \"beware: leaves instance of a\"\n```"
    },
    "decimal?": {
      "name": "decimal?",
      "desc": "( F -- true/false ): leaves whether Form is a decimal form,\n or a block that implements '__decimal__'.\n\n```\n123 decimal? leaves: true\n[ 123 $: __decimal__ this ] open decimal? leaves: true\n```"
    },
    "toQuotedWord": {
      "name": "toQuotedWord",
      "desc": "( Qw/W -- #Qw/#W ): adds a layer of \"quoting\" to Quoted\n word or Word.\n\n```\n\"Note that in quoted word literals (here on the left hand\n side) one layer of quoting is 'eaten off' by the parser!\"\n\n#foo toQuotedWord leaves: #foo\n##foo toQuotedWord leaves: ##foo\n```"
    },
    "asDecimal": {
      "name": "asDecimal",
      "desc": "( F -- D ): asserts that Form is a Decimal form, dies if\n it's not.\n\nFor example, the following expression dies:\n\n```\n'foo' asDecimal\n```\n\nEt cetera for all other forms, except:\n\n```\n100 asDecimal leaves: 100\n```\n\n`__decimal__` hook can make a block usable in place of a\ndecimal, provided its definition leaves a decimal or a\nblock that implements `__decimal__`:\n\n```\n[ $: x x $: __decimal__ this ] @: a\n100 a asDecimal \"beware: leaves an instance of a\"\n200 a a asDecimal \"beware: leaves an instance of a\"\n```"
    },
    "quote?": {
      "name": "quote?",
      "desc": "( F -- true/false ): leaves whether Form is a quote form,\n or a block that implements '__quote__'.\n\n```\n'foo' quote? leaves: true\n[ 'foo' $: __quote__ this ] open quote? leaves: true\n```"
    },
    "asQuote": {
      "name": "asQuote",
      "desc": "( F -- Q ): asserts that Form is a Quote form, dies if\n it's not.\n\nFor example, the following expression dies:\n\n```\n100 asQuote\n```\n\nEt cetera for all other forms, except:\n\n```\n'foo' asQuote leaves: 'foo'\n```\n\n`__quote__` hook can make a block usable in place of a\nquote, provided its definition leaves a quote or a block\nthat implements `__quote__`:\n\n```\n[ $: x x $: __quote__ this ] @: a\n'foo' a asQuote \"beware: leaves instance of a\"\n'boo' a a asQuote \"beware: leaves instance of a\"\n```"
    },
    "boolean?": {
      "name": "boolean?",
      "desc": "( F -- true/false ): leaves whether Form is a boolean form,\n or a block that implements '__boolean__'.\n\n```\ntrue boolean? leaves: true\n[ true $: __boolean__ this ] open boolean? leaves: true\n```"
    },
    "asBoolean": {
      "name": "asBoolean",
      "desc": "( F -- B ): asserts that Form is a Boolean form, dies if\n it's not.\n\nFor example, the following expression dies:\n\n```\n100 asBoolean\n```\n\nEt cetera for all other forms, except:\n\n```\ntrue asBoolean leaves: true\nfalse asBoolean leaves: false\n```\n\n`__boolean__` hook can make a block usable in place of a\nboolean, provided its definition leaves a boolean or a\nblock that implements `__boolean__`:\n\n```\n[ $: x x $: __boolean__ this ] @: a\ntrue a asBoolean \"beware: leaves an instance of a\"\ntrue a a asBoolean \"beware: leaves an instance of a\"\n```"
    },
    "builtin?": {
      "name": "builtin?",
      "desc": "( F -- true/false ): leaves whether Form is a builtin form."
    },
    "asBuiltin": {
      "name": "asBuiltin",
      "desc": "( F -- B ): asserts Form is a Builtin, dies if it's not.\n\nFor example, the following expression dies:\n\n```\n'foo' asBuiltin\n```\n\nEt cetera for all other forms, except:\n\n```\n#+ here asBuiltin toQuote leaves: '[ native code ]'\n```"
    },
    "color?": {
      "name": "color?",
      "desc": "( F -- true/false ): leaves whether Form is a color form,\n or a block that implements '__color__'.\n\n```\n0 0 0 rgb color? leaves: true\n[ 0 0 0 rgb $: __color__ this ] open color? leaves: true\n```"
    },
    "asColor": {
      "name": "asColor",
      "desc": "( F -- C ): asserts that Form is a Color form, dies if\n it's not.\n\nFor example, the following expression dies:\n\n```\n100 asColor\n```\n\nEt cetera for all other forms, except:\n\n```\n0 0 0 rgb asColor toQuote leaves: 'rgb(0, 0, 0)'\n```\n\n`__color__` hook can make a block usable in place of a\ncolor, provided its definition leaves a color or a block\nthat implements `__color__`:\n\n```\n[ $: x x $: __color__ this ] @: a\n0 0 0 rgb a asColor \"beware: leaves an instance of a\"\n0 0 0 rgb a a asColor \"beware: leaves an instance of a\"\n```"
    },
    "byteslice?": {
      "name": "byteslice?",
      "desc": "( F -- true/false ): leaves whether Form is a byteslice\n form, or a block that implements '__byteslice__'.\n\n```\n'hello world' toByteslice byteslice? leaves: true\n[ [ 'Hi!' toByteslice ] $: __byteslice__ this ] open byteslice? leaves: true\n```"
    },
    "asByteslice": {
      "name": "asByteslice",
      "desc": "( F -- B ): asserts that Form is a Byteslice form, dies if\n it's not.\n\nFor example, the following expression dies:\n\n```\n100 asByteslice\n```\n\nEt cetera for all other forms, except:\n\n```\n'hello world' toByteslice asByteslice leaves: '[byteslice, consists of 11 mutable byte(s)]'\n```\n\n`__byteslice__` hook can make a block usable in place of\na byteslice, provided its definition leaves a byteslice\nor a block that implements `__byteslice__`:\n\n```\n[ $: x x $: __byteslice__ this ] @: a\n'foo' toByteslice a asByteslice \"beware: leaves an instance of a\"\n'foo' toByteslice a a asByteslice \"beware: leaves an instance of a\"\n```"
    },
    "pushes": {
      "name": "pushes",
      "desc": "( B N F -- ): creates a definition for Name in Block that\n pushes Form when resolved there."
    },
    "opens": {
      "name": "opens",
      "desc": "( B N F -- ): creates a definition for Name in Block that\n opens Form when resolved there."
    },
    "entry:submit": {
      "name": "entry:submit",
      "desc": "( Ss N F -- ): replaces the value form of an existing\n definition for Name in Submittable store (usually a block)\n to Form. Does not change whether the definition opens\n or pushes."
    },
    "entry:exists?": {
      "name": "entry:exists?",
      "desc": "( Rs N -- true/false ): leaves whether Readable store\n (usually a block) can fetch value for Name."
    },
    "entry:fetch": {
      "name": "entry:fetch",
      "desc": "( Rs N -- F ): leaves the value Form with the given Name\n in Readable store (usually a block). Does not open the\n value form. Dies if Store does not contain an entry\n for Name."
    },
    "entry:fetch?": {
      "name": "entry:fetch?",
      "desc": "( Rs N -- F true / false ): leaves the value Form with the\n given Name in Readable store (usually a block) if an entry\n for Name exists there, and/or a boolean indicating the\n latter: `true` (exists), or `false` (does not exist).\n\n```\n[ ] $: a\na #x 100 pushes\n\na #x entry:fetch? leaves: [ 100 true ]\na #y entry:fetch? leaves: [ false ]\n```"
    },
    "entry:open": {
      "name": "entry:open",
      "desc": "( Rs C N -- ... ): resolves Name in Readable store and *opens*\n it if it is an opener, assuming Caller to be the opener block."
    },
    "entry:flatFetch?": {
      "name": "entry:flatFetch?",
      "desc": "( B N -- F true / false ): leaves the value Form under\n Name in Block's dictionary followed by `true`, or `false`\n if no such entry is in Block. Block hierarchy is not\n traversed (only the Block's own dictionary is looked at)."
    },
    "entry:opener?": {
      "name": "entry:opener?",
      "desc": "( Rs N -- true/false ): leaves whether an entry with the\n given Name in Readable store (usually a block) is an\n opener entry. Dies if Readable store has no entry with\n the given Name."
    },
    "entry:delete": {
      "name": "entry:delete",
      "desc": "( B N -- ): removes the entry corresponding to Name form\n from the dictionary of Block if it exists there. Otherwise,\n does nothing.\n\n```\n100 $: x\n\n[ 200 $: x ] obj $: foo\n\n\"'x' of foo shadows 'x' of toplevel block\"\nfoo.x leaves: 200\n\n\"Let's try to remove it so it doesn't:\"\nfoo #x entry:delete\nfoo.x leaves: 100\n```"
    },
    "entry:wipeout": {
      "name": "entry:wipeout",
      "desc": "( B -- ): removes all *owned* dictionary entries in Block.\n\n```\n[ 100 $: x\n  200 $: y\n] obj $: numbers\n\nnumbers entry:names leaves: [ [x y] ]\n\nnumbers entry:wipeout\nnumbers entry:names leaves: [ [] ]\n```"
    },
    "entry:pathTo?": {
      "name": "entry:pathTo?",
      "desc": "( B N -- P F true / false ): leaves Path, a block describing the\n path to Form (including Block itself) under the corresponding\n Name (like `entry:fetch?`). Follows Path and Form with `true`\n indicating success, otherwise *only* `false` indicating that\n there is no Form corresponding to Name in Block or any of the\n blocks reachable from Block.\n\nThis word exists mainly for testing word lookup sanity. Feel free\nto use it if you find any reason to!\n\n```\n[ 100 $: x  'a' $: __quote__ ] obj $: a\n[ 200 $: y  'b' $: __quote__ ] obj $: b\n[ 300 $: z  'c' $: __quote__ ] obj $: c\n\na -- b -- c drop\n\n[ a #x entry:pathTo? ] vals sepBy: ' ' leaves: '[ a ] 100 true'\n[ b #x entry:pathTo? ] vals sepBy: ' ' leaves: '[ b a ] 100 true'\n[ c #x entry:pathTo? ] vals sepBy: ' ' leaves: '[ c b a ] 100 true'\n\n[ b #y entry:pathTo? ] vals sepBy: ' ' leaves: '[ b ] 200 true'\n[ c #y entry:pathTo? ] vals sepBy: ' ' leaves: '[ c b ] 200 true'\n\n[ c #z entry:pathTo? ] vals sepBy: ' ' leaves: '[ c ] 300 true'\n\n[ c #foo entry:pathTo? ] vals sepBy: ' ' leaves: 'false'\n```"
    },
    "entry:names": {
      "name": "entry:names",
      "desc": "( B -- Nb ): gathers all *owned* dictionary entry names of Block\n into Name block.\n\n```\n[ 100 200 ${ x y } ] obj $: myParent\n[ 300 $: z ] obj $: myChild\n[ 'Hello World' $: greeting ] obj $: myFriend\n\nmyParent -- myChild drop\nmyParent ·> myFriend drop\nmyChild ·> myFriend drop \"for good measure :)\"\n\nmyParent entry:names leaves: [ [y x] ]\nmyChild entry:names leaves: [ [z] ]\nmyFriend entry:names leaves: [ [greeting] ]\n```"
    },
    "entry:names*": {
      "name": "entry:names*",
      "desc": "( B -- Nb ): gathers all dictionary entry names *reachable* from\n Block to Name block. That is, gathers all entry names in Block,\n Block's parents, Block's friends, and so on. Explores the entire\n relative graph of Block.\n\nOrder is not guaranteed, and mainly depends on the appearance of\nBlock's relative graph.\n\n```\n[ 100 200 ${ x y } ] obj toOrphan $: myParent\n[ 300 $: z ] obj toOrphan $: myChild\n[ 'Hello World' $: greeting ] obj toOrphan $: myFriend\n\nmyParent -- myChild drop\nmyParent ·> myFriend drop\nmyChild ·> myFriend drop\n\nmyParent entry:names* leaves: [ [y x greeting] ]\nmyChild entry:names* leaves: [ [z y x greeting] ]\nmyFriend entry:names* leaves: [ [greeting] ]\n```"
    },
    "entry:values": {
      "name": "entry:values",
      "desc": "( B -- Vb ): gathers all *owned* dictionary entry value forms of\n Block into Value block.\n\n```\n[ 100 200 ${ x y } ] obj $: myParent\n[ 300 $: z ] obj $: myChild\n[ 'Hello World' $: greeting ] obj $: myFriend\n\nmyParent -- myChild drop\nmyParent ·> myFriend drop\nmyChild ·> myFriend drop\n\nmyParent entry:values leaves: [ [200 100] ]\nmyChild entry:values leaves: [ [300] ]\nmyFriend entry:values leaves: [ ['Hello World'] ]\n```"
    },
    "entry:values*": {
      "name": "entry:values*",
      "desc": "( B -- Nb ): gathers all dictionary entry values *reachable* from\n Block to Name block. That is, gathers all entry values in Block,\n Block's parents, Block's friends, and so on. Explores the entire\n relative graph of Block.\n\nOrder is not guaranteed, and mainly depends on the appearance\nof Block's relative graph. Values may repeat if some blocks\nin this graph define entries with the same name.\n\n```\n[ 100 200 ${ x y } ] obj toOrphan $: myParent\n[ 300 $: z ] obj toOrphan $: myChild\n[ 'Hello World' $: greeting ] obj toOrphan $: myFriend\n\nmyParent -- myChild drop\nmyParent ·> myFriend drop\nmyChild ·> myFriend drop\n\nmyParent entry:values* leaves: [ [200 100 'Hello World'] ]\nmyChild entry:values* leaves: [ [300 200 100 'Hello World'] ]\nmyFriend entry:values* leaves: [ ['Hello World'] ]\n```"
    },
    "entry:count": {
      "name": "entry:count",
      "desc": "( B -- Ec ): leaves Entry count, that is, the amount of entries\n owned by (defined in) Block.\n\n```\n[ 100 200 ${ x y } ] obj $: myBlock\n\nmyBlock entry:count leaves: 2 \"'x' and 'y'\"\n```"
    },
    "shallowCopy": {
      "name": "shallowCopy",
      "desc": "( B -- C ): makes a shallow copy (sub-blocks are not copied)\n of Block's tape and dictionary, and leaves a Copy block with\n the tape copy, dictionary copy set as its tape, dictionary.\n\n```\n[ 1 2 3 ] $: a\na shallowCopy $: b\na #x 0 pushes\nb #y 1 pushes\nb 1 shove\na b 2echo\n\"STDOUT: [ 1 2 3 · ${x :: 0} ]⏎\"\n\"STDOUT: [ 1 2 3 1 · ${y :: 1} ]⏎\"\n```"
    },
    "resub": {
      "name": "resub",
      "desc": "( O B -- ): replaces the substrate of Block with Other's\n substrate. This is useful if you want to swap Block's\n contents with Other's without changing Block's identity:\n\n```\n[ 1 2 3 ] $: a\n[ 'a' 'b' 'c' ] $: b\nb #x 0 pushes\nb echo\n\"STDOUT: [ 'a' 'b' 'c' · ${x :: 0} ]⏎\"\n\na b resub\nb echo\n\"STDOUT: [ 1 2 3 · ${x :: 0} ]⏎\"\n```\n\nNote that since *substrate* is replaced, not *tape*, the\ncursor position is saved:\n\n```\na b 2echo\n\"STDOUT: [ 1 2 3 ]⏎\"\n\"STDOUT: [ 'a' 'b' 'c' · ${x :: 0} ]⏎\"\n\nb 2 |-\na b 2echo\n\"STDOUT: [ 1 2 3 ]⏎\"\n\"STDOUT: [ 'a' | 'b' 'c' · ${x :: 0} ]⏎\"\n\na b resub\nb echo\n\"STDOUT: [ 1 | 2 3 · ${x :: 0} ]⏎\"\n```"
    },
    "fromLeft": {
      "name": "fromLeft",
      "desc": "( B/Q/Bf I -- E ): leaves Index-th Element from the left\n in Block, Quote, or Byteslice form.\n\n```\n[ 1 2 3 ] 0 fromLeft leaves: 1\n```"
    },
    "fromRight": {
      "name": "fromRight",
      "desc": "( B/Q/Bf I -- E ): leaves Index-th Element from the right\n in Block, Quote, or Byteslice form.\n\n```\n[ 1 2 3 ] 0 fromRight leaves: 3\n[ 1 2 3 ] 1 fromRight leaves: 2\n[ 1 2 3 ] 2 fromRight leaves: 1\n```"
    },
    "fromLeft*": {
      "name": "fromLeft*",
      "desc": "( B/Q/Bf N -- Eb/Rq/Rbf ): leaves Elements block (if given\n a Block), Result quote (if given a Quote), or Result\n byteslice form (if given a Byteslice form) with N forms/\n chars/bytes from left in Block/Quote/Byteslice form.\n If N is larger than Block/Quote/Byteslice form count,\n it is made equal to Block/Quote/Byteslice form count.\n Dies if N is negative.\n\n```\n[ 1 2 3 ] 1 fromLeft* leaves: [ [ 1 ] ]\n[ 1 2 3 ] 2 fromLeft* leaves: [ [ 1 2 ] ]\n[ 1 2 3 ] 3 fromLeft* leaves: [ [ 1 2 3 ] ]\n[ 1 2 3 ] 100 fromLeft* leaves: [ [ 1 2 3 ] ]\n'hello' 3 fromLeft* leaves: 'hel'\n```"
    },
    "fromRight*": {
      "name": "fromRight*",
      "desc": "( B/Q/Bf N -- Fb/Rq/Rbf ): leaves Elements block (if given\n a Block), Result quote (if given a Quote), or Result\n byteslice form (if given a Byteslice form) with N forms/\n chars/bytes from right in Block/Quote/Byteslice form.\n If N is larger than Block/Quote/Byteslice form count,\n it is made equal to Block/Quote/Byteslice form count.\n Dies if N is negative.\n\n```\n[ 1 2 3 ] 1 fromRight* leaves: [ [ 3 ] ]\n[ 1 2 3 ] 2 fromRight* leaves: [ [ 2 3 ] ]\n[ 1 2 3 ] 3 fromRight* leaves: [ [ 1 2 3 ] ]\n[ 1 2 3 ] 100 fromRight* leaves: [ [ 1 2 3 ] ]\n```"
    },
    "+": {
      "name": "+",
      "desc": "( A B -- S ): leaves the Sum of two decimals."
    },
    "-": {
      "name": "-",
      "desc": "( A B -- D ): leaves the Difference of two decimals."
    },
    "*": {
      "name": "*",
      "desc": "( A B -- P ): leaves the Product of two decimals."
    },
    "/": {
      "name": "/",
      "desc": "( A B -- Q ): leaves the Quotient of two decimals."
    },
    "mod": {
      "name": "mod",
      "desc": "( A B -- M ): leaves the Modulo of two decimals."
    },
    "**": {
      "name": "**",
      "desc": "( A B -- R ): raises A to the power B, leaves Result."
    },
    "round": {
      "name": "round",
      "desc": "( D -- Rd ): rounds Decimal towards the nearest integer,\n leaves the corresoinding Rounded decimal. If both neighboring\n integers are equidistant, rounds towards the even neighbor\n (Banker's rounding).\n\n```\n1 round leaves: 1\n1.23 round leaves: 1\n\n1.5 round leaves: 2\n1.67 round leaves: 2\n\n2.5 round leaves: 2 \"rounds towards the even neighbor\"\n```"
    },
    "floor": {
      "name": "floor",
      "desc": "( D -- Rd ): rounds Decimal *down* towards the nearest integer,\n leaves the corresoinding Rounded decimal.\n\n```\n1 floor leaves: 1\n1.23 floor leaves: 1\n\n1.5 floor leaves: 1\n1.67 floor leaves: 1\n\n2.5 floor leaves: 2\n\n-2.5 floor leaves: -3 \"rounds down!\"\n```"
    },
    "ceil": {
      "name": "ceil",
      "desc": "( D -- Rd ): rounds Decimal *up* towards the nearest integer,\n leaves the corresoinding Rounded decimal.\n\n```\n1 ceil leaves: 1\n1.23 ceil leaves: 2\n\n1.5 ceil leaves: 2\n1.67 ceil leaves: 2\n\n2.5 ceil leaves: 3\n\n-2.5 ceil leaves: -2 \"rounds up!\"\n```"
    },
    "trunc": {
      "name": "trunc",
      "desc": "( D -- Rd ): rounds Decimal towards zero, leaves the resulting\n Rounded decimal.\n\n```\n1 trunc leaves: 1\n1.23 trunc leaves: 1\n1.5 trunc leaves: 1\n1.67 trunc leaves: 1\n2.5 trunc leaves: 2\n\n-2.3 trunc leaves:  -2\n```"
    },
    "sqrt": {
      "name": "sqrt",
      "desc": "( D -- R ): leaves the square Root of Decimal."
    },
    "cos": {
      "name": "cos",
      "desc": "( Air -- Dc ): leaves Decimal cosine of Angle in radians."
    },
    "sin": {
      "name": "sin",
      "desc": "( Air -- Ds ): leaves Decimal sine of Angle in radians."
    },
    "rand": {
      "name": "rand",
      "desc": "( -- Rd ): leaves a Random decimal between 0 and 1."
    },
    "sliceQuoteAt": {
      "name": "sliceQuoteAt",
      "desc": "( Q Sp -- Pb Pa ): for the given Quote, leaves the Part\n before and Part after Slice point.\n\n```\n'hello world' 2 sliceQuoteAt leaves: [ 'he' 'llo world' ]\n```"
    },
    "count": {
      "name": "count",
      "desc": "( B/Q/Bf -- N ): leaves N, the amount of elements/graphemes/\n bytes in Block/Quote/Byteslice form."
    },
    "chr": {
      "name": "chr",
      "desc": "( Uc -- Q ): leaves a quote that consists of a single\n character with the given Unicode codepoint."
    },
    "ord": {
      "name": "ord",
      "desc": "( Q -- Uc ): leaves the Unicode codepoint for the first\n character in Quote. Dies if Quote is empty."
    },
    "lpad": {
      "name": "lpad",
      "desc": "( Q Tl Pq -- Jq ): appends consecutive characters from Padding quote\n (the last one is repeated if no more follow) to the left of Quote,\n until Quote count becomes equal to Total length. Leaves the resulting\n Justified quote.\n\n```\n'hello' 10 '-' lpad leaves: '-----hello'\n'hello' 10 ':-' lpad leaves: ':----hello'\n'hello' 7 'XYZABC' lpad leaves: 'XYhello'\n'hello' 9 'XYZABC' lpad leaves: 'XYZAhello'\n```"
    },
    "rpad": {
      "name": "rpad",
      "desc": "( Q Tl Pq -- Jq ): appends consecutive characters from Padding quote\n (the last one is repeated if no more follow) to the right of Quote,\n until Quote count becomes equal to Total length. Leaves the resulting\n Justified quote.\n\n```\n'hello' 10 '-' rpad leaves: 'hello-----'\n'hello' 10 ' -' rpad leaves: 'hello ----'\n'hello' 7 'foobar' rpad leaves: 'hellofo'\n```"
    },
    "fit": {
      "name": "fit",
      "desc": "( Q Tl Eq -- Fq ): if Quote is longer than Total length, truncates\n it so that it can fit Ellipsis quote, and stitches the truncated\n Quote with the Ellipsis quote, forming Fit quote which is then\n left on the stack.\n\nEssentially, Fit quote is guaranteed to be of Total length\ncharacters **or less!**.\n\n```\n'hello' 10 '…' fit leaves: 'hello'\n'hello world' 10 '…' fit leaves: 'hello wor…'\n'hello world' 8 '' fit leaves: 'hello wo'\n'Lorem ipsum dolor sit amet' 10 '-' fit leaves: 'Lorem ipsu-'\n'Lorem ipsum dolor sit amet' 24 '… (hidden)' fit leaves: 'Lorem ipsum do… (hidden)'\n```"
    },
    "|at": {
      "name": "|at",
      "desc": "( B -- N ): leaves N, the position of the cursor in Block."
    },
    "|to": {
      "name": "|to",
      "desc": "( B N -- ): moves the cursor in Block to N."
    },
    "<|": {
      "name": "<|",
      "desc": "( -- ): moves stack cursor once to the left."
    },
    "|>": {
      "name": "|>",
      "desc": "( -- ): moves stack cursor once to the left."
    },
    "|slice": {
      "name": "|slice",
      "desc": "( B -- Lh Rh ): slices Block at cursor. Leaves Left half\n and Right half."
    },
    "cherry": {
      "name": "cherry",
      "desc": "( [ ... E | ... ]B ~> [ ... | ... ]B -- E ): drops Block\n and Element before cursor in Block (and moves cursor back\n once), leaves Element."
    },
    "shove": {
      "name": "shove",
      "desc": "( [ ... | ... ]B E ~> [ ... E | ... ]B -- ): adds Element\n before cursor in Block (and moves cursor forward once),\n drops both."
    },
    "shove*": {
      "name": "shove*",
      "desc": "( [ ...bl | ...br ]B [ ...el | ...er ]Eb ~> [ ...bl ...el | ...br ]B -- ): adds\n elements before cursor in Element block after the cursor in Block.\n\n```\n[ 1 2 3 ] $: xs\nxs [ 4 5 6 ] shove*\nxs leaves: [ [ 1 2 3 4 5 6 \"|\" ] ]\n\n[ 1 | 2 3 ] $: ys\nys [ 100 200 300 ] shove*\nys leaves: [ 1 100 200 300 | 2 3 ]\n```"
    },
    "eject": {
      "name": "eject",
      "desc": "( [ ... | F ... ]B ~> [ ... | ... ]B -- F ): drops and\n leaves the Form after cursor in Block."
    },
    "inject": {
      "name": "inject",
      "desc": "( B F -- ): inserts Form to Block: adds Form to Block,\n and moves cursor back again."
    },
    "thru": {
      "name": "thru",
      "desc": "( [ ... | F ... ] -> [ ... F | ... ] -- F ): moves cursor\n after Form, and leaves Form. Dies if cursor is at the end.\n\nNote: prefer `thru` to `eject` because `eject` modifies\nthe block, and that may cause a tape copy which uses up\na bit of memory and resources. The difference would matter\nonly in high load scenarios, though.\n\nNote: anything that *does not* `ahead inject` will be OK\nwith `ahead thru`. And even if it does `ahead inject`,\nstill, there are ways to overcome the problems from not\n`ahead eject`ing."
    },
    "thruBlock": {
      "name": "thruBlock",
      "desc": "( B -- Bf / [ Vf ] ): similar to `thru` for Block. If\n form after cursor is a Block form, it is left. If it is\n a Value form, then it is enclosed in a new block whose\n parent is Block."
    },
    "top": {
      "name": "top",
      "desc": "( [ ... F | ... ]B -- F ): leaves the top Form in Block."
    },
    "mergeDicts": {
      "name": "mergeDicts",
      "desc": "( Rb Db -- ): copies entries from Donor block's dictionary\n to Recipient block's dictionary. Donor entries override\n same-named entries in Recipient. Donor entries starting\n with one or more underscores are not imported.\n\n```\n[ ] $: a\na #x 100 pushes\na #_private 'Fool!' pushes\n[ ] $: b\nb #y 200 pushes\n\na b 2echo\n\"STDOUT: [ · ${x :: 100} ${_private :: 'Fool!'} ]⏎\"\n\"STDOUT: [ · ${y :: 200} ]⏎\"\n\nb a mergeDicts\nb echo\n\"STDOUT: [ · ${y :: 200} ${x :: 100} ]⏎\"\n```"
    },
    "sortUsing!": {
      "name": "sortUsing!",
      "desc": "( B Cb -- B ): leaves Block sorted inplace. Forms in Block\n are compared using Comparator block.\n\nComparator block is opened with two forms on the stack; let's\ncall them A and B. If Comparator block leaves a negative decimal\n(conventionally `-1`), then `A < B`. If Comparator block leaves\n`0`, then `A = B`. If Comparator block leaves a positive decimal\n(conventionally `1`), then `A > B`.\n\nDies if Comparator block leaves any other (kind of) form.\n\nIgnores all forms but the topmost for Comparator block.\n\n\n```\n[ 3 2 1 ] [ - ] sortUsing! leaves: [ 1 2 3 ]\n```"
    },
    "getErrorDetails": {
      "name": "getErrorDetails",
      "desc": "( Eo -- Dq ): leaves Details quote containing error details\n of an Error object."
    },
    "toQuote": {
      "name": "toQuote",
      "desc": "( F -- Qr ): leaves Quote representation of Form."
    },
    "toByteslice": {
      "name": "toByteslice",
      "desc": "( Q -- B ): leaves immutable Byteslice for Quote."
    },
    "replaceAll": {
      "name": "replaceAll",
      "desc": "( Sq Pq Q -- Rq ): replaces all instances of Pattern quote\n in Source quote with Quote. Leaves the Resulting quote.\n\n```\n'hello' 'l' 'y' replaceAll leaves: 'heyyo'\n```"
    },
    "effect": {
      "name": "effect",
      "desc": "( F -- Eq ): leaves Effect quote for Form.\n\nIf Form is not a block nor a builtin, it is simply converted\nto quote in the same way as `toQuote`.\n\nIf Form is a block or a builtin, an attempt is made at\nextracting a stack effect expression from its comment.\nIf the attempt fails, Form's description is left. If the\nattempt was successful, the extracted stack effect quote\nis added onto the stack as Effect quote.\n\n```\n100 effect leaves: '100'\ntrue effect leaves: 'true'\n\n[] effect leaves: 'a block'\n[ \"Hello World\" ] effect leaves: 'a block'\n[ \"( -- ) \"] effect leaves: '( -- )'\n\n#+ here effect leaves: '( A B -- S )' \"(yours may differ)\"\n#map: here effect leaves: '( Lb B -- MLb )'\n```"
    },
    "die": {
      "name": "die",
      "desc": "( D/Eo -- ): dies with Details quote/Error object."
    },
    "stitch": {
      "name": "stitch",
      "desc": "( Q1 Q2 -- Q3 ): quote concatenation."
    },
    "reparent": {
      "name": "reparent",
      "desc": "( C P -- C ): changes the parent of Child to Parent. Lookup\n cycles are allowed and handled gracefully."
    },
    "befriend": {
      "name": "befriend",
      "desc": "( B F -- ): adds Friend to Block's friend list.\n\nFriends are asked for word entries after parents, grandparents\netc. have failed to retrieve them. This recurses, e.g. friends\nask their own friends and so on, until the entry is found. Lookup\ncycles are allowed and handled gracefully.\n\n```\n[ 100 $: x this ] open $: a\n[ 200 $: y this ] open $: b\na b befriend\nb a befriend\na.x echo\n\"STDOUT: 100⏎\"\n\na.y echo\n\"STDOUT: 200⏎\"\n\nb.x echo\n\"STDOUT: 100⏎\"\n\nb.y echo\n\"STDOUT: 200⏎\"\n\na #x [ 'I've changed!' echo ] opens\n\na.x\n\"STDOUT: I've changed!⏎\"\nb.x\n\"STDOUT: I've changed!⏎\"\n```"
    },
    "unfriend": {
      "name": "unfriend",
      "desc": "( B F -- ): removes Friend from Block's friend list. Does\n nothing if Friend is not in the friend list. See `befriend`.\n\n```\n[ 100 $: x this ] open $: a\n[ 200 $: y this ] open $: b\na b befriend\na.x echo\n\"STDOUT: 100⏎\"\na.y echo\n\"STDOUT: 200⏎\"\na b unfriend\na.x echo\n\"STDOUT: 100⏎\"\na.y echo\n\"Sorry: no value form found for 'y'.\"\n```"
    },
    "friends": {
      "name": "friends",
      "desc": "( B -- Fl ): leaves Friend list of Block. See `befriend`.\n\n```\n[ 100 $: x this ] open $: a\n[ 200 $: y this ] open $: b\na b befriend\na friends count echo\n\"STDOUT: 1⏎\"\na friends first b same? echo\n\"STDOUT: true⏎\"\na.y echo\n\"STDOUT: 200⏎\"\na friends [ drop ] hydrate\na friends count echo\n\"STDOUT: 0⏎\"\na.y echo\n\"Sorry: no value form found for 'y'.\"\n```"
    },
    "slurp": {
      "name": "slurp",
      "desc": "( B Q -- B ): parses Quote and adds all forms from Quote\n to Block."
    },
    "orphan": {
      "name": "orphan",
      "desc": "( -- O ): Leaves an Orphan (a parent-less block)."
    },
    "orphan?": {
      "name": "orphan?",
      "desc": "( B -- true/false ): leaves whether Block is an orphan"
    },
    "toOrphan": {
      "name": "toOrphan",
      "desc": "( B -- B ): makes Block an orphan (destroys the link with\n its parent).\n\n```\n0 $: x\n[ ] $: b\nb . x echo\n\"STDOUT: 0⏎\"\n\nb toOrphan leaves: [ [ ] ]\n. x\n\"Sorry: no value form found for 'x'\"\"\n```"
    },
    "toTape": {
      "name": "toTape",
      "desc": "( B -- Tb ): leaves Tape block for Block. Useful for e.g.\n comparing two blocks only for tape contents, when Block may\n have dictionary entries.\n\nLookup hierarchy is destroyed: Tape block is an orphan.\n\n```\n[ 1 2 3 ] $: a\na #x 0 pushes\na a toTape 2echo\n\"STDOUT: [ 1 2 3 · ${x :: 0} ]⏎\"\n\"STDOUT: [ 1 2 3 ]⏎\"\n```"
    },
    "desc": {
      "name": "desc",
      "desc": "( F -- Dq ): leaves the Description quote of the given Form.\n\n```\n100 desc leaves: 'decimal number 100'\n'foobar' desc leaves: 'quote 'foobar''\n[ 1 2 3 ] desc leaves: 'a block'\n[ \"I am a block\" 1 2 3 ] desc leaves: 'I am a block'\ntrue desc leaves: 'boolean true'\n```"
    },
    "typedesc": {
      "name": "typedesc",
      "desc": "( F -- Dq ): leaves the type Description quote of the\n given Form.\n\n```\n100 typedesc leaves: 'decimal'\n'foobar' typedesc leaves: 'quote'\n[ 1 2 3 ] typedesc leaves: 'block'\n[ \"I am a block\" 1 2 3 ] typedesc leaves: 'block'\ntrue typedesc leaves: 'boolean'\n```"
    },
    "nki:toBlock": {
      "name": "nki:toBlock",
      "desc": "( Bf -- B ): leaves Block for the given Byteslice form,\n assumed to contain a well-formed Novika image created\n with `nki:captureAll`, `nki:captureNeighborhood`, or\n otherwise. Dies if Byteslice form is an invalid Novika\n image, or isn't a Novika image.\n\nFor code example, see `nki:captureNeighborhood`."
    },
    "nki:captureAll": {
      "name": "nki:captureAll",
      "desc": "( B -- Bf ): thoroughly, recursively captures entire\n hierarchy of Block (its parents, prototype, friends,\n tape, and dictionary), and leaves the resulting Novika\n image as a Byteslice form.\n\nArchives image payload using Gzip, fast.\n\nIf you're a visual type of person, imagine this word and\nall related facilities as a kind of \"mold\", which carefully,\nin an ordered fashion \"fills up\" a maze, until all paths\nwere explored and all exits found.\n\nFor code example, see `nki:captureNeighborhood`."
    },
    "nki:captureNeighborhood": {
      "name": "nki:captureNeighborhood",
      "desc": "( B -- Bf ): like `nki:captureAll`, but rather than\n capturing all reachable blocks, captures only Block's\n neighborhood. Leaves the resulting Byteslice form.\n\nArchives image payload using Gzip, fast.\n\nWe store each block in Block's tape and dictionary in\na list, then ask that block to do the same. When recursion\nfinishes, the resulting list is called *block neighborhood*.\n\nParent, friends, and prototype of the given block are\nreconstructed *if and only if they are in the block\nneighborhood*.\n\n```\n[ 1 2 3 ] nki:captureNeighborhood $: imgN\n\nimgN toQuote leaves: '[byteslice, consists of 111 byte(s)]' \"yours may differ!\"\nimgN nki:toBlock leaves: [ [ 1 2 3 ] ]\n\n\"As opposed to nki:captureAll, which will capture EVERYTHING\n it can reach:\"\n[ 1 2 3 ] nki:captureAll $: imgA\n\nimgA toQuote leaves: '[byteslice, consists of 38298 byte(s)]' \"yours may differ!\"\n\n\"Note: [ 1 2 3 ] lives in a parallel universe now, with\n its own friends, prototypes, toplevel block, and so on!\n It doesn't have any links whatsoever to the whoever-it-was\n that called nki:captureAll!\"\nimgA nki:toBlock leaves: [ [ 1 2 3 ] ]\n```"
    },
    "nki:captureAllRaw": {
      "name": "nki:captureAllRaw",
      "desc": "( B -- Bf ): same as `nki:captureAll`, but doesn't archive\n image payload. May yield very large Byteslice forms."
    },
    "nki:captureNeighborhoodRaw": {
      "name": "nki:captureNeighborhoodRaw",
      "desc": "( B -- Bf ): same as `nki:captureNeighborhood`, but doesn't\n archive image payload. May yield large Byteslice forms."
    },
    "nki:captureAllGzipBest": {
      "name": "nki:captureAllGzipBest",
      "desc": "( B -- Bf ): same as `nki:captureAll`, but archives image\n payload using Gzip, best."
    },
    "nki:captureNeighborhoodGzipBest": {
      "name": "nki:captureNeighborhoodGzipBest",
      "desc": "( B -- Bf ): same as `nki:captureNeighborhood`, but\n archives image payload using Gzip, best."
    },
    "nki:captureAllBrotliFast": {
      "name": "nki:captureAllBrotliFast",
      "desc": "( B -- Bf ): same as `nki:captureAll`, but archives image\n payload using Brotli, fast."
    },
    "nki:captureNeighborhoodBrotliFast": {
      "name": "nki:captureNeighborhoodBrotliFast",
      "desc": "( B -- Bf ): same as `nki:captureNeighborhood`, but\n archives image payload using Brotli, fast."
    },
    "nki:captureAllBrotliBest": {
      "name": "nki:captureAllBrotliBest",
      "desc": "( B -- Bf ): same as `nki:captureAll`, but archives image\n payload using Brotli, best."
    },
    "nki:captureNeighborhoodBrotliBest": {
      "name": "nki:captureNeighborhoodBrotliBest",
      "desc": "( B -- Bf ): same as `nki:captureNeighborhood`, but\n archives image payload using Brotli, best."
    },
    "console:on": {
      "name": "console:on",
      "desc": "( -- ): enables the console. Must be called before using\n any other console-related word."
    },
    "console:off": {
      "name": "console:off",
      "desc": "( -- ): disables the console. Must be called at the end\n of your program or when you don't need console anymore."
    },
    "console:compat": {
      "name": "console:compat",
      "desc": "( -- ): enables the compatibility color output mode. In\n this mode, only 8 colors are available. All RGB colors\n are automatically reduced to one of those 8 colors."
    },
    "console:256": {
      "name": "console:256",
      "desc": "( -- ): enables the 256-color output mode. In this mode,\n 256 colors are available. All RGB colors are automatically\n reduced to one of those 256 colors."
    },
    "console:truecolor": {
      "name": "console:truecolor",
      "desc": "( -- ): enables the truecolor output mode. In this mode,\nall colors are available and are passed to the console\nas-is."
    },
    "console:size": {
      "name": "console:size",
      "desc": "( -- Cw Ch ): leaves the Console width (in columns) and\n Console height (in rows)."
    },
    "console:setTimeout": {
      "name": "console:setTimeout",
      "desc": "( D -- ): sets input timeout to Duration, given in *milliseconds*.\n\n * If Duration is negative, `console:readKey` will wait\n   for input indefinitely (i.e., until there is input).\n\n * If Duration is zero, `console:readKey` won't wait for\n   input at all, but make note if there is any at the moment.\n\n * If Duration is positive, `console:readKey` will peek\n   during the timeout window."
    },
    "console:readKey": {
      "name": "console:readKey",
      "desc": "( -- ): peeks or waits for input. See `console:setTimeout`.\n Refreshes the input state. Use `console:hadKeyPressed` and\n friends to explore the input state afterwards."
    },
    "console:hadKeyPressed?": {
      "name": "console:hadKeyPressed?",
      "desc": "( -- B ): leaves Boolean for whether any key was pressed."
    },
    "console:hadCtrlPressed?": {
      "name": "console:hadCtrlPressed?",
      "desc": "( -- B ): leaves Boolean for whether the CTRL key was pressed."
    },
    "console:hadAltPressed?": {
      "name": "console:hadAltPressed?",
      "desc": "( -- B ): leaves Boolean for whether the ALT key was pressed."
    },
    "console:hadShiftPressed?": {
      "name": "console:hadShiftPressed?",
      "desc": "( -- B ): leaves Boolean for whether the SHIFT key was pressed."
    },
    "console:hadBackspacePressed?": {
      "name": "console:hadBackspacePressed?",
      "desc": "( -- B ): leaves Boolean for whether the Backspace key\n was pressed."
    },
    "console:hadFnPressed?": {
      "name": "console:hadFnPressed?",
      "desc": "( -- B ): leaves Boolean for whether one of the function\n keys F1-F12 was pressed."
    },
    "console:hadInsertPressed?": {
      "name": "console:hadInsertPressed?",
      "desc": "( -- B ): leaves Boolean for whether the INSERT key was pressed."
    },
    "console:hadDeletePressed?": {
      "name": "console:hadDeletePressed?",
      "desc": "( -- B ): leaves Boolean for whether the DELETE key was pressed."
    },
    "console:hadHomePressed?": {
      "name": "console:hadHomePressed?",
      "desc": "( -- B ): leaves Boolean for whether the HOME key was pressed."
    },
    "console:hadEndPressed?": {
      "name": "console:hadEndPressed?",
      "desc": "( -- B ): leaves Boolean for whether the END key was pressed."
    },
    "console:hadPageUpPressed?": {
      "name": "console:hadPageUpPressed?",
      "desc": "( -- B ): leaves Boolean for whether the PAGE UP key was pressed."
    },
    "console:hadPageDownPressed?": {
      "name": "console:hadPageDownPressed?",
      "desc": "( -- B ): leaves Boolean for whether the PAGE DOWN key was pressed."
    },
    "console:hadLeftPressed?": {
      "name": "console:hadLeftPressed?",
      "desc": "( -- B ): leaves Boolean for whether the LEFT ARROW key\n was pressed."
    },
    "console:hadRightPressed?": {
      "name": "console:hadRightPressed?",
      "desc": "( -- B ): leaves Boolean for whether the RIGHT ARROW key\n was pressed."
    },
    "console:hadUpPressed?": {
      "name": "console:hadUpPressed?",
      "desc": "( -- B ): leaves Boolean for whether the UP ARROW key\n was pressed."
    },
    "console:hadDownPressed?": {
      "name": "console:hadDownPressed?",
      "desc": "( -- B ): leaves Boolean for whether the DOWN ARROW key\n was pressed."
    },
    "console:hadCharPressed?": {
      "name": "console:hadCharPressed?",
      "desc": "( -- B ): leaves Boolean for whether EXCLUSIVELY a printable\n character key was pressed (no CTRL, ALT, etc.) Whether the\n SHIFT key was pressed or not is ignored."
    },
    "console:getCharPressed": {
      "name": "console:getCharPressed",
      "desc": "( -- Cq ): leaves Char quote for the key that was pressed.\n Usually a lowercase or uppercase letter; but also may look\n like `'\n'` or `'\t'`, etc.)\n\nIn case the key that was pressed cannot be represented\nby the means of a quote, or if the user did not press\nany key, an empty quote is left in place of Char quote."
    },
    "console:change": {
      "name": "console:change",
      "desc": "( X Y -- ): changes the color of the cell at X, Y coordinates\n to be the foreground, background colors set by ink's\n `withEchoFg` and `withEchoBg`."
    },
    "console:appendEcho": {
      "name": "console:appendEcho",
      "desc": "( F X Y -- ): appends echo of Form at an X and Y position\n (in columns and rows correspondingly) using the foreground,\n background colors set by ink's `withEchoFg` and `withEchoBg`."
    },
    "console:withReverseAppendEcho": {
      "name": "console:withReverseAppendEcho",
      "desc": "( F X Y -- ): appends Form with foreground and background\n colors swapped with each other (background color is set\n to foreground color, and vice versa)."
    },
    "console:present": {
      "name": "console:present",
      "desc": "( -- ): syncs internal buffer and console."
    },
    "console:clear": {
      "name": "console:clear",
      "desc": "( -- ): clears console with primary colors."
    },
    "disk:has?": {
      "name": "disk:has?",
      "desc": "( Pq -- true/false ): leaves whether Path quote exists\n on the disk."
    },
    "disk:canRead?": {
      "name": "disk:canRead?",
      "desc": "( Pq -- true/false ): leaves whether Path quote exists\n and is readable."
    },
    "disk:hasDir?": {
      "name": "disk:hasDir?",
      "desc": "( Pq -- true/false ): leaves whether Path quote exists\n and points to a directory."
    },
    "disk:hasFile?": {
      "name": "disk:hasFile?",
      "desc": "( Pq -- true/false ): leaves whether Path quote exists\n and points to a file."
    },
    "disk:hasSymlink?": {
      "name": "disk:hasSymlink?",
      "desc": "( Pq -- true/false ): leaves whether Path quote exists\n and points to a symlink."
    },
    "disk:dirEmpty?": {
      "name": "disk:dirEmpty?",
      "desc": "( Ptd -- B ): leaves Boolean for whether Path to directory\n is empty. Dies if Path to directory points to something\n other than a directory, or doesn't exist."
    },
    "disk:join": {
      "name": "disk:join",
      "desc": "( Bp Cp -- P ): leaves Path, which is the result of joining Base\n path and Child path using the platform-specific path separator.\n\n```\n'hello' 'world' disk:join leaves: 'hello/world' \"On Unix\"\n'hello' 'world' disk:join leaves: 'hello\\world' \"On Windows\"\n```"
    },
    "disk:pwd": {
      "name": "disk:pwd",
      "desc": "( -- Wd ): leaves current Working directory."
    },
    "disk:touch": {
      "name": "disk:touch",
      "desc": "( P -- ): creates an empty file at Path. Does nothing\n if Path already exists."
    },
    "disk:mkdir": {
      "name": "disk:mkdir",
      "desc": "( P -- ): creates an empty directory at Path, including\n any non-existing intermediate directories. Does nothing\n if Path already exists."
    },
    "disk:copy": {
      "name": "disk:copy",
      "desc": "( S D -- ): copies Source (quote path to a file, symlink,\n or directory) to Destination (also a quote).\n\nIf Source is a directory, copies it recursively.\nIf copy process failed, dies."
    },
    "disk:read": {
      "name": "disk:read",
      "desc": "( F -- C ): reads and leaves the Contents of File. Dies\n if there is no File."
    },
    "disk:write": {
      "name": "disk:write",
      "desc": "( Cq/B Fp -- ): (over)writes content of file at File path\n with Content quote/Byteslice. Dies if File path doesn't\n exist or doesn't point to a file."
    },
    "ffi:library?": {
      "name": "ffi:library?",
      "desc": "( F -- true/false ): leaves whether Form is a foreign\n library form.\n\n```\n'foo' ffi:getLibrary ffi:library? leaves: true\n```"
    },
    "ffi:layout?": {
      "name": "ffi:layout?",
      "desc": "( F -- true/false ): leaves whether Form is a foreign\n layout form.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:layout? leaves: true\n```"
    },
    "ffi:struct&?": {
      "name": "ffi:struct&?",
      "desc": "( F -- true/false ): leaves whether Form is a struct\n reference view form.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct& $: point&\npoint& ffi:struct&? leaves: true\n```"
    },
    "ffi:struct~?": {
      "name": "ffi:struct~?",
      "desc": "( F -- true/false ): leaves whether Form is an inline\n struct view form.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct~ $: point~\npoint~ ffi:struct~? leaves: true\n```"
    },
    "ffi:union?": {
      "name": "ffi:union?",
      "desc": "( F -- true/false ): leaves whether Form is a union\n view form.\n\n```\n[ chr char ord u8 ] ffi:createLayout $: quux\n\nquux ffi:allocateUnion $: quuxU\nquuxU ffi:union? leaves: true\n```"
    },
    "ffi:hole?": {
      "name": "ffi:hole?",
      "desc": "( F -- true/false ): leaves whether Form is a hole.\n\n```\n#i32 ffi:hole $: intHole\n\nintHole ffi:hole? leaves: true\n```"
    },
    "ffi:getLibrary?": {
      "name": "ffi:getLibrary?",
      "desc": "( I -- Lf true / false ): leaves Library form followed by true\n if dynamic library with the given Id exists and was loaded &\n retrieved successfully; otherwise, leaves false.\n\nOpening Library form allows one to expose functions from the\nunderlying dynamic library (.so on Linux, .dll on Windows,\n.dylib on Mac). See FFI documentation on GitHub Wiki for more\ndetails and examples.\n\n```\n'SDL2' ffi:getLibrary? leaves: [ \"[foreign library]\" true ]\n'random-nonexisting-library' ffi:getLibrary? leaves: false\n```"
    },
    "ffi:getLibrary": {
      "name": "ffi:getLibrary",
      "desc": "( I -- Lf ): leaves Library form if dynamic library with the\n given Id exists and was loaded & retrieved successfully;\n otherwise, dies.\n\nOpening Library form allows one to expose functions from the\nunderlying dynamic library (.so on Linux, .dll on Windows,\n.dylib on Mac). See FFI documentation on GitHub Wiki for more\ndetails and examples.\n\n```\n'SDL2' ffi:getLibrary ffi:library? leaves: true\n'random-nonexisting-library' ffi:getLibrary \"Dies: no such library\"\n```"
    },
    "ffi:createLayout": {
      "name": "ffi:createLayout",
      "desc": "( Lb -- Slf ): parses Layout block and leaves the resulting\n Struct layout form.\n\nStruct layouts are a generalization over structs (heap-\nallocated and stack-allocated) and unions. They literally\ndescribe how structs (unions) are layed out in memory.\n\nLayout block consists of *name words followed by type words*.\nSee the example below. A reference to another struct layout\ncan be made in Layout block using the prefixes `&` (heap-\nallocated struct, i.e., pointer to struct), `~` (inline or\nstack-allocated struct), and `?` (stack-allocated union).\n\nInline struct cycles are forbidden. Union cycles are forbidden.\nEither could be hidden behind a reference/pointer.\n\nLayout block is parsed lazily (on first use, e.g., by `toQuote`,\n`allocateStruct` variants, `=`, etc.) Therefore, you can define\nself-referential structs, mutually referential structs, and\nreference layouts that are defined later.\n\nSee FFI documentation on GitHub Wiki for a list of available\ntypes and the corresponding C types.\n\n```\n[ x f32\n  y f32\n] ffi:createLayout $: point\n\n[ datum ~point    \"<- inline struct\"\n  next &pointNode \"<- struct reference\"\n] ffi:createLayout $: pointNode\n\n[ asPoint &point\n  asPointNode ~pointNode\n] ffi:createLayout $: pointNodeUnion\n\n[ type u8\n  value ?pointNodeUnion \"<- stack-allocated union\"\n] ffi:createLayout $: pointNodeOrPoint\n```"
    },
    "ffi:allocateStruct~": {
      "name": "ffi:allocateStruct~",
      "desc": "( Slf -- Isv ): allocates Inline struct view for the\n given Struct layout form. If the struct is no longer in\n use, it is freed by the GC automatically.\n\nThis word is **unsafe**: the resulting Inline struct view is\nin an undefined state (may contain junk) before you (or the\nC code you pass it to) fills it with good values. Showing\nthe struct view left by this word to clients may expose your\nprogram to a whole class of security vulnerabilities.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct~ $: point~\npoint~ #x 123 entry:submit\npoint~ #y 456 entry:submit\npoint~ toQuote leaves: '~⟨x=123_i32, y=456_i32⟩'\n```"
    },
    "ffi:buildStruct~": {
      "name": "ffi:buildStruct~",
      "desc": "( Eb Slf -- Isv ): allocates and fills Inline struct\n view with entries by asking Entry block for them.\n\nIf Entry block is missing an entry matching a field that\nStruct layout form declares, and that field is of type\n`pointer` or struct reference (`&`), `none` (C nullptr)\nis used as the value. Dies if Entry block is missing\nmatching entry or entries for fields of other types.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\n100 $: x\n200 $: y\n\n\"Note: `this` has entries called `x` and `y`. `point` has\n fields called `x` and `y`. A match!\"\nthis point ffi:buildStruct~ $: point~\n\npoint~ toQuote leaves: '~⟨x=100_i32, y=200_i32⟩'\n```"
    },
    "ffi:asStruct~": {
      "name": "ffi:asStruct~",
      "desc": "( A Slf -- Isv ): creates and leaves Inline struct view\n for the given Address, according to Struct layout form.\n\nThis word is **unsafe**: it does not check whether Address\npoints at something that is layed out according to Struct\nlayout form. Passing 0 (none aka null pointer) for Address\nwill lead to segfault. Passing Address that is outside of\nyour program's memory will lead to segfault. Passing Address\nthat *is* in the bounds of your program's memory, but one\nnot pointing at a struct in accordance with Struct layout\nform, will lead to undefined behavior (most likely junk\nvalues in Inline struct view).\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\n100 $: x\n200 $: y\nthis point ffi:buildStruct~ $: point~\n\npoint~ ffi:addressof $: addr\n\naddr point ffi:asStruct~ $: addrPoint~\naddrPoint~.x leaves: x\naddrPoint~.y leaves: y\naddrPoint~ toQuote leaves: '~⟨x=100_i32, y=200_i32⟩'\n```"
    },
    "ffi:allocateStruct&": {
      "name": "ffi:allocateStruct&",
      "desc": "( Slf -- Srv ): allocates Struct reference view for the\n given Struct layout form. If the struct is no longer in\n use, it is freed by the GC automatically.\n\nThis word is **unsafe**: the resulting Struct reference view is\nin an undefined state (may contain junk) before you (or the\nC code you pass it to) fills it with good values. Showing\nthe struct view left by this word to clients may expose your\nprogram to a whole class of security vulnerabilities.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct& $: point&\npoint& #x 123 entry:submit\npoint& #y 456 entry:submit\npoint& toQuote leaves: '&⟨x=123_i32, y=456_i32⟩'\n```"
    },
    "ffi:buildStruct&": {
      "name": "ffi:buildStruct&",
      "desc": "( Eb Slf -- Srv ): allocates and fills Struct reference\n view with entries by asking Entry block for them.\n\nIf Entry block is missing an entry matching a field that\nStruct layout form declares, and that field is of type\n`pointer` or struct reference (`&`), `none` (C nullptr)\nis used as the value. Dies if Entry block is missing\nmatching entry or entries for fields of other types.\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\n100 $: x\n200 $: y\n\n\"Note: `this` has entries called `x` and `y`. `point` has\n fields called `x` and `y`. A match!\"\nthis point ffi:buildStruct& $: point&\n\npoint& toQuote leaves: '&⟨x=100_i32, y=200_i32⟩'\n```"
    },
    "ffi:asStruct&": {
      "name": "ffi:asStruct&",
      "desc": "( A Slf -- Srv ): creates and leaves Struct reference view\n for the given Address, according to Struct layout form.\n\nThis word is **unsafe**: it does not check whether Address\npoints at something that is layed out according to Struct\nlayout form. Passing 0 (none aka null pointer) for Address\nwill lead to segfault. Passing Address that is outside of\nyour program's memory will lead to segfault. Passing Address\nthat *is* in the bounds of your program's memory, but one\nnot pointing at a struct in accordance with Struct layout\nform, will lead to undefined behavior (most likely junk\nvalues in Struct reference view).\n\n```\n[ x i32 y i32 ] ffi:createLayout $: point\n\n100 $: x\n200 $: y\nthis point ffi:buildStruct& $: point&\n\npoint& ffi:addressof $: addr\n\naddr point ffi:asStruct& $: addrPoint&\naddrPoint&.x leaves: x\naddrPoint&.y leaves: y\naddrPoint& toQuote leaves: '&⟨x=100_i32, y=200_i32⟩'\n```"
    },
    "ffi:allocateUnion": {
      "name": "ffi:allocateUnion",
      "desc": "( Slf -- Uv ): allocates Union view for the given Struct\n layout form.\n\nThis word is **unsafe**: the resulting Union view is in\nan undefined (uninitialized) state (may be zeroed out,\ncontain junk, or both) before you (or the C code you pass\nit to) fills it with good values. Showing the uninitialized\nunion to clients may expose your program to a whole class\nof security vulnerabilities.\n\n```\n[ chr char\n  ord u8\n] ffi:createLayout $: quux\n\nquux ffi:allocateUnion $: quuxUnion\nquuxUnion #chr 'A' entry:submit\nquuxUnion.ord leaves: 65\n\n\"Union toQuote avoids printing values, because that could\n cause a segfault/overflow in some cases, and would mostly\n output junk anyway.\"\nquuxUnion toQuote leaves: '(⋃ ⟪chr=char, ord=u8⟫)'\n```"
    },
    "ffi:buildUnion": {
      "name": "ffi:buildUnion",
      "desc": "( Eb Slf -- Uv ): allocates and fills Union view with an\n entry by asking Entry block for any *one* entry out of\n those specified in Struct layout form, in the order they\n are specified in Struct layout form. If the union is no\n longer in use, it is freed by the GC automatically.\n\nEntry block must have at least one of the Struct layout\nform's fields defined. Otherwise, this word dies.\n\n```\n[ chr char\n  ord u8\n] ffi:createLayout $: quux\n\n[ 'A' $: chr\n  this quux ffi:buildUnion\n] val $: unionByChr\n\n[ 66 $: ord\n  this quux ffi:buildUnion\n] val $: unionByOrd\n\n[ 'A' $: chr\n  123 $: ord\n  this quux ffi:buildUnion\n] val $: unionBoth\n\nunionByChr.ord leaves: 65\nunionByOrd.chr leaves: 'B'\n\n\"'chr' is defined first, therefore, it is used rather\n than 'ord'\"\nunionBoth.chr leaves: 'A'\nunionBoth.ord leaves: 65\n```"
    },
    "ffi:asUnion": {
      "name": "ffi:asUnion",
      "desc": "( A Slf -- Uv ): creates and leaves a Union view for the\n given Address, according to Struct layout form.\n\nThis word is **unsafe**: it does not check whether Address\npoints at something that is layed out according to Struct\nlayout form. Passing 0 (none aka null pointer) for Address\nwill lead to segfault. Passing Address that points outside\nof your program's memory will lead to segfault. Passing\nAddress that *is* in the bounds of your program's memory,\nbut one not pointing at a union in accordance with Struct\nlayout form, will lead to undefined behavior (most likely\njunk values in Union view). Showing ill-formed results of\nthis word to clients may expose your program to a whole\nclass of security vulnerabilities.\n\n```\n[ chr char\n  ord u8\n] ffi:createLayout $: quux\n\n'A' $: chr\n\nthis quux ffi:buildUnion $: quuxUnion\n\nquuxUnion ffi:addressof $: addr\n\naddr quux ffi:asUnion $: addrUnion\naddrUnion.chr leaves: 'A'\naddrUnion.ord leaves: 65\n```"
    },
    "ffi:hole": {
      "name": "ffi:hole",
      "desc": "( T/Oh -- H ): allocates garbage-collected memory for Hole\n that will hold a value of the given Type. If Other hole\n is passed, wraps that Other hole instead (this could be\n useful in C situations like `int**`)\n\nHoles are (just a bit) safer way of letting C write to a\nmemory location. You first create the hole, then pass it\nto C, then read from the hole by opening it.\n\nNote: this word is **unsafe**: since we cannot check whether\nthe hole was written to, reading from hole (opening it) before\nwriting to it will result in undefined behavior.\n\n```\n\"\"\"\nvoid outputCInt(int* x)\n{\n  *x = 123;\n}\n\"\"\"\n\n#i32 ffi:hole $: intBox\n\nintBox outputCInt\nintBox open leaves: 123\n```"
    },
    "ffi:box": {
      "name": "ffi:box",
      "desc": "( F T -- A ): allocates garbage-collected memory for Type, and\n writes Form there. Form must be of (or convertible to) Type;\n otherwise, this word dies. Leaves Address of the beginning of\n the allocated memory.\n\n```\n123 #i32 ffi:box $: ptr\nptr #i32 ffi:unbox leaves: 123\n```"
    },
    "ffi:unbox": {
      "name": "ffi:unbox",
      "desc": "( A T -- F ): interprets whatever Address points at as a\n value of the given Type, and leaves the matching Form.\n Inverse of `ffi:box`.\n\nThis word is **unsafe**: it does not check whether Address\npoints at something that is of the given Type. Passing 0\n(none aka null pointer) for Address will lead to segfault.\nPassing Address that points outside of your program's memory\nwill lead to segfault. Passing Address that *is* in the bounds\nof your program's memory, but one not pointing at a value of\nthe given Type, will lead to undefined behavior (most likely\njunk value of Form). Showing ill-formed results of this word to\nclients, or letting clients control Address or Type, may expose\nyour program to a whole class of security vulnerabilities.\n\n```\n123 #i32 ffi:box $: ptr\nptr #i32 ffi:unbox leaves: 123\n```"
    },
    "ffi:unsafeWrite": {
      "name": "ffi:unsafeWrite",
      "desc": "( A F T -- ): interprets Form as that of the given Type,\n and writes it at Address.\n\nThis word is **unsafe**: it does not check whether Address\ncan be written to, whether there is enough memory to fully\nwrite Form, etc. Passing 0 (none aka null pointer) for Address\nwill lead to segfault. Passing Address that points outside\nof your program's memory will lead to segfault. Passing Address\nthat *is* in the bounds of your program's memory and can\nbe written to may lead to undefined behavior.\n\n```\n#i32 ffi:hole $: myHole\nmyHole ffi:addressof $: holeAddr\nholeAddr 123 #i32 ffi:unsafeWrite\nmyHole open leaves: 123\n```"
    },
    "ffi:viewLayout": {
      "name": "ffi:viewLayout",
      "desc": "( Svf -- Slf ): leaves Struct layout form for the given\n Struct view form (an inline struct view, struct reference\n view, or union view).\n\n```\n[ x f32 y f32 ] ffi:createLayout $: point\n\npoint ffi:allocateStruct& $: point&\npoint ffi:allocateStruct~ $: point~\npoint ffi:allocateUnion $: pointU\n\npoint& ffi:viewLayout leaves: point\npoint~ ffi:viewLayout leaves: point\npointU ffi:viewLayout leaves: point\n```"
    },
    "ffi:sizeof": {
      "name": "ffi:sizeof",
      "desc": "( T -- B ): leaves the size of Type, in Bytes.\n\n```\n#u8  ffi:sizeof leaves: 1\n#u16 ffi:sizeof leaves: 2\n#u32 ffi:sizeof leaves: 4\n#u64 ffi:sizeof leaves: 8\n```"
    },
    "ffi:addressof": {
      "name": "ffi:addressof",
      "desc": "( Svf/H -- A ): leaves Address of the given Struct view form\n (an inline struct view, struct reference view, or union view),\n or Hole in memory.\n\n```\n#i32 ffi:hole $: myHole\nmyHole ffi:addressof $: holeAddr\nholeAddr 123 #i32 ffi:unsafeWrite\nmyHole open leaves: 123\n```"
    }
  }
}
